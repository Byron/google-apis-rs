<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An extension trait which adds utility methods to `AsyncBufRead` types."><title>AsyncBufReadExt in tokio::io - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="tokio" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../tokio/index.html">tokio</a><span class="version">1.33.0</span></h2></div><h2 class="location"><a href="#">AsyncBufReadExt</a></h2><div class="sidebar-elems"><section><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.consume">consume</a></li><li><a href="#method.fill_buf">fill_buf</a></li><li><a href="#method.lines">lines</a></li><li><a href="#method.read_line">read_line</a></li><li><a href="#method.read_until">read_until</a></li><li><a href="#method.split">split</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In tokio::io</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../tokio/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../index.html">tokio</a>::<wbr><a href="index.html">io</a>::<wbr><a class="trait" href="#">AsyncBufReadExt</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/tokio/io/util/async_buf_read_ext.rs.html#12-348">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait AsyncBufReadExt: <a class="trait" href="trait.AsyncBufRead.html" title="trait tokio::io::AsyncBufRead">AsyncBufRead</a> {
    // Provided methods
    fn <a href="#method.read_until" class="fn">read_until</a>&lt;'a&gt;(
        &amp;'a mut self,
        byte: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.u8.html">u8</a>,
        buf: &amp;'a mut <a class="struct" href="https://doc.rust-lang.org/1.76.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.u8.html">u8</a>&gt;
    ) -&gt; ReadUntil&lt;'a, Self&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_line" class="fn">read_line</a>&lt;'a&gt;(&amp;'a mut self, buf: &amp;'a mut <a class="struct" href="https://doc.rust-lang.org/1.76.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) -&gt; ReadLine&lt;'a, Self&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.split" class="fn">split</a>(self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.u8.html">u8</a>) -&gt; <a class="struct" href="struct.Split.html" title="struct tokio::io::Split">Split</a>&lt;Self&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.fill_buf" class="fn">fill_buf</a>(&amp;mut self) -&gt; FillBuf&lt;'_, Self&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.consume" class="fn">consume</a>(&amp;mut self, amt: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.usize.html">usize</a>)
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.lines" class="fn">lines</a>(self) -&gt; <a class="struct" href="struct.Lines.html" title="struct tokio::io::Lines">Lines</a>&lt;Self&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An extension trait which adds utility methods to <a href="trait.AsyncBufRead.html" title="trait tokio::io::AsyncBufRead"><code>AsyncBufRead</code></a> types.</p>
</div></details><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.read_until" class="method"><a class="src rightside" href="../../src/tokio/io/util/async_buf_read_ext.rs.html#96-101">source</a><h4 class="code-header">fn <a href="#method.read_until" class="fn">read_until</a>&lt;'a&gt;(
    &amp;'a mut self,
    byte: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.u8.html">u8</a>,
    buf: &amp;'a mut <a class="struct" href="https://doc.rust-lang.org/1.76.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.u8.html">u8</a>&gt;
) -&gt; ReadUntil&lt;'a, Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h4></section></summary><div class="docblock"><p>Reads all bytes into <code>buf</code> until the delimiter <code>byte</code> or EOF is reached.</p>
<p>Equivalent to:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">async fn </span>read_until(<span class="kw-2">&amp;mut </span><span class="self">self</span>, byte: u8, buf: <span class="kw-2">&amp;mut </span>Vec&lt;u8&gt;) -&gt; io::Result&lt;usize&gt;;</code></pre></div>
<p>This function will read bytes from the underlying stream until the
delimiter or EOF is found. Once found, all bytes up to, and including,
the delimiter (if found) will be appended to <code>buf</code>.</p>
<p>If successful, this function will return the total number of bytes read.</p>
<p>If this function returns <code>Ok(0)</code>, the stream has reached EOF.</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>This function will ignore all instances of <a href="https://doc.rust-lang.org/1.76.0/std/io/error/enum.ErrorKind.html#variant.Interrupted" title="variant std::io::error::ErrorKind::Interrupted"><code>ErrorKind::Interrupted</code></a> and
will otherwise return any errors returned by <a href="trait.AsyncBufRead.html#tymethod.poll_fill_buf" title="method tokio::io::AsyncBufRead::poll_fill_buf"><code>fill_buf</code></a>.</p>
<p>If an I/O error is encountered then all bytes read so far will be
present in <code>buf</code> and its length will have been adjusted appropriately.</p>
<h5 id="cancel-safety"><a href="#cancel-safety">Cancel safety</a></h5>
<p>If the method is used as the event in a
<a href="../macro.select.html" title="macro tokio::select"><code>tokio::select!</code></a> statement and some other branch
completes first, then some data may have been partially read. Any
partially read bytes are appended to <code>buf</code>, and the method can be
called again to continue reading until <code>byte</code>.</p>
<p>This method returns the total number of bytes read. If you cancel
the call to <code>read_until</code> and then call it again to continue reading,
the counter is reset.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<p><a href="https://doc.rust-lang.org/1.76.0/std/io/cursor/struct.Cursor.html" title="struct std::io::cursor::Cursor"><code>std::io::Cursor</code></a> is a type that implements <code>BufRead</code>. In
this example, we use <a href="https://doc.rust-lang.org/1.76.0/std/io/cursor/struct.Cursor.html" title="struct std::io::cursor::Cursor"><code>Cursor</code></a> to read all the bytes in a byte slice
in hyphen delimited segments:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::io::AsyncBufReadExt;

<span class="kw">use </span>std::io::Cursor;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>cursor = Cursor::new(<span class="string">b"lorem-ipsum"</span>);
    <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="macro">vec!</span>[];

    <span class="comment">// cursor is at 'l'
    </span><span class="kw">let </span>num_bytes = cursor.read_until(<span class="string">b'-'</span>, <span class="kw-2">&amp;mut </span>buf)
        .<span class="kw">await
        </span>.expect(<span class="string">"reading from cursor won't fail"</span>);

    <span class="macro">assert_eq!</span>(num_bytes, <span class="number">6</span>);
    <span class="macro">assert_eq!</span>(buf, <span class="string">b"lorem-"</span>);
    buf.clear();

    <span class="comment">// cursor is at 'i'
    </span><span class="kw">let </span>num_bytes = cursor.read_until(<span class="string">b'-'</span>, <span class="kw-2">&amp;mut </span>buf)
        .<span class="kw">await
        </span>.expect(<span class="string">"reading from cursor won't fail"</span>);

    <span class="macro">assert_eq!</span>(num_bytes, <span class="number">5</span>);
    <span class="macro">assert_eq!</span>(buf, <span class="string">b"ipsum"</span>);
    buf.clear();

    <span class="comment">// cursor is at EOF
    </span><span class="kw">let </span>num_bytes = cursor.read_until(<span class="string">b'-'</span>, <span class="kw-2">&amp;mut </span>buf)
        .<span class="kw">await
        </span>.expect(<span class="string">"reading from cursor won't fail"</span>);
    <span class="macro">assert_eq!</span>(num_bytes, <span class="number">0</span>);
    <span class="macro">assert_eq!</span>(buf, <span class="string">b""</span>);
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_line" class="method"><a class="src rightside" href="../../src/tokio/io/util/async_buf_read_ext.rs.html#199-204">source</a><h4 class="code-header">fn <a href="#method.read_line" class="fn">read_line</a>&lt;'a&gt;(&amp;'a mut self, buf: &amp;'a mut <a class="struct" href="https://doc.rust-lang.org/1.76.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) -&gt; ReadLine&lt;'a, Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h4></section></summary><div class="docblock"><p>Reads all bytes until a newline (the 0xA byte) is reached, and append
them to the provided buffer.</p>
<p>Equivalent to:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">async fn </span>read_line(<span class="kw-2">&amp;mut </span><span class="self">self</span>, buf: <span class="kw-2">&amp;mut </span>String) -&gt; io::Result&lt;usize&gt;;</code></pre></div>
<p>This function will read bytes from the underlying stream until the
newline delimiter (the 0xA byte) or EOF is found. Once found, all bytes
up to, and including, the delimiter (if found) will be appended to
<code>buf</code>.</p>
<p>If successful, this function will return the total number of bytes read.</p>
<p>If this function returns <code>Ok(0)</code>, the stream has reached EOF.</p>
<h5 id="errors-1"><a href="#errors-1">Errors</a></h5>
<p>This function has the same error semantics as <a href="trait.AsyncBufReadExt.html#method.read_until" title="method tokio::io::AsyncBufReadExt::read_until"><code>read_until</code></a> and will
also return an error if the read bytes are not valid UTF-8. If an I/O
error is encountered then <code>buf</code> may contain some bytes already read in
the event that all data read so far was valid UTF-8.</p>
<h5 id="cancel-safety-1"><a href="#cancel-safety-1">Cancel safety</a></h5>
<p>This method is not cancellation safe. If the method is used as the
event in a <a href="../macro.select.html" title="macro tokio::select"><code>tokio::select!</code></a> statement and some
other branch completes first, then some data may have been partially
read, and this data is lost. There are no guarantees regarding the
contents of <code>buf</code> when the call is cancelled. The current
implementation replaces <code>buf</code> with the empty string, but this may
change in the future.</p>
<p>This function does not behave like <a href="trait.AsyncBufReadExt.html#method.read_until" title="method tokio::io::AsyncBufReadExt::read_until"><code>read_until</code></a> because of the
requirement that a string contains only valid utf-8. If you need a
cancellation safe <code>read_line</code>, there are three options:</p>
<ul>
<li>Call <a href="trait.AsyncBufReadExt.html#method.read_until" title="method tokio::io::AsyncBufReadExt::read_until"><code>read_until</code></a> with a newline character and manually perform the utf-8 check.</li>
<li>The stream returned by <a href="trait.AsyncBufReadExt.html#method.lines"><code>lines</code></a> has a cancellation safe
<a href="struct.Lines.html#method.next_line" title="method tokio::io::Lines::next_line"><code>next_line</code></a> method.</li>
<li>Use <a href="https://docs.rs/tokio-util/latest/tokio_util/codec/struct.LinesCodec.html"><code>tokio_util::codec::LinesCodec</code></a>.</li>
</ul>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p><a href="https://doc.rust-lang.org/1.76.0/std/io/cursor/struct.Cursor.html" title="struct std::io::cursor::Cursor"><code>std::io::Cursor</code></a> is a type that implements
<code>AsyncBufRead</code>. In this example, we use <a href="https://doc.rust-lang.org/1.76.0/std/io/cursor/struct.Cursor.html" title="struct std::io::cursor::Cursor"><code>Cursor</code></a> to read all the
lines in a byte slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::io::AsyncBufReadExt;

<span class="kw">use </span>std::io::Cursor;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>cursor = Cursor::new(<span class="string">b"foo\nbar"</span>);
    <span class="kw">let </span><span class="kw-2">mut </span>buf = String::new();

    <span class="comment">// cursor is at 'f'
    </span><span class="kw">let </span>num_bytes = cursor.read_line(<span class="kw-2">&amp;mut </span>buf)
        .<span class="kw">await
        </span>.expect(<span class="string">"reading from cursor won't fail"</span>);

    <span class="macro">assert_eq!</span>(num_bytes, <span class="number">4</span>);
    <span class="macro">assert_eq!</span>(buf, <span class="string">"foo\n"</span>);
    buf.clear();

    <span class="comment">// cursor is at 'b'
    </span><span class="kw">let </span>num_bytes = cursor.read_line(<span class="kw-2">&amp;mut </span>buf)
        .<span class="kw">await
        </span>.expect(<span class="string">"reading from cursor won't fail"</span>);

    <span class="macro">assert_eq!</span>(num_bytes, <span class="number">3</span>);
    <span class="macro">assert_eq!</span>(buf, <span class="string">"bar"</span>);
    buf.clear();

    <span class="comment">// cursor is at EOF
    </span><span class="kw">let </span>num_bytes = cursor.read_line(<span class="kw-2">&amp;mut </span>buf)
        .<span class="kw">await
        </span>.expect(<span class="string">"reading from cursor won't fail"</span>);

    <span class="macro">assert_eq!</span>(num_bytes, <span class="number">0</span>);
    <span class="macro">assert_eq!</span>(buf, <span class="string">""</span>);
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><a class="src rightside" href="../../src/tokio/io/util/async_buf_read_ext.rs.html#240-245">source</a><h4 class="code-header">fn <a href="#method.split" class="fn">split</a>(self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.u8.html">u8</a>) -&gt; <a class="struct" href="struct.Split.html" title="struct tokio::io::Split">Split</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h4></section></summary><div class="docblock"><p>Returns a stream of the contents of this reader split on the byte
<code>byte</code>.</p>
<p>This method is the asynchronous equivalent to
<a href="https://doc.rust-lang.org/1.76.0/std/io/trait.BufRead.html#method.split" title="method std::io::BufRead::split"><code>BufRead::split</code></a>.</p>
<p>The stream returned from this function will yield instances of
<a href="https://doc.rust-lang.org/1.76.0/std/io/error/type.Result.html" title="type std::io::error::Result"><code>io::Result</code></a><code>&lt;</code><a href="https://doc.rust-lang.org/1.76.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a><code>&lt;</code><a href="https://doc.rust-lang.org/1.76.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec&lt;u8&gt;</code></a><code>&gt;&gt;</code>. Each vector returned will <em>not</em> have
the delimiter byte at the end.</p>
<h5 id="errors-2"><a href="#errors-2">Errors</a></h5>
<p>Each item of the stream has the same error semantics as
<a href="trait.AsyncBufReadExt.html#method.read_until" title="method tokio::io::AsyncBufReadExt::read_until"><code>AsyncBufReadExt::read_until</code></a>.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::io::AsyncBufReadExt;

<span class="kw">let </span><span class="kw-2">mut </span>segments = my_buf_read.split(<span class="string">b'f'</span>);

<span class="kw">while let </span><span class="prelude-val">Some</span>(segment) = segments.next_segment().<span class="kw">await</span><span class="question-mark">? </span>{
    <span class="macro">println!</span>(<span class="string">"length = {}"</span>, segment.len())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fill_buf" class="method"><a class="src rightside" href="../../src/tokio/io/util/async_buf_read_ext.rs.html#271-276">source</a><h4 class="code-header">fn <a href="#method.fill_buf" class="fn">fill_buf</a>(&amp;mut self) -&gt; FillBuf&lt;'_, Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h4></section></summary><div class="docblock"><p>Returns the contents of the internal buffer, filling it with more
data from the inner reader if it is empty.</p>
<p>This function is a lower-level call. It needs to be paired with the
<a href="trait.AsyncBufReadExt.html#method.consume" title="method tokio::io::AsyncBufReadExt::consume"><code>consume</code></a> method to function properly. When calling this method,
none of the contents will be “read” in the sense that later calling
<code>read</code> may return the same contents. As such, <a href="trait.AsyncBufReadExt.html#method.consume" title="method tokio::io::AsyncBufReadExt::consume"><code>consume</code></a> must be
called with the number of bytes that are consumed from this buffer
to ensure that the bytes are never returned twice.</p>
<p>An empty buffer returned indicates that the stream has reached EOF.</p>
<p>Equivalent to:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">async fn </span>fill_buf(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; io::Result&lt;<span class="kw-2">&amp;</span>[u8]&gt;;</code></pre></div>
<h5 id="errors-3"><a href="#errors-3">Errors</a></h5>
<p>This function will return an I/O error if the underlying reader was
read, but returned an error.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.consume" class="method"><a class="src rightside" href="../../src/tokio/io/util/async_buf_read_ext.rs.html#293-298">source</a><h4 class="code-header">fn <a href="#method.consume" class="fn">consume</a>(&amp;mut self, amt: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.usize.html">usize</a>)<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h4></section></summary><div class="docblock"><p>Tells this buffer that <code>amt</code> bytes have been consumed from the
buffer, so they should no longer be returned in calls to <a href="trait.AsyncReadExt.html#method.read" title="method tokio::io::AsyncReadExt::read"><code>read</code></a>.</p>
<p>This function is a lower-level call. It needs to be paired with the
<a href="trait.AsyncBufReadExt.html#method.fill_buf" title="method tokio::io::AsyncBufReadExt::fill_buf"><code>fill_buf</code></a> method to function properly. This function does not
perform any I/O, it simply informs this object that some amount of
its buffer, returned from <a href="trait.AsyncBufReadExt.html#method.fill_buf" title="method tokio::io::AsyncBufReadExt::fill_buf"><code>fill_buf</code></a>, has been consumed and should
no longer be returned. As such, this function may do odd things if
<a href="trait.AsyncBufReadExt.html#method.fill_buf" title="method tokio::io::AsyncBufReadExt::fill_buf"><code>fill_buf</code></a> isn’t called before calling it.</p>
<p>The <code>amt</code> must be less than the number of bytes in the buffer
returned by <a href="trait.AsyncBufReadExt.html#method.fill_buf" title="method tokio::io::AsyncBufReadExt::fill_buf"><code>fill_buf</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines" class="method"><a class="src rightside" href="../../src/tokio/io/util/async_buf_read_ext.rs.html#342-347">source</a><h4 class="code-header">fn <a href="#method.lines" class="fn">lines</a>(self) -&gt; <a class="struct" href="struct.Lines.html" title="struct tokio::io::Lines">Lines</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Returns a stream over the lines of this reader.
This method is the async equivalent to <a href="https://doc.rust-lang.org/1.76.0/std/io/trait.BufRead.html#method.lines" title="method std::io::BufRead::lines"><code>BufRead::lines</code></a>.</p>
<p>The stream returned from this function will yield instances of
<a href="https://doc.rust-lang.org/1.76.0/std/io/error/type.Result.html" title="type std::io::error::Result"><code>io::Result</code></a><code>&lt;</code><a href="https://doc.rust-lang.org/1.76.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a><code>&lt;</code><a href="https://doc.rust-lang.org/1.76.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a><code>&gt;&gt;</code>. Each string returned will <em>not</em> have a newline
byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.</p>
<h5 id="errors-4"><a href="#errors-4">Errors</a></h5>
<p>Each line of the stream has the same error semantics as <a href="trait.AsyncBufReadExt.html#method.read_line" title="method tokio::io::AsyncBufReadExt::read_line"><code>AsyncBufReadExt::read_line</code></a>.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<p><a href="https://doc.rust-lang.org/1.76.0/std/io/cursor/struct.Cursor.html" title="struct std::io::cursor::Cursor"><code>std::io::Cursor</code></a> is a type that implements <code>BufRead</code>. In
this example, we use <a href="https://doc.rust-lang.org/1.76.0/std/io/cursor/struct.Cursor.html" title="struct std::io::cursor::Cursor"><code>Cursor</code></a> to iterate over all the lines in a byte
slice.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::io::AsyncBufReadExt;

<span class="kw">use </span>std::io::Cursor;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span>cursor = Cursor::new(<span class="string">b"lorem\nipsum\r\ndolor"</span>);

    <span class="kw">let </span><span class="kw-2">mut </span>lines = cursor.lines();

    <span class="macro">assert_eq!</span>(lines.next_line().<span class="kw">await</span>.unwrap(), <span class="prelude-val">Some</span>(String::from(<span class="string">"lorem"</span>)));
    <span class="macro">assert_eq!</span>(lines.next_line().<span class="kw">await</span>.unwrap(), <span class="prelude-val">Some</span>(String::from(<span class="string">"ipsum"</span>)));
    <span class="macro">assert_eq!</span>(lines.next_line().<span class="kw">await</span>.unwrap(), <span class="prelude-val">Some</span>(String::from(<span class="string">"dolor"</span>)));
    <span class="macro">assert_eq!</span>(lines.next_line().<span class="kw">await</span>.unwrap(), <span class="prelude-val">None</span>);
}</code></pre></div>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.76.0/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-AsyncBufReadExt-for-R" class="impl"><a class="src rightside" href="../../src/tokio/io/util/async_buf_read_ext.rs.html#351">source</a><a href="#impl-AsyncBufReadExt-for-R" class="anchor">§</a><h3 class="code-header">impl&lt;R: <a class="trait" href="trait.AsyncBufRead.html" title="trait tokio::io::AsyncBufRead">AsyncBufRead</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt; <a class="trait" href="trait.AsyncBufReadExt.html" title="trait tokio::io::AsyncBufReadExt">AsyncBufReadExt</a> for R</h3></section></div><script src="../../trait.impl/tokio/io/util/async_buf_read_ext/trait.AsyncBufReadExt.js" async></script></section></div></main></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `UnixDatagram` struct in crate `tokio`."><meta name="keywords" content="rust, rustlang, rust-lang, UnixDatagram"><title>tokio::net::UnixDatagram - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../tokio/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Struct UnixDatagram</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.bind">bind</a><a href="#method.connect">connect</a><a href="#method.from_std">from_std</a><a href="#method.into_std">into_std</a><a href="#method.local_addr">local_addr</a><a href="#method.pair">pair</a><a href="#method.peer_addr">peer_addr</a><a href="#method.poll_recv">poll_recv</a><a href="#method.poll_recv_from">poll_recv_from</a><a href="#method.poll_send">poll_send</a><a href="#method.poll_send_to">poll_send_to</a><a href="#method.readable">readable</a><a href="#method.ready">ready</a><a href="#method.recv">recv</a><a href="#method.recv_from">recv_from</a><a href="#method.send">send</a><a href="#method.send_to">send_to</a><a href="#method.shutdown">shutdown</a><a href="#method.take_error">take_error</a><a href="#method.try_recv">try_recv</a><a href="#method.try_recv_buf">try_recv_buf</a><a href="#method.try_recv_buf_from">try_recv_buf_from</a><a href="#method.try_recv_from">try_recv_from</a><a href="#method.try_send">try_send</a><a href="#method.try_send_to">try_send_to</a><a href="#method.unbound">unbound</a><a href="#method.writable">writable</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-AsRawFd">AsRawFd</a><a href="#impl-Debug">Debug</a><a href="#impl-TryFrom%3CUnixDatagram%3E">TryFrom&lt;UnixDatagram&gt;</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">!UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class="location"><a href="../index.html">tokio</a>::<wbr><a href="index.html">net</a></p><div id="sidebar-vars" data-name="UnixDatagram" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">tokio</a>::<wbr><a href="index.html">net</a>::<wbr><a class="struct" href="">UnixDatagram</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#93-95" title="goto source code">[src]</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class="rust struct">pub struct UnixDatagram { /* fields omitted */ }</pre></div><div class="docblock"><p>An I/O object representing a Unix datagram socket.</p>
<p>A socket can be either named (associated with a filesystem path) or
unnamed.</p>
<p>This type does not provide a <code>split</code> method, because this functionality
can be achieved by wrapping the socket in an <a href="https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html"><code>Arc</code></a>. Note that you do
not need a <code>Mutex</code> to share the <code>UnixDatagram</code> — an <code>Arc&lt;UnixDatagram&gt;</code>
is enough. This is because all of the methods take <code>&amp;self</code> instead of
<code>&amp;mut self</code>.</p>
<p><strong>Note:</strong> named sockets are persisted even after the object is dropped
and the program has exited, and cannot be reconnected. It is advised
that you either check for and unlink the existing socket if it exists,
or use a temporary file that is guaranteed to not already exist.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>Using named sockets, associated with a filesystem path:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>;

<span class="comment">// We use a temporary directory so that the socket</span>
<span class="comment">// files left by the bound sockets will get cleaned up.</span>
<span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="ident">tempdir</span>()<span class="question-mark">?</span>;

<span class="comment">// Bind each socket to a filesystem path</span>
<span class="kw">let</span> <span class="ident">tx_path</span> <span class="op">=</span> <span class="ident">tmp</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;tx&quot;</span>);
<span class="kw">let</span> <span class="ident">tx</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">tx_path</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">rx_path</span> <span class="op">=</span> <span class="ident">tmp</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;rx&quot;</span>);
<span class="kw">let</span> <span class="ident">rx</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">rx_path</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">b&quot;hello world&quot;</span>;
<span class="ident">tx</span>.<span class="ident">send_to</span>(<span class="ident">bytes</span>, <span class="kw-2">&amp;</span><span class="ident">rx_path</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="number">24</span>];
<span class="kw">let</span> (<span class="ident">size</span>, <span class="ident">addr</span>) <span class="op">=</span> <span class="ident">rx</span>.<span class="ident">recv_from</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">dgram</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">size</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dgram</span>, <span class="ident">bytes</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">addr</span>.<span class="ident">as_pathname</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">tx_path</span>);
</pre></div>
<p>Using unnamed sockets, created as a pair</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;

<span class="comment">// Create the pair of sockets</span>
<span class="kw">let</span> (<span class="ident">sock1</span>, <span class="ident">sock2</span>) <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">pair</span>()<span class="question-mark">?</span>;

<span class="comment">// Since the sockets are paired, the paired send/recv</span>
<span class="comment">// functions can be used</span>
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">b&quot;hello world&quot;</span>;
<span class="ident">sock1</span>.<span class="ident">send</span>(<span class="ident">bytes</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buff</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="number">24</span>];
<span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">sock2</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buff</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">dgram</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">buff</span>[..<span class="ident">size</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dgram</span>, <span class="ident">bytes</span>);
</pre></div>
</div><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><h3 id="impl" class="impl"><code class="in-band">impl <a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a></code><a href="#impl" class="anchor"></a><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#98-1250" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.ready" class="method"><code>pub async fn <a href="#method.ready" class="fnname">ready</a>(&amp;self, interest: <a class="struct" href="../../tokio/io/struct.Interest.html" title="struct tokio::io::Interest">Interest</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../../tokio/io/struct.Ready.html" title="struct tokio::io::Ready">Ready</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#160-163" title="goto source code">[src]</a></h4><div class="docblock"><p>Wait for any of the requested ready states.</p>
<p>This function is usually paired with <code>try_recv()</code> or <code>try_send()</code>. It
can be used to concurrently recv / send to the same socket on a single
task without splitting the socket.</p>
<p>The function may complete without the socket being ready. This is a
false-positive and attempting an operation will return with
<code>io::ErrorKind::WouldBlock</code>.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<p>Concurrently receive from and send to the socket on the same task
without splitting.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">io</span>::<span class="ident">Interest</span>;
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">dir</span> <span class="op">=</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">client_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;client.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">server_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;server.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">client_path</span>)<span class="question-mark">?</span>;
    <span class="ident">socket</span>.<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="ident">server_path</span>)<span class="question-mark">?</span>;

    <span class="kw">loop</span> {
        <span class="kw">let</span> <span class="ident">ready</span> <span class="op">=</span> <span class="ident">socket</span>.<span class="ident">ready</span>(<span class="ident">Interest</span>::<span class="ident">READABLE</span> <span class="op">|</span> <span class="ident">Interest</span>::<span class="ident">WRITABLE</span>).<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="kw">if</span> <span class="ident">ready</span>.<span class="ident">is_readable</span>() {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">1024</span>];
            <span class="kw">match</span> <span class="ident">socket</span>.<span class="ident">try_recv</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">data</span>[..]) {
                <span class="prelude-val">Ok</span>(<span class="ident">n</span>) <span class="op">=</span><span class="op">&gt;</span> {
                    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;received {:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">data</span>[..<span class="ident">n</span>]);
                }
                <span class="comment">// False-positive, continue</span>
                <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="kw">if</span> <span class="ident">e</span>.<span class="ident">kind</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">io</span>::<span class="ident">ErrorKind</span>::<span class="ident">WouldBlock</span> <span class="op">=</span><span class="op">&gt;</span> {}
                <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> {
                    <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>);
                }
            }
        }

        <span class="kw">if</span> <span class="ident">ready</span>.<span class="ident">is_writable</span>() {
            <span class="comment">// Write some data</span>
            <span class="kw">match</span> <span class="ident">socket</span>.<span class="ident">try_send</span>(<span class="string">b&quot;hello world&quot;</span>) {
                <span class="prelude-val">Ok</span>(<span class="ident">n</span>) <span class="op">=</span><span class="op">&gt;</span> {
                    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;sent {} bytes&quot;</span>, <span class="ident">n</span>);
                }
                <span class="comment">// False-positive, continue</span>
                <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="kw">if</span> <span class="ident">e</span>.<span class="ident">kind</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">io</span>::<span class="ident">ErrorKind</span>::<span class="ident">WouldBlock</span> <span class="op">=</span><span class="op">&gt;</span> {}
                <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> {
                    <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>);
                }
            }
        }
    }
}</pre></div>
</div><h4 id="method.writable" class="method"><code>pub async fn <a href="#method.writable" class="fnname">writable</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#210-213" title="goto source code">[src]</a></h4><div class="docblock"><p>Wait for the socket to become writable.</p>
<p>This function is equivalent to <code>ready(Interest::WRITABLE)</code> and is
usually paired with <code>try_send()</code> or <code>try_send_to()</code>.</p>
<p>The function may complete without the socket being writable. This is a
false-positive and attempting a <code>try_send()</code> will return with
<code>io::ErrorKind::WouldBlock</code>.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">dir</span> <span class="op">=</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">client_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;client.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">server_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;server.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">client_path</span>)<span class="question-mark">?</span>;
    <span class="ident">socket</span>.<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="ident">server_path</span>)<span class="question-mark">?</span>;

    <span class="kw">loop</span> {
        <span class="comment">// Wait for the socket to be writable</span>
        <span class="ident">socket</span>.<span class="ident">writable</span>().<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="comment">// Try to send data, this may still fail with `WouldBlock`</span>
        <span class="comment">// if the readiness event is a false positive.</span>
        <span class="kw">match</span> <span class="ident">socket</span>.<span class="ident">try_send</span>(<span class="string">b&quot;hello world&quot;</span>) {
            <span class="prelude-val">Ok</span>(<span class="ident">n</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">break</span>;
            }
            <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="kw">if</span> <span class="ident">e</span>.<span class="ident">kind</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">io</span>::<span class="ident">ErrorKind</span>::<span class="ident">WouldBlock</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">continue</span>;
            }
            <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>);
            }
        }
    }

    <span class="prelude-val">Ok</span>(())
}</pre></div>
</div><h4 id="method.readable" class="method"><code>pub async fn <a href="#method.readable" class="fnname">readable</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#266-269" title="goto source code">[src]</a></h4><div class="docblock"><p>Wait for the socket to become readable.</p>
<p>This function is equivalent to <code>ready(Interest::READABLE)</code> and is usually
paired with <code>try_recv()</code>.</p>
<p>The function may complete without the socket being readable. This is a
false-positive and attempting a <code>try_recv()</code> will return with
<code>io::ErrorKind::WouldBlock</code>.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// Connect to a peer</span>
    <span class="kw">let</span> <span class="ident">dir</span> <span class="op">=</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">client_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;client.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">server_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;server.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">client_path</span>)<span class="question-mark">?</span>;
    <span class="ident">socket</span>.<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="ident">server_path</span>)<span class="question-mark">?</span>;

    <span class="kw">loop</span> {
        <span class="comment">// Wait for the socket to be readable</span>
        <span class="ident">socket</span>.<span class="ident">readable</span>().<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="comment">// The buffer is **not** included in the async task and will</span>
        <span class="comment">// only exist on the stack.</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">1024</span>];

        <span class="comment">// Try to recv data, this may still fail with `WouldBlock`</span>
        <span class="comment">// if the readiness event is a false positive.</span>
        <span class="kw">match</span> <span class="ident">socket</span>.<span class="ident">try_recv</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>) {
            <span class="prelude-val">Ok</span>(<span class="ident">n</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;GOT {:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">n</span>]);
                <span class="kw">break</span>;
            }
            <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="kw">if</span> <span class="ident">e</span>.<span class="ident">kind</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">io</span>::<span class="ident">ErrorKind</span>::<span class="ident">WouldBlock</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">continue</span>;
            }
            <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>);
            }
        }
    }

    <span class="prelude-val">Ok</span>(())
}</pre></div>
</div><h4 id="method.bind" class="method"><code>pub fn <a href="#method.bind" class="fnname">bind</a>&lt;P&gt;(path: P) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;,&nbsp;</span></code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#292-298" title="goto source code">[src]</a></h4><div class="docblock"><p>Creates a new <code>UnixDatagram</code> bound to the specified path.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>;

<span class="comment">// We use a temporary directory so that the socket</span>
<span class="comment">// files left by the bound sockets will get cleaned up.</span>
<span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="ident">tempdir</span>()<span class="question-mark">?</span>;

<span class="comment">// Bind the socket to a filesystem path</span>
<span class="kw">let</span> <span class="ident">socket_path</span> <span class="op">=</span> <span class="ident">tmp</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;socket&quot;</span>);
<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">socket_path</span>)<span class="question-mark">?</span>;
</pre></div>
</div><h4 id="method.pair" class="method"><code>pub fn <a href="#method.pair" class="fnname">pair</a>() -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a>, <a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#329-335" title="goto source code">[src]</a></h4><div class="docblock"><p>Creates an unnamed pair of connected sockets.</p>
<p>This function will create a pair of interconnected Unix sockets for
communicating back and forth between one another.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;

<span class="comment">// Create the pair of sockets</span>
<span class="kw">let</span> (<span class="ident">sock1</span>, <span class="ident">sock2</span>) <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">pair</span>()<span class="question-mark">?</span>;

<span class="comment">// Since the sockets are paired, the paired send/recv</span>
<span class="comment">// functions can be used</span>
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">b&quot;hail eris&quot;</span>;
<span class="ident">sock1</span>.<span class="ident">send</span>(<span class="ident">bytes</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buff</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="number">24</span>];
<span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">sock2</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buff</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">dgram</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">buff</span>[..<span class="ident">size</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dgram</span>, <span class="ident">bytes</span>);
</pre></div>
</div><h4 id="method.from_std" class="method"><code>pub fn <a href="#method.from_std" class="fnname">from_std</a>(datagram: <a class="struct" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/net/datagram/struct.UnixDatagram.html" title="struct std::sys::unix::ext::net::datagram::UnixDatagram">UnixDatagram</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#373-377" title="goto source code">[src]</a></h4><div class="docblock"><p>Creates new <code>UnixDatagram</code> from a <code>std::os::unix::net::UnixDatagram</code>.</p>
<p>This function is intended to be used to wrap a UnixDatagram from the
standard library in the Tokio equivalent. The conversion assumes
nothing about the underlying datagram; it is left up to the user to set
it in non-blocking mode.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>This function panics if thread-local runtime is not set.</p>
<p>The runtime is usually set implicitly when this function is called
from a future driven by a Tokio runtime, otherwise runtime can be set
explicitly with <a href="../../tokio/runtime/struct.Runtime.html#method.enter"><code>Runtime::enter</code></a> function.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">os</span>::<span class="ident">unix</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span> <span class="kw">as</span> <span class="ident">StdUDS</span>;
<span class="kw">use</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>;

<span class="comment">// We use a temporary directory so that the socket</span>
<span class="comment">// files left by the bound sockets will get cleaned up.</span>
<span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="ident">tempdir</span>()<span class="question-mark">?</span>;

<span class="comment">// Bind the socket to a filesystem path</span>
<span class="kw">let</span> <span class="ident">socket_path</span> <span class="op">=</span> <span class="ident">tmp</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;socket&quot;</span>);
<span class="kw">let</span> <span class="ident">std_socket</span> <span class="op">=</span> <span class="ident">StdUDS</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">socket_path</span>)<span class="question-mark">?</span>;
<span class="ident">std_socket</span>.<span class="ident">set_nonblocking</span>(<span class="bool-val">true</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">tokio_socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">from_std</span>(<span class="ident">std_socket</span>)<span class="question-mark">?</span>;
</pre></div>
</div><h4 id="method.into_std" class="method"><code>pub fn <a href="#method.into_std" class="fnname">into_std</a>(self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/net/datagram/struct.UnixDatagram.html" title="struct std::sys::unix::ext::net::datagram::UnixDatagram">UnixDatagram</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#402-407" title="goto source code">[src]</a></h4><div class="docblock"><p>Turn a <a href="../../tokio/net/struct.UnixDatagram.html"><code>tokio::net::UnixDatagram</code></a> into a <a href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/net/datagram/struct.UnixDatagram.html"><code>std::os::unix::net::UnixDatagram</code></a>.</p>
<p>The returned <a href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/net/datagram/struct.UnixDatagram.html"><code>std::os::unix::net::UnixDatagram</code></a> will have nonblocking
mode set as <code>true</code>.  Use <a href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/net/datagram/struct.UnixDatagram.html#method.set_nonblocking"><code>set_nonblocking</code></a> to change the blocking mode
if needed.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">tokio_socket</span> <span class="op">=</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="string">&quot;127.0.0.1:0&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="ident">std_socket</span> <span class="op">=</span> <span class="ident">tokio_socket</span>.<span class="ident">into_std</span>()<span class="question-mark">?</span>;
    <span class="ident">std_socket</span>.<span class="ident">set_nonblocking</span>(<span class="bool-val">false</span>)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</pre></div>
</div><h4 id="method.unbound" class="method"><code>pub fn <a href="#method.unbound" class="fnname">unbound</a>() -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#445-448" title="goto source code">[src]</a></h4><div class="docblock"><p>Creates a new <code>UnixDatagram</code> which is not bound to any address.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>;

<span class="comment">// Create an unbound socket</span>
<span class="kw">let</span> <span class="ident">tx</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">unbound</span>()<span class="question-mark">?</span>;

<span class="comment">// Create another, bound socket</span>
<span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="ident">tempdir</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">rx_path</span> <span class="op">=</span> <span class="ident">tmp</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;rx&quot;</span>);
<span class="kw">let</span> <span class="ident">rx</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">rx_path</span>)<span class="question-mark">?</span>;

<span class="comment">// Send to the bound socket</span>
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">b&quot;hello world&quot;</span>;
<span class="ident">tx</span>.<span class="ident">send_to</span>(<span class="ident">bytes</span>, <span class="kw-2">&amp;</span><span class="ident">rx_path</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="number">24</span>];
<span class="kw">let</span> (<span class="ident">size</span>, <span class="ident">addr</span>) <span class="op">=</span> <span class="ident">rx</span>.<span class="ident">recv_from</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">dgram</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">size</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dgram</span>, <span class="ident">bytes</span>);
</pre></div>
</div><h4 id="method.connect" class="method"><code>pub fn <a href="#method.connect" class="fnname">connect</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(&amp;self, path: P) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#487-489" title="goto source code">[src]</a></h4><div class="docblock"><p>Connects the socket to the specified address.</p>
<p>The <code>send</code> method may be used to send data to the specified address.
<code>recv</code> and <code>recv_from</code> will only receive data from that address.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>;

<span class="comment">// Create an unbound socket</span>
<span class="kw">let</span> <span class="ident">tx</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">unbound</span>()<span class="question-mark">?</span>;

<span class="comment">// Create another, bound socket</span>
<span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="ident">tempdir</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">rx_path</span> <span class="op">=</span> <span class="ident">tmp</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;rx&quot;</span>);
<span class="kw">let</span> <span class="ident">rx</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">rx_path</span>)<span class="question-mark">?</span>;

<span class="comment">// Connect to the bound socket</span>
<span class="ident">tx</span>.<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="ident">rx_path</span>)<span class="question-mark">?</span>;

<span class="comment">// Send to the bound socket</span>
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">b&quot;hello world&quot;</span>;
<span class="ident">tx</span>.<span class="ident">send</span>(<span class="ident">bytes</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="number">24</span>];
<span class="kw">let</span> (<span class="ident">size</span>, <span class="ident">addr</span>) <span class="op">=</span> <span class="ident">rx</span>.<span class="ident">recv_from</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">dgram</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">size</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dgram</span>, <span class="ident">bytes</span>);
</pre></div>
</div><h4 id="method.send" class="method"><code>pub async fn <a href="#method.send" class="fnname">send</a>(&amp;self, buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#517-522" title="goto source code">[src]</a></h4><div class="docblock"><p>Sends data on the socket to the socket's peer.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;

<span class="comment">// Create the pair of sockets</span>
<span class="kw">let</span> (<span class="ident">sock1</span>, <span class="ident">sock2</span>) <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">pair</span>()<span class="question-mark">?</span>;

<span class="comment">// Since the sockets are paired, the paired send/recv</span>
<span class="comment">// functions can be used</span>
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">b&quot;hello world&quot;</span>;
<span class="ident">sock1</span>.<span class="ident">send</span>(<span class="ident">bytes</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buff</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="number">24</span>];
<span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">sock2</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buff</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">dgram</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">buff</span>[..<span class="ident">size</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dgram</span>, <span class="ident">bytes</span>);
</pre></div>
</div><h4 id="method.try_send" class="method"><code>pub fn <a href="#method.try_send" class="fnname">try_send</a>(&amp;self, buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#562-566" title="goto source code">[src]</a></h4><div class="docblock"><p>Try to send a datagram to the peer without waiting.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">dir</span> <span class="op">=</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">client_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;client.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">server_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;server.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">client_path</span>)<span class="question-mark">?</span>;
    <span class="ident">socket</span>.<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="ident">server_path</span>)<span class="question-mark">?</span>;

    <span class="kw">loop</span> {
        <span class="comment">// Wait for the socket to be writable</span>
        <span class="ident">socket</span>.<span class="ident">writable</span>().<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="comment">// Try to send data, this may still fail with `WouldBlock`</span>
        <span class="comment">// if the readiness event is a false positive.</span>
        <span class="kw">match</span> <span class="ident">socket</span>.<span class="ident">try_send</span>(<span class="string">b&quot;hello world&quot;</span>) {
            <span class="prelude-val">Ok</span>(<span class="ident">n</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">break</span>;
            }
            <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="kw">if</span> <span class="ident">e</span>.<span class="ident">kind</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">io</span>::<span class="ident">ErrorKind</span>::<span class="ident">WouldBlock</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">continue</span>;
            }
            <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>);
            }
        }
    }

    <span class="prelude-val">Ok</span>(())
}</pre></div>
</div><h4 id="method.try_send_to" class="method"><code>pub fn <a href="#method.try_send_to" class="fnname">try_send_to</a>&lt;P&gt;(&amp;self, buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, target: P) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;,&nbsp;</span></code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#605-612" title="goto source code">[src]</a></h4><div class="docblock"><p>Try to send a datagram to the peer without waiting.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">dir</span> <span class="op">=</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">client_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;client.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">server_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;server.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">client_path</span>)<span class="question-mark">?</span>;

    <span class="kw">loop</span> {
        <span class="comment">// Wait for the socket to be writable</span>
        <span class="ident">socket</span>.<span class="ident">writable</span>().<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="comment">// Try to send data, this may still fail with `WouldBlock`</span>
        <span class="comment">// if the readiness event is a false positive.</span>
        <span class="kw">match</span> <span class="ident">socket</span>.<span class="ident">try_send_to</span>(<span class="string">b&quot;hello world&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">server_path</span>) {
            <span class="prelude-val">Ok</span>(<span class="ident">n</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">break</span>;
            }
            <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="kw">if</span> <span class="ident">e</span>.<span class="ident">kind</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">io</span>::<span class="ident">ErrorKind</span>::<span class="ident">WouldBlock</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">continue</span>;
            }
            <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>);
            }
        }
    }

    <span class="prelude-val">Ok</span>(())
}</pre></div>
</div><h4 id="method.recv" class="method"><code>pub async fn <a href="#method.recv" class="fnname">recv</a>(&amp;self, buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#640-645" title="goto source code">[src]</a></h4><div class="docblock"><p>Receives data from the socket.</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;

<span class="comment">// Create the pair of sockets</span>
<span class="kw">let</span> (<span class="ident">sock1</span>, <span class="ident">sock2</span>) <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">pair</span>()<span class="question-mark">?</span>;

<span class="comment">// Since the sockets are paired, the paired send/recv</span>
<span class="comment">// functions can be used</span>
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">b&quot;hello world&quot;</span>;
<span class="ident">sock1</span>.<span class="ident">send</span>(<span class="ident">bytes</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buff</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="number">24</span>];
<span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">sock2</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buff</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">dgram</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">buff</span>[..<span class="ident">size</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dgram</span>, <span class="ident">bytes</span>);
</pre></div>
</div><h4 id="method.try_recv" class="method"><code>pub fn <a href="#method.try_recv" class="fnname">try_recv</a>(&amp;self, buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#691-695" title="goto source code">[src]</a></h4><div class="docblock"><p>Try to receive a datagram from the peer without waiting.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// Connect to a peer</span>
    <span class="kw">let</span> <span class="ident">dir</span> <span class="op">=</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">client_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;client.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">server_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;server.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">client_path</span>)<span class="question-mark">?</span>;
    <span class="ident">socket</span>.<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="ident">server_path</span>)<span class="question-mark">?</span>;

    <span class="kw">loop</span> {
        <span class="comment">// Wait for the socket to be readable</span>
        <span class="ident">socket</span>.<span class="ident">readable</span>().<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="comment">// The buffer is **not** included in the async task and will</span>
        <span class="comment">// only exist on the stack.</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">1024</span>];

        <span class="comment">// Try to recv data, this may still fail with `WouldBlock`</span>
        <span class="comment">// if the readiness event is a false positive.</span>
        <span class="kw">match</span> <span class="ident">socket</span>.<span class="ident">try_recv</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>) {
            <span class="prelude-val">Ok</span>(<span class="ident">n</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;GOT {:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">n</span>]);
                <span class="kw">break</span>;
            }
            <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="kw">if</span> <span class="ident">e</span>.<span class="ident">kind</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">io</span>::<span class="ident">ErrorKind</span>::<span class="ident">WouldBlock</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">continue</span>;
            }
            <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>);
            }
        }
    }

    <span class="prelude-val">Ok</span>(())
}</pre></div>
</div><h4 id="method.try_recv_buf_from" class="method"><code>pub fn <a href="#method.try_recv_buf_from" class="fnname">try_recv_buf_from</a>&lt;B:&nbsp;<a class="trait" href="../../bytes/buf/buf_mut/trait.BufMut.html" title="trait bytes::buf::buf_mut::BufMut">BufMut</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>B<br>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="../../tokio/net/unix/struct.SocketAddr.html" title="struct tokio::net::unix::SocketAddr">SocketAddr</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#739-757" title="goto source code">[src]</a></h4><div class="docblock"><p>Try to receive data from the socket without waiting.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// Connect to a peer</span>
    <span class="kw">let</span> <span class="ident">dir</span> <span class="op">=</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">client_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;client.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">server_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;server.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">client_path</span>)<span class="question-mark">?</span>;

    <span class="kw">loop</span> {
        <span class="comment">// Wait for the socket to be readable</span>
        <span class="ident">socket</span>.<span class="ident">readable</span>().<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="number">1024</span>);

        <span class="comment">// Try to recv data, this may still fail with `WouldBlock`</span>
        <span class="comment">// if the readiness event is a false positive.</span>
        <span class="kw">match</span> <span class="ident">socket</span>.<span class="ident">try_recv_buf_from</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>) {
            <span class="prelude-val">Ok</span>((<span class="ident">n</span>, <span class="ident">_addr</span>)) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;GOT {:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">n</span>]);
                <span class="kw">break</span>;
            }
            <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="kw">if</span> <span class="ident">e</span>.<span class="ident">kind</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">io</span>::<span class="ident">ErrorKind</span>::<span class="ident">WouldBlock</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">continue</span>;
            }
            <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>);
            }
        }
    }

    <span class="prelude-val">Ok</span>(())
}</pre></div>
</div><h4 id="method.try_recv_buf" class="method"><code>pub fn <a href="#method.try_recv_buf" class="fnname">try_recv_buf</a>&lt;B:&nbsp;<a class="trait" href="../../bytes/buf/buf_mut/trait.BufMut.html" title="trait bytes::buf::buf_mut::BufMut">BufMut</a>&gt;(&amp;self, buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>B) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#802-818" title="goto source code">[src]</a></h4><div class="docblock"><p>Try to read data from the stream into the provided buffer, advancing the
buffer's internal cursor, returning how many bytes were read.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// Connect to a peer</span>
    <span class="kw">let</span> <span class="ident">dir</span> <span class="op">=</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">client_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;client.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">server_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;server.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">client_path</span>)<span class="question-mark">?</span>;
    <span class="ident">socket</span>.<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="ident">server_path</span>)<span class="question-mark">?</span>;

    <span class="kw">loop</span> {
        <span class="comment">// Wait for the socket to be readable</span>
        <span class="ident">socket</span>.<span class="ident">readable</span>().<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="number">1024</span>);

        <span class="comment">// Try to recv data, this may still fail with `WouldBlock`</span>
        <span class="comment">// if the readiness event is a false positive.</span>
        <span class="kw">match</span> <span class="ident">socket</span>.<span class="ident">try_recv_buf</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>) {
            <span class="prelude-val">Ok</span>(<span class="ident">n</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;GOT {:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">n</span>]);
                <span class="kw">break</span>;
            }
            <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="kw">if</span> <span class="ident">e</span>.<span class="ident">kind</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">io</span>::<span class="ident">ErrorKind</span>::<span class="ident">WouldBlock</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">continue</span>;
            }
            <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>);
            }
        }
    }

    <span class="prelude-val">Ok</span>(())
}</pre></div>
</div><h4 id="method.send_to" class="method"><code>pub async fn <a href="#method.send_to" class="fnname">send_to</a>&lt;P&gt;(&amp;self, buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, target: P) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;,&nbsp;</span></code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#854-862" title="goto source code">[src]</a></h4><div class="docblock"><p>Sends data on the socket to the specified address.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>;

<span class="comment">// We use a temporary directory so that the socket</span>
<span class="comment">// files left by the bound sockets will get cleaned up.</span>
<span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="ident">tempdir</span>()<span class="question-mark">?</span>;

<span class="comment">// Bind each socket to a filesystem path</span>
<span class="kw">let</span> <span class="ident">tx_path</span> <span class="op">=</span> <span class="ident">tmp</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;tx&quot;</span>);
<span class="kw">let</span> <span class="ident">tx</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">tx_path</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">rx_path</span> <span class="op">=</span> <span class="ident">tmp</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;rx&quot;</span>);
<span class="kw">let</span> <span class="ident">rx</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">rx_path</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">b&quot;hello world&quot;</span>;
<span class="ident">tx</span>.<span class="ident">send_to</span>(<span class="ident">bytes</span>, <span class="kw-2">&amp;</span><span class="ident">rx_path</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="number">24</span>];
<span class="kw">let</span> (<span class="ident">size</span>, <span class="ident">addr</span>) <span class="op">=</span> <span class="ident">rx</span>.<span class="ident">recv_from</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">dgram</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">size</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dgram</span>, <span class="ident">bytes</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">addr</span>.<span class="ident">as_pathname</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">tx_path</span>);
</pre></div>
</div><h4 id="method.recv_from" class="method"><code>pub async fn <a href="#method.recv_from" class="fnname">recv_from</a>(&amp;self, buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="../../tokio/net/unix/struct.SocketAddr.html" title="struct tokio::net::unix::SocketAddr">SocketAddr</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#897-905" title="goto source code">[src]</a></h4><div class="docblock"><p>Receives data from the socket.</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>;

<span class="comment">// We use a temporary directory so that the socket</span>
<span class="comment">// files left by the bound sockets will get cleaned up.</span>
<span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="ident">tempdir</span>()<span class="question-mark">?</span>;

<span class="comment">// Bind each socket to a filesystem path</span>
<span class="kw">let</span> <span class="ident">tx_path</span> <span class="op">=</span> <span class="ident">tmp</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;tx&quot;</span>);
<span class="kw">let</span> <span class="ident">tx</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">tx_path</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">rx_path</span> <span class="op">=</span> <span class="ident">tmp</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;rx&quot;</span>);
<span class="kw">let</span> <span class="ident">rx</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">rx_path</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">b&quot;hello world&quot;</span>;
<span class="ident">tx</span>.<span class="ident">send_to</span>(<span class="ident">bytes</span>, <span class="kw-2">&amp;</span><span class="ident">rx_path</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="number">24</span>];
<span class="kw">let</span> (<span class="ident">size</span>, <span class="ident">addr</span>) <span class="op">=</span> <span class="ident">rx</span>.<span class="ident">recv_from</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">dgram</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">size</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dgram</span>, <span class="ident">bytes</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">addr</span>.<span class="ident">as_pathname</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">tx_path</span>);
</pre></div>
</div><h4 id="method.poll_recv_from" class="method"><code>pub fn <a href="#method.poll_recv_from" class="fnname">poll_recv_from</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;cx: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/task/wake/struct.Context.html" title="struct core::task::wake::Context">Context</a>&lt;'_&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: &amp;mut <a class="struct" href="../../tokio/io/struct.ReadBuf.html" title="struct tokio::io::ReadBuf">ReadBuf</a>&lt;'_&gt;<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/task/poll/enum.Poll.html" title="enum core::task::poll::Poll">Poll</a>&lt;<a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../../tokio/net/unix/struct.SocketAddr.html" title="struct tokio::net::unix::SocketAddr">SocketAddr</a>&gt;&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#924-944" title="goto source code">[src]</a></h4><div class="docblock"><p>Attempts to receive a single datagram on the specified address.</p>
<p>Note that on multiple calls to a <code>poll_*</code> method in the recv direction, only the
<code>Waker</code> from the <code>Context</code> passed to the most recent call will be scheduled to
receive a wakeup.</p>
<h1 id="return-value" class="section-header"><a href="#return-value">Return value</a></h1>
<p>The function returns:</p>
<ul>
<li><code>Poll::Pending</code> if the socket is not ready to read</li>
<li><code>Poll::Ready(Ok(addr))</code> reads data from <code>addr</code> into <code>ReadBuf</code> if the socket is ready</li>
<li><code>Poll::Ready(Err(e))</code> if an error is encountered.</li>
</ul>
<h1 id="errors" class="section-header"><a href="#errors">Errors</a></h1>
<p>This function may encounter any standard I/O error except <code>WouldBlock</code>.</p>
</div><h4 id="method.poll_send_to" class="method"><code>pub fn <a href="#method.poll_send_to" class="fnname">poll_send_to</a>&lt;P&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;cx: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/task/wake/struct.Context.html" title="struct core::task::wake::Context">Context</a>&lt;'_&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;target: P<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/task/poll/enum.Poll.html" title="enum core::task::poll::Poll">Poll</a>&lt;<a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;,&nbsp;</span></code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#963-975" title="goto source code">[src]</a></h4><div class="docblock"><p>Attempts to send data to the specified address.</p>
<p>Note that on multiple calls to a <code>poll_*</code> method in the send direction, only the
<code>Waker</code> from the <code>Context</code> passed to the most recent call will be scheduled to
receive a wakeup.</p>
<h1 id="return-value-1" class="section-header"><a href="#return-value-1">Return value</a></h1>
<p>The function returns:</p>
<ul>
<li><code>Poll::Pending</code> if the socket is not ready to write</li>
<li><code>Poll::Ready(Ok(n))</code> <code>n</code> is the number of bytes sent.</li>
<li><code>Poll::Ready(Err(e))</code> if an error is encountered.</li>
</ul>
<h1 id="errors-1" class="section-header"><a href="#errors-1">Errors</a></h1>
<p>This function may encounter any standard I/O error except <code>WouldBlock</code>.</p>
</div><h4 id="method.poll_send" class="method"><code>pub fn <a href="#method.poll_send" class="fnname">poll_send</a>(&amp;self, cx: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/task/wake/struct.Context.html" title="struct core::task::wake::Context">Context</a>&lt;'_&gt;, buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/task/poll/enum.Poll.html" title="enum core::task::poll::Poll">Poll</a>&lt;<a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1000-1004" title="goto source code">[src]</a></h4><div class="docblock"><p>Attempts to send data on the socket to the remote address to which it
was previously <code>connect</code>ed.</p>
<p>The <a href="../../tokio/net/struct.UnixDatagram.html#method.connect"><code>connect</code></a> method will connect this socket to a remote address.
This method will fail if the socket is not connected.</p>
<p>Note that on multiple calls to a <code>poll_*</code> method in the send direction,
only the <code>Waker</code> from the <code>Context</code> passed to the most recent call will
be scheduled to receive a wakeup.</p>
<h1 id="return-value-2" class="section-header"><a href="#return-value-2">Return value</a></h1>
<p>The function returns:</p>
<ul>
<li><code>Poll::Pending</code> if the socket is not available to write</li>
<li><code>Poll::Ready(Ok(n))</code> <code>n</code> is the number of bytes sent</li>
<li><code>Poll::Ready(Err(e))</code> if an error is encountered.</li>
</ul>
<h1 id="errors-2" class="section-header"><a href="#errors-2">Errors</a></h1>
<p>This function may encounter any standard I/O error except <code>WouldBlock</code>.</p>
</div><h4 id="method.poll_recv" class="method"><code>pub fn <a href="#method.poll_recv" class="fnname">poll_recv</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;cx: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/task/wake/struct.Context.html" title="struct core::task::wake::Context">Context</a>&lt;'_&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: &amp;mut <a class="struct" href="../../tokio/io/struct.ReadBuf.html" title="struct tokio::io::ReadBuf">ReadBuf</a>&lt;'_&gt;<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/task/poll/enum.Poll.html" title="enum core::task::poll::Poll">Poll</a>&lt;<a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1029-1045" title="goto source code">[src]</a></h4><div class="docblock"><p>Attempts to receive a single datagram message on the socket from the remote
address to which it is <code>connect</code>ed.</p>
<p>The <a href="../../tokio/net/struct.UnixDatagram.html#method.connect"><code>connect</code></a> method will connect this socket to a remote address. This method
resolves to an error if the socket is not connected.</p>
<p>Note that on multiple calls to a <code>poll_*</code> method in the recv direction, only the
<code>Waker</code> from the <code>Context</code> passed to the most recent call will be scheduled to
receive a wakeup.</p>
<h1 id="return-value-3" class="section-header"><a href="#return-value-3">Return value</a></h1>
<p>The function returns:</p>
<ul>
<li><code>Poll::Pending</code> if the socket is not ready to read</li>
<li><code>Poll::Ready(Ok(()))</code> reads data <code>ReadBuf</code> if the socket is ready</li>
<li><code>Poll::Ready(Err(e))</code> if an error is encountered.</li>
</ul>
<h1 id="errors-3" class="section-header"><a href="#errors-3">Errors</a></h1>
<p>This function may encounter any standard I/O error except <code>WouldBlock</code>.</p>
</div><h4 id="method.try_recv_from" class="method"><code>pub fn <a href="#method.try_recv_from" class="fnname">try_recv_from</a>(&amp;self, buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="../../tokio/net/unix/struct.SocketAddr.html" title="struct tokio::net::unix::SocketAddr">SocketAddr</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1090-1097" title="goto source code">[src]</a></h4><div class="docblock"><p>Try to receive data from the socket without waiting.</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// Connect to a peer</span>
    <span class="kw">let</span> <span class="ident">dir</span> <span class="op">=</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">client_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;client.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">server_path</span> <span class="op">=</span> <span class="ident">dir</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;server.sock&quot;</span>);
    <span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">client_path</span>)<span class="question-mark">?</span>;

    <span class="kw">loop</span> {
        <span class="comment">// Wait for the socket to be readable</span>
        <span class="ident">socket</span>.<span class="ident">readable</span>().<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="comment">// The buffer is **not** included in the async task and will</span>
        <span class="comment">// only exist on the stack.</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">1024</span>];

        <span class="comment">// Try to recv data, this may still fail with `WouldBlock`</span>
        <span class="comment">// if the readiness event is a false positive.</span>
        <span class="kw">match</span> <span class="ident">socket</span>.<span class="ident">try_recv_from</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>) {
            <span class="prelude-val">Ok</span>((<span class="ident">n</span>, <span class="ident">_addr</span>)) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;GOT {:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">n</span>]);
                <span class="kw">break</span>;
            }
            <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="kw">if</span> <span class="ident">e</span>.<span class="ident">kind</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">io</span>::<span class="ident">ErrorKind</span>::<span class="ident">WouldBlock</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">continue</span>;
            }
            <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>);
            }
        }
    }

    <span class="prelude-val">Ok</span>(())
}</pre></div>
</div><h4 id="method.local_addr" class="method"><code>pub fn <a href="#method.local_addr" class="fnname">local_addr</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../../tokio/net/unix/struct.SocketAddr.html" title="struct tokio::net::unix::SocketAddr">SocketAddr</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1139-1141" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the local address that this socket is bound to.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<p>For a socket bound to a local path</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>;

<span class="comment">// We use a temporary directory so that the socket</span>
<span class="comment">// files left by the bound sockets will get cleaned up.</span>
<span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="ident">tempdir</span>()<span class="question-mark">?</span>;

<span class="comment">// Bind socket to a filesystem path</span>
<span class="kw">let</span> <span class="ident">socket_path</span> <span class="op">=</span> <span class="ident">tmp</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;socket&quot;</span>);
<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">socket_path</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">socket</span>.<span class="ident">local_addr</span>()<span class="question-mark">?</span>.<span class="ident">as_pathname</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">socket_path</span>);
</pre></div>
<p>For an unbound socket</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;

<span class="comment">// Create an unbound socket</span>
<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">unbound</span>()<span class="question-mark">?</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">socket</span>.<span class="ident">local_addr</span>()<span class="question-mark">?</span>.<span class="ident">is_unnamed</span>());
</pre></div>
</div><h4 id="method.peer_addr" class="method"><code>pub fn <a href="#method.peer_addr" class="fnname">peer_addr</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../../tokio/net/unix/struct.SocketAddr.html" title="struct tokio::net::unix::SocketAddr">SocketAddr</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1188-1190" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the address of this socket's peer.</p>
<p>The <code>connect</code> method will connect the socket to a peer.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<p>For a peer with a local path</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">tempfile</span>::<span class="ident">tempdir</span>;

<span class="comment">// Create an unbound socket</span>
<span class="kw">let</span> <span class="ident">tx</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">unbound</span>()<span class="question-mark">?</span>;

<span class="comment">// Create another, bound socket</span>
<span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="ident">tempdir</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">rx_path</span> <span class="op">=</span> <span class="ident">tmp</span>.<span class="ident">path</span>().<span class="ident">join</span>(<span class="string">&quot;rx&quot;</span>);
<span class="kw">let</span> <span class="ident">rx</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">bind</span>(<span class="kw-2">&amp;</span><span class="ident">rx_path</span>)<span class="question-mark">?</span>;

<span class="comment">// Connect to the bound socket</span>
<span class="ident">tx</span>.<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="ident">rx_path</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">tx</span>.<span class="ident">peer_addr</span>()<span class="question-mark">?</span>.<span class="ident">as_pathname</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">rx_path</span>);
</pre></div>
<p>For an unbound peer</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;

<span class="comment">// Create the pair of sockets</span>
<span class="kw">let</span> (<span class="ident">sock1</span>, <span class="ident">sock2</span>) <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">pair</span>()<span class="question-mark">?</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">sock1</span>.<span class="ident">peer_addr</span>()<span class="question-mark">?</span>.<span class="ident">is_unnamed</span>());
</pre></div>
</div><h4 id="method.take_error" class="method"><code>pub fn <a href="#method.take_error" class="fnname">take_error</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1211-1213" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the value of the <code>SO_ERROR</code> option.</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;

<span class="comment">// Create an unbound socket</span>
<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">unbound</span>()<span class="question-mark">?</span>;

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="ident">err</span>)) <span class="op">=</span> <span class="ident">socket</span>.<span class="ident">take_error</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Got error: {:?}&quot;</span>, <span class="ident">err</span>);
}
</pre></div>
</div><h4 id="method.shutdown" class="method"><code>pub fn <a href="#method.shutdown" class="fnname">shutdown</a>(&amp;self, how: <a class="enum" href="https://doc.rust-lang.org/nightly/std/net/enum.Shutdown.html" title="enum std::net::Shutdown">Shutdown</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1247-1249" title="goto source code">[src]</a></h4><div class="docblock"><p>Shuts down the read, write, or both halves of this connection.</p>
<p>This function will cause all pending and future I/O calls on the
specified portions to immediately return with an appropriate value
(see the documentation of <code>Shutdown</code>).</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio</span>::<span class="ident">net</span>::<span class="ident">UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">net</span>::<span class="ident">Shutdown</span>;

<span class="comment">// Create an unbound socket</span>
<span class="kw">let</span> (<span class="ident">socket</span>, <span class="ident">other</span>) <span class="op">=</span> <span class="ident">UnixDatagram</span>::<span class="ident">pair</span>()<span class="question-mark">?</span>;

<span class="ident">socket</span>.<span class="ident">shutdown</span>(<span class="ident">Shutdown</span>::<span class="ident">Both</span>)<span class="question-mark">?</span>;

<span class="comment">// NOTE: the following commented out code does NOT work as expected.</span>
<span class="comment">// Due to an underlying issue, the recv call will block indefinitely.</span>
<span class="comment">// See: https://github.com/tokio-rs/tokio/issues/1679</span>
<span class="comment">//let mut buff = vec![0u8; 24];</span>
<span class="comment">//let size = socket.recv(&amp;mut buff).await?;</span>
<span class="comment">//assert_eq!(size, 0);</span>

<span class="kw">let</span> <span class="ident">send_result</span> <span class="op">=</span> <span class="ident">socket</span>.<span class="ident">send</span>(<span class="string">b&quot;hello world&quot;</span>).<span class="kw">await</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">send_result</span>.<span class="ident">is_err</span>());
</pre></div>
</div></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><h3 id="impl-AsRawFd" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/trait.AsRawFd.html" title="trait std::sys::unix::ext::io::AsRawFd">AsRawFd</a> for <a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a></code><a href="#impl-AsRawFd" class="anchor"></a><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1270-1274" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.as_raw_fd" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/trait.AsRawFd.html#tymethod.as_raw_fd" class="fnname">as_raw_fd</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a></code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1271-1273" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Extracts the raw file descriptor. <a href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/trait.AsRawFd.html#tymethod.as_raw_fd">Read more</a></p>
</div></div><h3 id="impl-Debug" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a></code><a href="#impl-Debug" class="anchor"></a><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1264-1268" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1265-1267" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id="impl-TryFrom%3CUnixDatagram%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/net/datagram/struct.UnixDatagram.html" title="struct std::sys::unix::ext::net::datagram::UnixDatagram">UnixDatagram</a>&gt; for <a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a></code><a href="#impl-TryFrom%3CUnixDatagram%3E" class="anchor"></a><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1252-1262" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(stream: <a class="struct" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/net/datagram/struct.UnixDatagram.html" title="struct std::sys::unix::ext::net::datagram::UnixDatagram">UnixDatagram</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="../../src/tokio/net/unix/datagram/socket.rs.html#1259-1261" title="goto source code">[src]</a></h4><div class="docblock"><p>Consumes stream, returning the Tokio I/O object.</p>
<p>This is equivalent to
<a href="../../tokio/net/struct.UnixDatagram.html#method.from_std"><code>UnixDatagram::from_std(stream)</code></a>.</p>
</div></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a></code><a href="#impl-RefUnwindSafe" class="anchor"></a><a class="srclink" href="../../src/tokio/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Send" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a></code><a href="#impl-Send" class="anchor"></a><a class="srclink" href="../../src/tokio/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Sync" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a></code><a href="#impl-Sync" class="anchor"></a><a class="srclink" href="../../src/tokio/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Unpin" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a></code><a href="#impl-Unpin" class="anchor"></a><a class="srclink" href="../../src/tokio/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../../tokio/net/struct.UnixDatagram.html" title="struct tokio::net::UnixDatagram">UnixDatagram</a></code><a href="#impl-UnwindSafe" class="anchor"></a><a class="srclink" href="../../src/tokio/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><h3 id="impl-Any" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Any" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#131-135" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.type_id" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id="impl-Borrow%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#207-211" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>F</h3><code class="content"><span class="where fmt-newline">impl&lt;'_, F&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>F <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html#associatedtype.Output" class="type">Output</a> = &lt;F as <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html#associatedtype.Output" title="type core::future::future::Future::Output">Output</a>;</span></code></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id="impl-BorrowMut%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214-218" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow_mut" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>F</h3><code class="content"><span class="where fmt-newline">impl&lt;'_, F&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>F <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html#associatedtype.Output" class="type">Output</a> = &lt;F as <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html#associatedtype.Output" title="type core::future::future::Future::Output">Output</a>;</span></code></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#215" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id="impl-From%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#545-549" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#546" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Into%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#534-541" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#538" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryFrom%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#582-591" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from-1" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#588" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryInto%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#568-577" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-2" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#574" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="tokio"></div>
    <script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>
// DO NOT EDIT !
// This file was generated automatically from 'src/generator/templates/cli/main.rs.mako'
// DO NOT EDIT !
#![allow(unused_variables, unused_imports, dead_code, unused_mut)]

#[macro_use]
extern crate clap;

use std::env;
use std::io::{self, Write};
use clap::{App, SubCommand, Arg};

use google_dfareporting2d8::{api, Error, oauth2, client::chrono, FieldMask};


use google_clis_common as client;

use client::{InvalidOptionsError, CLIError, arg_from_str, writer_from_opts, parse_kv_arg,
          input_file_from_opts, input_mime_from_opts, FieldCursor, FieldError, CallType, UploadProtocol,
          calltype_from_str, remove_json_null_values, ComplexType, JsonType, JsonTypeInfo};

use std::default::Default;
use std::error::Error as StdError;
use std::str::FromStr;

use serde_json as json;
use clap::ArgMatches;
use http::Uri;
use hyper::client::connect;
use tokio::io::{AsyncRead, AsyncWrite};
use tower_service;

enum DoitError {
    IoError(String, io::Error),
    ApiError(Error),
}

struct Engine<'n, S> {
    opt: ArgMatches<'n>,
    hub: api::Dfareporting<S>,
    gp: Vec<&'static str>,
    gpm: Vec<(&'static str, &'static str)>,
}


impl<'n, S> Engine<'n, S>
where
    S: tower_service::Service<Uri> + Clone + Send + Sync + 'static,
    S::Response: hyper::client::connect::Connection + AsyncRead + AsyncWrite + Send + Unpin + 'static,
    S::Future: Send + Unpin + 'static,
    S::Error: Into<Box<dyn StdError + Send + Sync>>,
{
    async fn _account_active_ad_summaries_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.account_active_ad_summaries().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("summary-account-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _account_permission_groups_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.account_permission_groups().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _account_permission_groups_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.account_permission_groups().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _account_permissions_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.account_permissions().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _account_permissions_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.account_permissions().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _account_user_profiles_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.account_user_profiles().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _account_user_profiles_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-filter.kind" => Some(("advertiserFilter.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-filter.object-ids" => Some(("advertiserFilter.objectIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "advertiser-filter.status" => Some(("advertiserFilter.status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-filter.kind" => Some(("campaignFilter.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-filter.object-ids" => Some(("campaignFilter.objectIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "campaign-filter.status" => Some(("campaignFilter.status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "comments" => Some(("comments", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "email" => Some(("email", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "locale" => Some(("locale", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-filter.kind" => Some(("siteFilter.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-filter.object-ids" => Some(("siteFilter.objectIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "site-filter.status" => Some(("siteFilter.status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "trafficker-type" => Some(("traffickerType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-access-type" => Some(("userAccessType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-role-filter.kind" => Some(("userRoleFilter.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-role-filter.object-ids" => Some(("userRoleFilter.objectIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "user-role-filter.status" => Some(("userRoleFilter.status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-role-id" => Some(("userRoleId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "advertiser-filter", "campaign-filter", "comments", "email", "id", "kind", "locale", "name", "object-ids", "site-filter", "status", "subaccount-id", "trafficker-type", "user-access-type", "user-role-filter", "user-role-id"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::AccountUserProfile = json::value::from_value(object).unwrap();
        let mut call = self.hub.account_user_profiles().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _account_user_profiles_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.account_user_profiles().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "user-role-id" => {
                    call = call.user_role_id(        value.map(|v| arg_from_str(v, err, "user-role-id", "int64")).unwrap_or(-0));
                },
                "subaccount-id" => {
                    call = call.subaccount_id(        value.map(|v| arg_from_str(v, err, "subaccount-id", "int64")).unwrap_or(-0));
                },
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "active" => {
                    call = call.active(        value.map(|v| arg_from_str(v, err, "active", "boolean")).unwrap_or(false));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["active", "ids", "max-results", "page-token", "search-string", "sort-field", "sort-order", "subaccount-id", "user-role-id"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _account_user_profiles_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-filter.kind" => Some(("advertiserFilter.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-filter.object-ids" => Some(("advertiserFilter.objectIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "advertiser-filter.status" => Some(("advertiserFilter.status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-filter.kind" => Some(("campaignFilter.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-filter.object-ids" => Some(("campaignFilter.objectIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "campaign-filter.status" => Some(("campaignFilter.status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "comments" => Some(("comments", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "email" => Some(("email", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "locale" => Some(("locale", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-filter.kind" => Some(("siteFilter.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-filter.object-ids" => Some(("siteFilter.objectIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "site-filter.status" => Some(("siteFilter.status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "trafficker-type" => Some(("traffickerType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-access-type" => Some(("userAccessType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-role-filter.kind" => Some(("userRoleFilter.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-role-filter.object-ids" => Some(("userRoleFilter.objectIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "user-role-filter.status" => Some(("userRoleFilter.status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-role-id" => Some(("userRoleId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "advertiser-filter", "campaign-filter", "comments", "email", "id", "kind", "locale", "name", "object-ids", "site-filter", "status", "subaccount-id", "trafficker-type", "user-access-type", "user-role-filter", "user-role-id"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::AccountUserProfile = json::value::from_value(object).unwrap();
        let mut call = self.hub.account_user_profiles().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _account_user_profiles_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-filter.kind" => Some(("advertiserFilter.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-filter.object-ids" => Some(("advertiserFilter.objectIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "advertiser-filter.status" => Some(("advertiserFilter.status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-filter.kind" => Some(("campaignFilter.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-filter.object-ids" => Some(("campaignFilter.objectIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "campaign-filter.status" => Some(("campaignFilter.status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "comments" => Some(("comments", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "email" => Some(("email", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "locale" => Some(("locale", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-filter.kind" => Some(("siteFilter.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-filter.object-ids" => Some(("siteFilter.objectIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "site-filter.status" => Some(("siteFilter.status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "trafficker-type" => Some(("traffickerType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-access-type" => Some(("userAccessType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-role-filter.kind" => Some(("userRoleFilter.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-role-filter.object-ids" => Some(("userRoleFilter.objectIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "user-role-filter.status" => Some(("userRoleFilter.status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-role-id" => Some(("userRoleId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "advertiser-filter", "campaign-filter", "comments", "email", "id", "kind", "locale", "name", "object-ids", "site-filter", "status", "subaccount-id", "trafficker-type", "user-access-type", "user-role-filter", "user-role-id"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::AccountUserProfile = json::value::from_value(object).unwrap();
        let mut call = self.hub.account_user_profiles().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _accounts_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.accounts().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _accounts_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.accounts().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "active" => {
                    call = call.active(        value.map(|v| arg_from_str(v, err, "active", "boolean")).unwrap_or(false));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["active", "ids", "max-results", "page-token", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _accounts_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-permission-ids" => Some(("accountPermissionIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "account-profile" => Some(("accountProfile", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "active-ads-limit-tier" => Some(("activeAdsLimitTier", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active-view-opt-out" => Some(("activeViewOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "available-permission-ids" => Some(("availablePermissionIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "country-id" => Some(("countryId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "currency-id" => Some(("currencyId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-creative-size-id" => Some(("defaultCreativeSizeId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "description" => Some(("description", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "locale" => Some(("locale", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "maximum-image-size" => Some(("maximumImageSize", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "nielsen-ocr-enabled" => Some(("nielsenOcrEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "reports-configuration.exposure-to-conversion-enabled" => Some(("reportsConfiguration.exposureToConversionEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "reports-configuration.lookback-configuration.click-duration" => Some(("reportsConfiguration.lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "reports-configuration.lookback-configuration.post-impression-activities-duration" => Some(("reportsConfiguration.lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "reports-configuration.report-generation-time-zone-id" => Some(("reportsConfiguration.reportGenerationTimeZoneId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "share-reports-with-twitter" => Some(("shareReportsWithTwitter", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "teaser-size-limit" => Some(("teaserSizeLimit", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-permission-ids", "account-profile", "active", "active-ads-limit-tier", "active-view-opt-out", "available-permission-ids", "click-duration", "country-id", "currency-id", "default-creative-size-id", "description", "exposure-to-conversion-enabled", "id", "kind", "locale", "lookback-configuration", "maximum-image-size", "name", "nielsen-ocr-enabled", "post-impression-activities-duration", "report-generation-time-zone-id", "reports-configuration", "share-reports-with-twitter", "teaser-size-limit"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Account = json::value::from_value(object).unwrap();
        let mut call = self.hub.accounts().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _accounts_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-permission-ids" => Some(("accountPermissionIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "account-profile" => Some(("accountProfile", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "active-ads-limit-tier" => Some(("activeAdsLimitTier", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active-view-opt-out" => Some(("activeViewOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "available-permission-ids" => Some(("availablePermissionIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "country-id" => Some(("countryId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "currency-id" => Some(("currencyId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-creative-size-id" => Some(("defaultCreativeSizeId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "description" => Some(("description", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "locale" => Some(("locale", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "maximum-image-size" => Some(("maximumImageSize", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "nielsen-ocr-enabled" => Some(("nielsenOcrEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "reports-configuration.exposure-to-conversion-enabled" => Some(("reportsConfiguration.exposureToConversionEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "reports-configuration.lookback-configuration.click-duration" => Some(("reportsConfiguration.lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "reports-configuration.lookback-configuration.post-impression-activities-duration" => Some(("reportsConfiguration.lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "reports-configuration.report-generation-time-zone-id" => Some(("reportsConfiguration.reportGenerationTimeZoneId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "share-reports-with-twitter" => Some(("shareReportsWithTwitter", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "teaser-size-limit" => Some(("teaserSizeLimit", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-permission-ids", "account-profile", "active", "active-ads-limit-tier", "active-view-opt-out", "available-permission-ids", "click-duration", "country-id", "currency-id", "default-creative-size-id", "description", "exposure-to-conversion-enabled", "id", "kind", "locale", "lookback-configuration", "maximum-image-size", "name", "nielsen-ocr-enabled", "post-impression-activities-duration", "report-generation-time-zone-id", "reports-configuration", "share-reports-with-twitter", "teaser-size-limit"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Account = json::value::from_value(object).unwrap();
        let mut call = self.hub.accounts().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _ads_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.ads().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _ads_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "audience-segment-id" => Some(("audienceSegmentId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id" => Some(("campaignId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.dimension-name" => Some(("campaignIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.etag" => Some(("campaignIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.id" => Some(("campaignIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.kind" => Some(("campaignIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.match-type" => Some(("campaignIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.value" => Some(("campaignIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url.computed-click-through-url" => Some(("clickThroughUrl.computedClickThroughUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url.custom-click-through-url" => Some(("clickThroughUrl.customClickThroughUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url.default-landing-page" => Some(("clickThroughUrl.defaultLandingPage", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "click-through-url.landing-page-id" => Some(("clickThroughUrl.landingPageId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix-properties.click-through-url-suffix" => Some(("clickThroughUrlSuffixProperties.clickThroughUrlSuffix", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix-properties.override-inherited-suffix" => Some(("clickThroughUrlSuffixProperties.overrideInheritedSuffix", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "comments" => Some(("comments", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "compatibility" => Some(("compatibility", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "create-info.time" => Some(("createInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-rotation.creative-optimization-configuration-id" => Some(("creativeRotation.creativeOptimizationConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-rotation.type" => Some(("creativeRotation.type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-rotation.weight-calculation-strategy" => Some(("creativeRotation.weightCalculationStrategy", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "day-part-targeting.days-of-week" => Some(("dayPartTargeting.daysOfWeek", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "day-part-targeting.hours-of-day" => Some(("dayPartTargeting.hoursOfDay", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Vec })),
                    "day-part-targeting.user-local-time" => Some(("dayPartTargeting.userLocalTime", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-properties.default-click-through-event-tag-id" => Some(("defaultClickThroughEventTagProperties.defaultClickThroughEventTagId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-properties.override-inherited-event-tag" => Some(("defaultClickThroughEventTagProperties.overrideInheritedEventTag", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery-schedule.frequency-cap.duration" => Some(("deliverySchedule.frequencyCap.duration", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery-schedule.frequency-cap.impressions" => Some(("deliverySchedule.frequencyCap.impressions", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery-schedule.hard-cutoff" => Some(("deliverySchedule.hardCutoff", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery-schedule.impression-ratio" => Some(("deliverySchedule.impressionRatio", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery-schedule.priority" => Some(("deliverySchedule.priority", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "dynamic-click-tracker" => Some(("dynamicClickTracker", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "end-time" => Some(("endTime", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "geo-targeting.exclude-countries" => Some(("geoTargeting.excludeCountries", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "key-value-targeting-expression.expression" => Some(("keyValueTargetingExpression.expression", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "remarketing-list-expression.expression" => Some(("remarketingListExpression.expression", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.height" => Some(("size.height", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "size.iab" => Some(("size.iab", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "size.id" => Some(("size.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.kind" => Some(("size.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.width" => Some(("size.width", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "ssl-compliant" => Some(("sslCompliant", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-required" => Some(("sslRequired", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "start-time" => Some(("startTime", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "targeting-template-id" => Some(("targetingTemplateId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "advertiser-id", "advertiser-id-dimension-value", "archived", "audience-segment-id", "campaign-id", "campaign-id-dimension-value", "click-through-url", "click-through-url-suffix", "click-through-url-suffix-properties", "comments", "compatibility", "computed-click-through-url", "create-info", "creative-optimization-configuration-id", "creative-rotation", "custom-click-through-url", "day-part-targeting", "days-of-week", "default-click-through-event-tag-id", "default-click-through-event-tag-properties", "default-landing-page", "delivery-schedule", "dimension-name", "duration", "dynamic-click-tracker", "end-time", "etag", "exclude-countries", "expression", "frequency-cap", "geo-targeting", "hard-cutoff", "height", "hours-of-day", "iab", "id", "id-dimension-value", "impression-ratio", "impressions", "key-value-targeting-expression", "kind", "landing-page-id", "last-modified-info", "match-type", "name", "override-inherited-event-tag", "override-inherited-suffix", "priority", "remarketing-list-expression", "size", "ssl-compliant", "ssl-required", "start-time", "subaccount-id", "targeting-template-id", "time", "type", "user-local-time", "value", "weight-calculation-strategy", "width"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Ad = json::value::from_value(object).unwrap();
        let mut call = self.hub.ads().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _ads_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.ads().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "type" => {
                    call = call.add_type(value.unwrap_or(""));
                },
                "ssl-required" => {
                    call = call.ssl_required(        value.map(|v| arg_from_str(v, err, "ssl-required", "boolean")).unwrap_or(false));
                },
                "ssl-compliant" => {
                    call = call.ssl_compliant(        value.map(|v| arg_from_str(v, err, "ssl-compliant", "boolean")).unwrap_or(false));
                },
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "size-ids" => {
                    call = call.add_size_ids(        value.map(|v| arg_from_str(v, err, "size-ids", "int64")).unwrap_or(-0));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "remarketing-list-ids" => {
                    call = call.add_remarketing_list_ids(        value.map(|v| arg_from_str(v, err, "remarketing-list-ids", "int64")).unwrap_or(-0));
                },
                "placement-ids" => {
                    call = call.add_placement_ids(        value.map(|v| arg_from_str(v, err, "placement-ids", "int64")).unwrap_or(-0));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "overridden-event-tag-id" => {
                    call = call.overridden_event_tag_id(        value.map(|v| arg_from_str(v, err, "overridden-event-tag-id", "int64")).unwrap_or(-0));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "landing-page-ids" => {
                    call = call.add_landing_page_ids(        value.map(|v| arg_from_str(v, err, "landing-page-ids", "int64")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "dynamic-click-tracker" => {
                    call = call.dynamic_click_tracker(        value.map(|v| arg_from_str(v, err, "dynamic-click-tracker", "boolean")).unwrap_or(false));
                },
                "creative-optimization-configuration-ids" => {
                    call = call.add_creative_optimization_configuration_ids(        value.map(|v| arg_from_str(v, err, "creative-optimization-configuration-ids", "int64")).unwrap_or(-0));
                },
                "creative-ids" => {
                    call = call.add_creative_ids(        value.map(|v| arg_from_str(v, err, "creative-ids", "int64")).unwrap_or(-0));
                },
                "compatibility" => {
                    call = call.compatibility(value.unwrap_or(""));
                },
                "campaign-ids" => {
                    call = call.add_campaign_ids(        value.map(|v| arg_from_str(v, err, "campaign-ids", "int64")).unwrap_or(-0));
                },
                "audience-segment-ids" => {
                    call = call.add_audience_segment_ids(        value.map(|v| arg_from_str(v, err, "audience-segment-ids", "int64")).unwrap_or(-0));
                },
                "archived" => {
                    call = call.archived(        value.map(|v| arg_from_str(v, err, "archived", "boolean")).unwrap_or(false));
                },
                "advertiser-id" => {
                    call = call.advertiser_id(        value.map(|v| arg_from_str(v, err, "advertiser-id", "int64")).unwrap_or(-0));
                },
                "active" => {
                    call = call.active(        value.map(|v| arg_from_str(v, err, "active", "boolean")).unwrap_or(false));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["active", "advertiser-id", "archived", "audience-segment-ids", "campaign-ids", "compatibility", "creative-ids", "creative-optimization-configuration-ids", "dynamic-click-tracker", "ids", "landing-page-ids", "max-results", "overridden-event-tag-id", "page-token", "placement-ids", "remarketing-list-ids", "search-string", "size-ids", "sort-field", "sort-order", "ssl-compliant", "ssl-required", "type"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _ads_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "audience-segment-id" => Some(("audienceSegmentId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id" => Some(("campaignId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.dimension-name" => Some(("campaignIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.etag" => Some(("campaignIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.id" => Some(("campaignIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.kind" => Some(("campaignIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.match-type" => Some(("campaignIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.value" => Some(("campaignIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url.computed-click-through-url" => Some(("clickThroughUrl.computedClickThroughUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url.custom-click-through-url" => Some(("clickThroughUrl.customClickThroughUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url.default-landing-page" => Some(("clickThroughUrl.defaultLandingPage", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "click-through-url.landing-page-id" => Some(("clickThroughUrl.landingPageId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix-properties.click-through-url-suffix" => Some(("clickThroughUrlSuffixProperties.clickThroughUrlSuffix", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix-properties.override-inherited-suffix" => Some(("clickThroughUrlSuffixProperties.overrideInheritedSuffix", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "comments" => Some(("comments", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "compatibility" => Some(("compatibility", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "create-info.time" => Some(("createInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-rotation.creative-optimization-configuration-id" => Some(("creativeRotation.creativeOptimizationConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-rotation.type" => Some(("creativeRotation.type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-rotation.weight-calculation-strategy" => Some(("creativeRotation.weightCalculationStrategy", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "day-part-targeting.days-of-week" => Some(("dayPartTargeting.daysOfWeek", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "day-part-targeting.hours-of-day" => Some(("dayPartTargeting.hoursOfDay", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Vec })),
                    "day-part-targeting.user-local-time" => Some(("dayPartTargeting.userLocalTime", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-properties.default-click-through-event-tag-id" => Some(("defaultClickThroughEventTagProperties.defaultClickThroughEventTagId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-properties.override-inherited-event-tag" => Some(("defaultClickThroughEventTagProperties.overrideInheritedEventTag", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery-schedule.frequency-cap.duration" => Some(("deliverySchedule.frequencyCap.duration", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery-schedule.frequency-cap.impressions" => Some(("deliverySchedule.frequencyCap.impressions", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery-schedule.hard-cutoff" => Some(("deliverySchedule.hardCutoff", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery-schedule.impression-ratio" => Some(("deliverySchedule.impressionRatio", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery-schedule.priority" => Some(("deliverySchedule.priority", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "dynamic-click-tracker" => Some(("dynamicClickTracker", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "end-time" => Some(("endTime", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "geo-targeting.exclude-countries" => Some(("geoTargeting.excludeCountries", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "key-value-targeting-expression.expression" => Some(("keyValueTargetingExpression.expression", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "remarketing-list-expression.expression" => Some(("remarketingListExpression.expression", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.height" => Some(("size.height", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "size.iab" => Some(("size.iab", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "size.id" => Some(("size.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.kind" => Some(("size.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.width" => Some(("size.width", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "ssl-compliant" => Some(("sslCompliant", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-required" => Some(("sslRequired", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "start-time" => Some(("startTime", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "targeting-template-id" => Some(("targetingTemplateId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "advertiser-id", "advertiser-id-dimension-value", "archived", "audience-segment-id", "campaign-id", "campaign-id-dimension-value", "click-through-url", "click-through-url-suffix", "click-through-url-suffix-properties", "comments", "compatibility", "computed-click-through-url", "create-info", "creative-optimization-configuration-id", "creative-rotation", "custom-click-through-url", "day-part-targeting", "days-of-week", "default-click-through-event-tag-id", "default-click-through-event-tag-properties", "default-landing-page", "delivery-schedule", "dimension-name", "duration", "dynamic-click-tracker", "end-time", "etag", "exclude-countries", "expression", "frequency-cap", "geo-targeting", "hard-cutoff", "height", "hours-of-day", "iab", "id", "id-dimension-value", "impression-ratio", "impressions", "key-value-targeting-expression", "kind", "landing-page-id", "last-modified-info", "match-type", "name", "override-inherited-event-tag", "override-inherited-suffix", "priority", "remarketing-list-expression", "size", "ssl-compliant", "ssl-required", "start-time", "subaccount-id", "targeting-template-id", "time", "type", "user-local-time", "value", "weight-calculation-strategy", "width"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Ad = json::value::from_value(object).unwrap();
        let mut call = self.hub.ads().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _ads_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "audience-segment-id" => Some(("audienceSegmentId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id" => Some(("campaignId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.dimension-name" => Some(("campaignIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.etag" => Some(("campaignIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.id" => Some(("campaignIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.kind" => Some(("campaignIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.match-type" => Some(("campaignIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.value" => Some(("campaignIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url.computed-click-through-url" => Some(("clickThroughUrl.computedClickThroughUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url.custom-click-through-url" => Some(("clickThroughUrl.customClickThroughUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url.default-landing-page" => Some(("clickThroughUrl.defaultLandingPage", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "click-through-url.landing-page-id" => Some(("clickThroughUrl.landingPageId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix-properties.click-through-url-suffix" => Some(("clickThroughUrlSuffixProperties.clickThroughUrlSuffix", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix-properties.override-inherited-suffix" => Some(("clickThroughUrlSuffixProperties.overrideInheritedSuffix", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "comments" => Some(("comments", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "compatibility" => Some(("compatibility", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "create-info.time" => Some(("createInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-rotation.creative-optimization-configuration-id" => Some(("creativeRotation.creativeOptimizationConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-rotation.type" => Some(("creativeRotation.type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-rotation.weight-calculation-strategy" => Some(("creativeRotation.weightCalculationStrategy", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "day-part-targeting.days-of-week" => Some(("dayPartTargeting.daysOfWeek", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "day-part-targeting.hours-of-day" => Some(("dayPartTargeting.hoursOfDay", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Vec })),
                    "day-part-targeting.user-local-time" => Some(("dayPartTargeting.userLocalTime", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-properties.default-click-through-event-tag-id" => Some(("defaultClickThroughEventTagProperties.defaultClickThroughEventTagId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-properties.override-inherited-event-tag" => Some(("defaultClickThroughEventTagProperties.overrideInheritedEventTag", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery-schedule.frequency-cap.duration" => Some(("deliverySchedule.frequencyCap.duration", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery-schedule.frequency-cap.impressions" => Some(("deliverySchedule.frequencyCap.impressions", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery-schedule.hard-cutoff" => Some(("deliverySchedule.hardCutoff", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery-schedule.impression-ratio" => Some(("deliverySchedule.impressionRatio", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery-schedule.priority" => Some(("deliverySchedule.priority", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "dynamic-click-tracker" => Some(("dynamicClickTracker", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "end-time" => Some(("endTime", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "geo-targeting.exclude-countries" => Some(("geoTargeting.excludeCountries", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "key-value-targeting-expression.expression" => Some(("keyValueTargetingExpression.expression", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "remarketing-list-expression.expression" => Some(("remarketingListExpression.expression", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.height" => Some(("size.height", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "size.iab" => Some(("size.iab", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "size.id" => Some(("size.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.kind" => Some(("size.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.width" => Some(("size.width", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "ssl-compliant" => Some(("sslCompliant", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-required" => Some(("sslRequired", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "start-time" => Some(("startTime", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "targeting-template-id" => Some(("targetingTemplateId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "advertiser-id", "advertiser-id-dimension-value", "archived", "audience-segment-id", "campaign-id", "campaign-id-dimension-value", "click-through-url", "click-through-url-suffix", "click-through-url-suffix-properties", "comments", "compatibility", "computed-click-through-url", "create-info", "creative-optimization-configuration-id", "creative-rotation", "custom-click-through-url", "day-part-targeting", "days-of-week", "default-click-through-event-tag-id", "default-click-through-event-tag-properties", "default-landing-page", "delivery-schedule", "dimension-name", "duration", "dynamic-click-tracker", "end-time", "etag", "exclude-countries", "expression", "frequency-cap", "geo-targeting", "hard-cutoff", "height", "hours-of-day", "iab", "id", "id-dimension-value", "impression-ratio", "impressions", "key-value-targeting-expression", "kind", "landing-page-id", "last-modified-info", "match-type", "name", "override-inherited-event-tag", "override-inherited-suffix", "priority", "remarketing-list-expression", "size", "ssl-compliant", "ssl-required", "start-time", "subaccount-id", "targeting-template-id", "time", "type", "user-local-time", "value", "weight-calculation-strategy", "width"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Ad = json::value::from_value(object).unwrap();
        let mut call = self.hub.ads().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _advertiser_groups_delete(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.advertiser_groups().delete(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok(mut response) => {
                    Ok(())
                }
            }
        }
    }

    async fn _advertiser_groups_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.advertiser_groups().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _advertiser_groups_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "id", "kind", "name"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::AdvertiserGroup = json::value::from_value(object).unwrap();
        let mut call = self.hub.advertiser_groups().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _advertiser_groups_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.advertiser_groups().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["ids", "max-results", "page-token", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _advertiser_groups_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "id", "kind", "name"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::AdvertiserGroup = json::value::from_value(object).unwrap();
        let mut call = self.hub.advertiser_groups().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _advertiser_groups_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "id", "kind", "name"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::AdvertiserGroup = json::value::from_value(object).unwrap();
        let mut call = self.hub.advertiser_groups().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _advertisers_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.advertisers().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _advertisers_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-group-id" => Some(("advertiserGroupId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix" => Some(("clickThroughUrlSuffix", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-id" => Some(("defaultClickThroughEventTagId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-email" => Some(("defaultEmail", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id" => Some(("floodlightConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.dimension-name" => Some(("floodlightConfigurationIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.etag" => Some(("floodlightConfigurationIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.id" => Some(("floodlightConfigurationIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.kind" => Some(("floodlightConfigurationIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.match-type" => Some(("floodlightConfigurationIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.value" => Some(("floodlightConfigurationIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "original-floodlight-configuration-id" => Some(("originalFloodlightConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "status" => Some(("status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "suspended" => Some(("suspended", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-group-id", "click-through-url-suffix", "default-click-through-event-tag-id", "default-email", "dimension-name", "etag", "floodlight-configuration-id", "floodlight-configuration-id-dimension-value", "id", "id-dimension-value", "kind", "match-type", "name", "original-floodlight-configuration-id", "status", "subaccount-id", "suspended", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Advertiser = json::value::from_value(object).unwrap();
        let mut call = self.hub.advertisers().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _advertisers_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.advertisers().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "subaccount-id" => {
                    call = call.subaccount_id(        value.map(|v| arg_from_str(v, err, "subaccount-id", "int64")).unwrap_or(-0));
                },
                "status" => {
                    call = call.status(value.unwrap_or(""));
                },
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "only-parent" => {
                    call = call.only_parent(        value.map(|v| arg_from_str(v, err, "only-parent", "boolean")).unwrap_or(false));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "include-advertisers-without-groups-only" => {
                    call = call.include_advertisers_without_groups_only(        value.map(|v| arg_from_str(v, err, "include-advertisers-without-groups-only", "boolean")).unwrap_or(false));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "floodlight-configuration-ids" => {
                    call = call.add_floodlight_configuration_ids(        value.map(|v| arg_from_str(v, err, "floodlight-configuration-ids", "int64")).unwrap_or(-0));
                },
                "advertiser-group-ids" => {
                    call = call.add_advertiser_group_ids(        value.map(|v| arg_from_str(v, err, "advertiser-group-ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["advertiser-group-ids", "floodlight-configuration-ids", "ids", "include-advertisers-without-groups-only", "max-results", "only-parent", "page-token", "search-string", "sort-field", "sort-order", "status", "subaccount-id"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _advertisers_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-group-id" => Some(("advertiserGroupId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix" => Some(("clickThroughUrlSuffix", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-id" => Some(("defaultClickThroughEventTagId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-email" => Some(("defaultEmail", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id" => Some(("floodlightConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.dimension-name" => Some(("floodlightConfigurationIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.etag" => Some(("floodlightConfigurationIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.id" => Some(("floodlightConfigurationIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.kind" => Some(("floodlightConfigurationIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.match-type" => Some(("floodlightConfigurationIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.value" => Some(("floodlightConfigurationIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "original-floodlight-configuration-id" => Some(("originalFloodlightConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "status" => Some(("status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "suspended" => Some(("suspended", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-group-id", "click-through-url-suffix", "default-click-through-event-tag-id", "default-email", "dimension-name", "etag", "floodlight-configuration-id", "floodlight-configuration-id-dimension-value", "id", "id-dimension-value", "kind", "match-type", "name", "original-floodlight-configuration-id", "status", "subaccount-id", "suspended", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Advertiser = json::value::from_value(object).unwrap();
        let mut call = self.hub.advertisers().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _advertisers_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-group-id" => Some(("advertiserGroupId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix" => Some(("clickThroughUrlSuffix", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-id" => Some(("defaultClickThroughEventTagId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-email" => Some(("defaultEmail", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id" => Some(("floodlightConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.dimension-name" => Some(("floodlightConfigurationIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.etag" => Some(("floodlightConfigurationIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.id" => Some(("floodlightConfigurationIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.kind" => Some(("floodlightConfigurationIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.match-type" => Some(("floodlightConfigurationIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.value" => Some(("floodlightConfigurationIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "original-floodlight-configuration-id" => Some(("originalFloodlightConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "status" => Some(("status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "suspended" => Some(("suspended", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-group-id", "click-through-url-suffix", "default-click-through-event-tag-id", "default-email", "dimension-name", "etag", "floodlight-configuration-id", "floodlight-configuration-id-dimension-value", "id", "id-dimension-value", "kind", "match-type", "name", "original-floodlight-configuration-id", "status", "subaccount-id", "suspended", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Advertiser = json::value::from_value(object).unwrap();
        let mut call = self.hub.advertisers().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _browsers_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.browsers().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _campaign_creative_associations_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "creative-id" => Some(("creativeId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["creative-id", "kind"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::CampaignCreativeAssociation = json::value::from_value(object).unwrap();
        let mut call = self.hub.campaign_creative_associations().insert(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("campaign-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _campaign_creative_associations_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.campaign_creative_associations().list(opt.value_of("profile-id").unwrap_or(""), opt.value_of("campaign-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["max-results", "page-token", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _campaigns_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.campaigns().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _campaigns_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-blocking-configuration.click-through-url" => Some(("adBlockingConfiguration.clickThroughUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-blocking-configuration.creative-bundle-id" => Some(("adBlockingConfiguration.creativeBundleId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-blocking-configuration.enabled" => Some(("adBlockingConfiguration.enabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ad-blocking-configuration.override-click-through-url" => Some(("adBlockingConfiguration.overrideClickThroughUrl", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-group-id" => Some(("advertiserGroupId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "billing-invoice-code" => Some(("billingInvoiceCode", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix-properties.click-through-url-suffix" => Some(("clickThroughUrlSuffixProperties.clickThroughUrlSuffix", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix-properties.override-inherited-suffix" => Some(("clickThroughUrlSuffixProperties.overrideInheritedSuffix", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "comment" => Some(("comment", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "create-info.time" => Some(("createInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-group-ids" => Some(("creativeGroupIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "creative-optimization-configuration.id" => Some(("creativeOptimizationConfiguration.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-optimization-configuration.name" => Some(("creativeOptimizationConfiguration.name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-optimization-configuration.optimization-model" => Some(("creativeOptimizationConfiguration.optimizationModel", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-properties.default-click-through-event-tag-id" => Some(("defaultClickThroughEventTagProperties.defaultClickThroughEventTagId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-properties.override-inherited-event-tag" => Some(("defaultClickThroughEventTagProperties.overrideInheritedEventTag", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "end-date" => Some(("endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "external-id" => Some(("externalId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "lookback-configuration.click-duration" => Some(("lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "lookback-configuration.post-impression-activities-duration" => Some(("lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "nielsen-ocr-enabled" => Some(("nielsenOcrEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "start-date" => Some(("startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "trafficker-emails" => Some(("traffickerEmails", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "ad-blocking-configuration", "advertiser-group-id", "advertiser-id", "advertiser-id-dimension-value", "archived", "billing-invoice-code", "click-duration", "click-through-url", "click-through-url-suffix", "click-through-url-suffix-properties", "comment", "create-info", "creative-bundle-id", "creative-group-ids", "creative-optimization-configuration", "default-click-through-event-tag-id", "default-click-through-event-tag-properties", "dimension-name", "enabled", "end-date", "etag", "external-id", "id", "id-dimension-value", "kind", "last-modified-info", "lookback-configuration", "match-type", "name", "nielsen-ocr-enabled", "optimization-model", "override-click-through-url", "override-inherited-event-tag", "override-inherited-suffix", "post-impression-activities-duration", "start-date", "subaccount-id", "time", "trafficker-emails", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Campaign = json::value::from_value(object).unwrap();
        let mut call = self.hub.campaigns().insert(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("default-landing-page-name").unwrap_or(""), opt.value_of("default-landing-page-url").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _campaigns_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.campaigns().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "subaccount-id" => {
                    call = call.subaccount_id(        value.map(|v| arg_from_str(v, err, "subaccount-id", "int64")).unwrap_or(-0));
                },
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "overridden-event-tag-id" => {
                    call = call.overridden_event_tag_id(        value.map(|v| arg_from_str(v, err, "overridden-event-tag-id", "int64")).unwrap_or(-0));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "excluded-ids" => {
                    call = call.add_excluded_ids(        value.map(|v| arg_from_str(v, err, "excluded-ids", "int64")).unwrap_or(-0));
                },
                "at-least-one-optimization-activity" => {
                    call = call.at_least_one_optimization_activity(        value.map(|v| arg_from_str(v, err, "at-least-one-optimization-activity", "boolean")).unwrap_or(false));
                },
                "archived" => {
                    call = call.archived(        value.map(|v| arg_from_str(v, err, "archived", "boolean")).unwrap_or(false));
                },
                "advertiser-ids" => {
                    call = call.add_advertiser_ids(        value.map(|v| arg_from_str(v, err, "advertiser-ids", "int64")).unwrap_or(-0));
                },
                "advertiser-group-ids" => {
                    call = call.add_advertiser_group_ids(        value.map(|v| arg_from_str(v, err, "advertiser-group-ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["advertiser-group-ids", "advertiser-ids", "archived", "at-least-one-optimization-activity", "excluded-ids", "ids", "max-results", "overridden-event-tag-id", "page-token", "search-string", "sort-field", "sort-order", "subaccount-id"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _campaigns_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-blocking-configuration.click-through-url" => Some(("adBlockingConfiguration.clickThroughUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-blocking-configuration.creative-bundle-id" => Some(("adBlockingConfiguration.creativeBundleId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-blocking-configuration.enabled" => Some(("adBlockingConfiguration.enabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ad-blocking-configuration.override-click-through-url" => Some(("adBlockingConfiguration.overrideClickThroughUrl", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-group-id" => Some(("advertiserGroupId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "billing-invoice-code" => Some(("billingInvoiceCode", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix-properties.click-through-url-suffix" => Some(("clickThroughUrlSuffixProperties.clickThroughUrlSuffix", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix-properties.override-inherited-suffix" => Some(("clickThroughUrlSuffixProperties.overrideInheritedSuffix", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "comment" => Some(("comment", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "create-info.time" => Some(("createInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-group-ids" => Some(("creativeGroupIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "creative-optimization-configuration.id" => Some(("creativeOptimizationConfiguration.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-optimization-configuration.name" => Some(("creativeOptimizationConfiguration.name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-optimization-configuration.optimization-model" => Some(("creativeOptimizationConfiguration.optimizationModel", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-properties.default-click-through-event-tag-id" => Some(("defaultClickThroughEventTagProperties.defaultClickThroughEventTagId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-properties.override-inherited-event-tag" => Some(("defaultClickThroughEventTagProperties.overrideInheritedEventTag", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "end-date" => Some(("endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "external-id" => Some(("externalId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "lookback-configuration.click-duration" => Some(("lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "lookback-configuration.post-impression-activities-duration" => Some(("lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "nielsen-ocr-enabled" => Some(("nielsenOcrEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "start-date" => Some(("startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "trafficker-emails" => Some(("traffickerEmails", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "ad-blocking-configuration", "advertiser-group-id", "advertiser-id", "advertiser-id-dimension-value", "archived", "billing-invoice-code", "click-duration", "click-through-url", "click-through-url-suffix", "click-through-url-suffix-properties", "comment", "create-info", "creative-bundle-id", "creative-group-ids", "creative-optimization-configuration", "default-click-through-event-tag-id", "default-click-through-event-tag-properties", "dimension-name", "enabled", "end-date", "etag", "external-id", "id", "id-dimension-value", "kind", "last-modified-info", "lookback-configuration", "match-type", "name", "nielsen-ocr-enabled", "optimization-model", "override-click-through-url", "override-inherited-event-tag", "override-inherited-suffix", "post-impression-activities-duration", "start-date", "subaccount-id", "time", "trafficker-emails", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Campaign = json::value::from_value(object).unwrap();
        let mut call = self.hub.campaigns().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _campaigns_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-blocking-configuration.click-through-url" => Some(("adBlockingConfiguration.clickThroughUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-blocking-configuration.creative-bundle-id" => Some(("adBlockingConfiguration.creativeBundleId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-blocking-configuration.enabled" => Some(("adBlockingConfiguration.enabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ad-blocking-configuration.override-click-through-url" => Some(("adBlockingConfiguration.overrideClickThroughUrl", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-group-id" => Some(("advertiserGroupId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "billing-invoice-code" => Some(("billingInvoiceCode", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix-properties.click-through-url-suffix" => Some(("clickThroughUrlSuffixProperties.clickThroughUrlSuffix", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "click-through-url-suffix-properties.override-inherited-suffix" => Some(("clickThroughUrlSuffixProperties.overrideInheritedSuffix", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "comment" => Some(("comment", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "create-info.time" => Some(("createInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-group-ids" => Some(("creativeGroupIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "creative-optimization-configuration.id" => Some(("creativeOptimizationConfiguration.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-optimization-configuration.name" => Some(("creativeOptimizationConfiguration.name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "creative-optimization-configuration.optimization-model" => Some(("creativeOptimizationConfiguration.optimizationModel", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-properties.default-click-through-event-tag-id" => Some(("defaultClickThroughEventTagProperties.defaultClickThroughEventTagId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-click-through-event-tag-properties.override-inherited-event-tag" => Some(("defaultClickThroughEventTagProperties.overrideInheritedEventTag", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "end-date" => Some(("endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "external-id" => Some(("externalId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "lookback-configuration.click-duration" => Some(("lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "lookback-configuration.post-impression-activities-duration" => Some(("lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "nielsen-ocr-enabled" => Some(("nielsenOcrEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "start-date" => Some(("startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "trafficker-emails" => Some(("traffickerEmails", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "ad-blocking-configuration", "advertiser-group-id", "advertiser-id", "advertiser-id-dimension-value", "archived", "billing-invoice-code", "click-duration", "click-through-url", "click-through-url-suffix", "click-through-url-suffix-properties", "comment", "create-info", "creative-bundle-id", "creative-group-ids", "creative-optimization-configuration", "default-click-through-event-tag-id", "default-click-through-event-tag-properties", "dimension-name", "enabled", "end-date", "etag", "external-id", "id", "id-dimension-value", "kind", "last-modified-info", "lookback-configuration", "match-type", "name", "nielsen-ocr-enabled", "optimization-model", "override-click-through-url", "override-inherited-event-tag", "override-inherited-suffix", "post-impression-activities-duration", "start-date", "subaccount-id", "time", "trafficker-emails", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Campaign = json::value::from_value(object).unwrap();
        let mut call = self.hub.campaigns().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _change_logs_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.change_logs().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _change_logs_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.change_logs().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "user-profile-ids" => {
                    call = call.add_user_profile_ids(        value.map(|v| arg_from_str(v, err, "user-profile-ids", "int64")).unwrap_or(-0));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "object-type" => {
                    call = call.object_type(value.unwrap_or(""));
                },
                "object-ids" => {
                    call = call.add_object_ids(        value.map(|v| arg_from_str(v, err, "object-ids", "int64")).unwrap_or(-0));
                },
                "min-change-time" => {
                    call = call.min_change_time(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "max-change-time" => {
                    call = call.max_change_time(value.unwrap_or(""));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "action" => {
                    call = call.action(value.unwrap_or(""));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["action", "ids", "max-change-time", "max-results", "min-change-time", "object-ids", "object-type", "page-token", "search-string", "user-profile-ids"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _cities_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.cities().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "region-dart-ids" => {
                    call = call.add_region_dart_ids(        value.map(|v| arg_from_str(v, err, "region-dart-ids", "int64")).unwrap_or(-0));
                },
                "name-prefix" => {
                    call = call.name_prefix(value.unwrap_or(""));
                },
                "dart-ids" => {
                    call = call.add_dart_ids(        value.map(|v| arg_from_str(v, err, "dart-ids", "int64")).unwrap_or(-0));
                },
                "country-dart-ids" => {
                    call = call.add_country_dart_ids(        value.map(|v| arg_from_str(v, err, "country-dart-ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["country-dart-ids", "dart-ids", "name-prefix", "region-dart-ids"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _connection_types_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.connection_types().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _connection_types_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.connection_types().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _content_categories_delete(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.content_categories().delete(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok(mut response) => {
                    Ok(())
                }
            }
        }
    }

    async fn _content_categories_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.content_categories().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _content_categories_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "id", "kind", "name"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::ContentCategory = json::value::from_value(object).unwrap();
        let mut call = self.hub.content_categories().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _content_categories_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.content_categories().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["ids", "max-results", "page-token", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _content_categories_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "id", "kind", "name"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::ContentCategory = json::value::from_value(object).unwrap();
        let mut call = self.hub.content_categories().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _content_categories_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "id", "kind", "name"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::ContentCategory = json::value::from_value(object).unwrap();
        let mut call = self.hub.content_categories().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _conversions_batchinsert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "encryption-info.encryption-entity-id" => Some(("encryptionInfo.encryptionEntityId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "encryption-info.encryption-entity-type" => Some(("encryptionInfo.encryptionEntityType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "encryption-info.encryption-source" => Some(("encryptionInfo.encryptionSource", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "encryption-info.kind" => Some(("encryptionInfo.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["encryption-entity-id", "encryption-entity-type", "encryption-info", "encryption-source", "kind"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::ConversionsBatchInsertRequest = json::value::from_value(object).unwrap();
        let mut call = self.hub.conversions().batchinsert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _conversions_batchupdate(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "encryption-info.encryption-entity-id" => Some(("encryptionInfo.encryptionEntityId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "encryption-info.encryption-entity-type" => Some(("encryptionInfo.encryptionEntityType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "encryption-info.encryption-source" => Some(("encryptionInfo.encryptionSource", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "encryption-info.kind" => Some(("encryptionInfo.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["encryption-entity-id", "encryption-entity-type", "encryption-info", "encryption-source", "kind"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::ConversionsBatchUpdateRequest = json::value::from_value(object).unwrap();
        let mut call = self.hub.conversions().batchupdate(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _countries_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.countries().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("dart-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _countries_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.countries().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_assets_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "asset-identifier.name" => Some(("assetIdentifier.name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "asset-identifier.type" => Some(("assetIdentifier.type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "detected-features" => Some(("detectedFeatures", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "warned-validation-rules" => Some(("warnedValidationRules", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["asset-identifier", "detected-features", "dimension-name", "etag", "id", "id-dimension-value", "kind", "match-type", "name", "type", "value", "warned-validation-rules"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::CreativeAssetMetadata = json::value::from_value(object).unwrap();
        let mut call = self.hub.creative_assets().insert(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("advertiser-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let vals = opt.values_of("mode").unwrap().collect::<Vec<&str>>();
        let protocol = calltype_from_str(vals[0], ["simple"].iter().map(|&v| v.to_string()).collect(), err);
        let mut input_file = input_file_from_opts(vals[1], err);
        let mime_type = input_mime_from_opts(opt.value_of("mime").unwrap_or("application/octet-stream"), err);
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Upload(UploadProtocol::Simple) => call.upload(input_file.unwrap(), mime_type.unwrap()).await,
                CallType::Standard => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_field_values_delete(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.creative_field_values().delete(opt.value_of("profile-id").unwrap_or(""), opt.value_of("creative-field-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok(mut response) => {
                    Ok(())
                }
            }
        }
    }

    async fn _creative_field_values_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.creative_field_values().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("creative-field-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_field_values_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "value" => Some(("value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["id", "kind", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::CreativeFieldValue = json::value::from_value(object).unwrap();
        let mut call = self.hub.creative_field_values().insert(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("creative-field-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_field_values_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.creative_field_values().list(opt.value_of("profile-id").unwrap_or(""), opt.value_of("creative-field-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["ids", "max-results", "page-token", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_field_values_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "value" => Some(("value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["id", "kind", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::CreativeFieldValue = json::value::from_value(object).unwrap();
        let mut call = self.hub.creative_field_values().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("creative-field-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_field_values_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "value" => Some(("value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["id", "kind", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::CreativeFieldValue = json::value::from_value(object).unwrap();
        let mut call = self.hub.creative_field_values().update(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("creative-field-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_fields_delete(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.creative_fields().delete(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok(mut response) => {
                    Ok(())
                }
            }
        }
    }

    async fn _creative_fields_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.creative_fields().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_fields_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "dimension-name", "etag", "id", "kind", "match-type", "name", "subaccount-id", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::CreativeField = json::value::from_value(object).unwrap();
        let mut call = self.hub.creative_fields().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_fields_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.creative_fields().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "advertiser-ids" => {
                    call = call.add_advertiser_ids(        value.map(|v| arg_from_str(v, err, "advertiser-ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["advertiser-ids", "ids", "max-results", "page-token", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_fields_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "dimension-name", "etag", "id", "kind", "match-type", "name", "subaccount-id", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::CreativeField = json::value::from_value(object).unwrap();
        let mut call = self.hub.creative_fields().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_fields_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "dimension-name", "etag", "id", "kind", "match-type", "name", "subaccount-id", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::CreativeField = json::value::from_value(object).unwrap();
        let mut call = self.hub.creative_fields().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_groups_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.creative_groups().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_groups_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "group-number" => Some(("groupNumber", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "dimension-name", "etag", "group-number", "id", "kind", "match-type", "name", "subaccount-id", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::CreativeGroup = json::value::from_value(object).unwrap();
        let mut call = self.hub.creative_groups().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_groups_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.creative_groups().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "group-number" => {
                    call = call.group_number(        value.map(|v| arg_from_str(v, err, "group-number", "int32")).unwrap_or(-0));
                },
                "advertiser-ids" => {
                    call = call.add_advertiser_ids(        value.map(|v| arg_from_str(v, err, "advertiser-ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["advertiser-ids", "group-number", "ids", "max-results", "page-token", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_groups_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "group-number" => Some(("groupNumber", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "dimension-name", "etag", "group-number", "id", "kind", "match-type", "name", "subaccount-id", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::CreativeGroup = json::value::from_value(object).unwrap();
        let mut call = self.hub.creative_groups().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creative_groups_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "group-number" => Some(("groupNumber", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "dimension-name", "etag", "group-number", "id", "kind", "match-type", "name", "subaccount-id", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::CreativeGroup = json::value::from_value(object).unwrap();
        let mut call = self.hub.creative_groups().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creatives_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.creatives().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creatives_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ad-parameters" => Some(("adParameters", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-tag-keys" => Some(("adTagKeys", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "allow-script-access" => Some(("allowScriptAccess", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "artwork-type" => Some(("artworkType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "authoring-source" => Some(("authoringSource", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "authoring-tool" => Some(("authoringTool", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "auto-advance-images" => Some(("autoAdvanceImages", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "background-color" => Some(("backgroundColor", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "backup-image-click-through-url" => Some(("backupImageClickThroughUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "backup-image-features" => Some(("backupImageFeatures", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "backup-image-reporting-label" => Some(("backupImageReportingLabel", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "backup-image-target-window.custom-html" => Some(("backupImageTargetWindow.customHtml", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "backup-image-target-window.target-window-option" => Some(("backupImageTargetWindow.targetWindowOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "commercial-id" => Some(("commercialId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "companion-creatives" => Some(("companionCreatives", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "compatibility" => Some(("compatibility", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "convert-flash-to-html5" => Some(("convertFlashToHtml5", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "creative-asset-selection.default-asset-id" => Some(("creativeAssetSelection.defaultAssetId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "custom-key-values" => Some(("customKeyValues", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "dynamic-asset-selection" => Some(("dynamicAssetSelection", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "fs-command.left" => Some(("fsCommand.left", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "fs-command.position-option" => Some(("fsCommand.positionOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "fs-command.top" => Some(("fsCommand.top", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "fs-command.window-height" => Some(("fsCommand.windowHeight", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "fs-command.window-width" => Some(("fsCommand.windowWidth", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "html-code" => Some(("htmlCode", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "html-code-locked" => Some(("htmlCodeLocked", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "latest-trafficked-creative-id" => Some(("latestTraffickedCreativeId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "override-css" => Some(("overrideCss", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "progress-offset.offset-percentage" => Some(("progressOffset.offsetPercentage", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "progress-offset.offset-seconds" => Some(("progressOffset.offsetSeconds", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "redirect-url" => Some(("redirectUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id" => Some(("renderingId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.dimension-name" => Some(("renderingIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.etag" => Some(("renderingIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.id" => Some(("renderingIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.kind" => Some(("renderingIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.match-type" => Some(("renderingIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.value" => Some(("renderingIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "required-flash-plugin-version" => Some(("requiredFlashPluginVersion", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "required-flash-version" => Some(("requiredFlashVersion", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "size.height" => Some(("size.height", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "size.iab" => Some(("size.iab", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "size.id" => Some(("size.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.kind" => Some(("size.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.width" => Some(("size.width", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "skip-offset.offset-percentage" => Some(("skipOffset.offsetPercentage", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "skip-offset.offset-seconds" => Some(("skipOffset.offsetSeconds", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "skippable" => Some(("skippable", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-compliant" => Some(("sslCompliant", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-override" => Some(("sslOverride", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "studio-advertiser-id" => Some(("studioAdvertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "studio-creative-id" => Some(("studioCreativeId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "studio-trafficked-creative-id" => Some(("studioTraffickedCreativeId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "third-party-backup-image-impressions-url" => Some(("thirdPartyBackupImageImpressionsUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "third-party-rich-media-impressions-url" => Some(("thirdPartyRichMediaImpressionsUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "total-file-size" => Some(("totalFileSize", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "universal-ad-id.registry" => Some(("universalAdId.registry", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "universal-ad-id.value" => Some(("universalAdId.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "version" => Some(("version", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-description" => Some(("videoDescription", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-duration" => Some(("videoDuration", JsonTypeInfo { jtype: JsonType::Float, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "ad-parameters", "ad-tag-keys", "advertiser-id", "allow-script-access", "archived", "artwork-type", "authoring-source", "authoring-tool", "auto-advance-images", "background-color", "backup-image-click-through-url", "backup-image-features", "backup-image-reporting-label", "backup-image-target-window", "commercial-id", "companion-creatives", "compatibility", "convert-flash-to-html5", "creative-asset-selection", "custom-html", "custom-key-values", "default-asset-id", "dimension-name", "dynamic-asset-selection", "etag", "fs-command", "height", "html-code", "html-code-locked", "iab", "id", "id-dimension-value", "kind", "last-modified-info", "latest-trafficked-creative-id", "left", "match-type", "name", "offset-percentage", "offset-seconds", "override-css", "position-option", "progress-offset", "redirect-url", "registry", "rendering-id", "rendering-id-dimension-value", "required-flash-plugin-version", "required-flash-version", "size", "skip-offset", "skippable", "ssl-compliant", "ssl-override", "studio-advertiser-id", "studio-creative-id", "studio-trafficked-creative-id", "subaccount-id", "target-window-option", "third-party-backup-image-impressions-url", "third-party-rich-media-impressions-url", "time", "top", "total-file-size", "type", "universal-ad-id", "value", "version", "video-description", "video-duration", "width", "window-height", "window-width"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Creative = json::value::from_value(object).unwrap();
        let mut call = self.hub.creatives().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creatives_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.creatives().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "types" => {
                    call = call.add_types(value.unwrap_or(""));
                },
                "studio-creative-id" => {
                    call = call.studio_creative_id(        value.map(|v| arg_from_str(v, err, "studio-creative-id", "int64")).unwrap_or(-0));
                },
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "size-ids" => {
                    call = call.add_size_ids(        value.map(|v| arg_from_str(v, err, "size-ids", "int64")).unwrap_or(-0));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "rendering-ids" => {
                    call = call.add_rendering_ids(        value.map(|v| arg_from_str(v, err, "rendering-ids", "int64")).unwrap_or(-0));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "creative-field-ids" => {
                    call = call.add_creative_field_ids(        value.map(|v| arg_from_str(v, err, "creative-field-ids", "int64")).unwrap_or(-0));
                },
                "companion-creative-ids" => {
                    call = call.add_companion_creative_ids(        value.map(|v| arg_from_str(v, err, "companion-creative-ids", "int64")).unwrap_or(-0));
                },
                "campaign-id" => {
                    call = call.campaign_id(        value.map(|v| arg_from_str(v, err, "campaign-id", "int64")).unwrap_or(-0));
                },
                "archived" => {
                    call = call.archived(        value.map(|v| arg_from_str(v, err, "archived", "boolean")).unwrap_or(false));
                },
                "advertiser-id" => {
                    call = call.advertiser_id(        value.map(|v| arg_from_str(v, err, "advertiser-id", "int64")).unwrap_or(-0));
                },
                "active" => {
                    call = call.active(        value.map(|v| arg_from_str(v, err, "active", "boolean")).unwrap_or(false));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["active", "advertiser-id", "archived", "campaign-id", "companion-creative-ids", "creative-field-ids", "ids", "max-results", "page-token", "rendering-ids", "search-string", "size-ids", "sort-field", "sort-order", "studio-creative-id", "types"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creatives_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ad-parameters" => Some(("adParameters", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-tag-keys" => Some(("adTagKeys", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "allow-script-access" => Some(("allowScriptAccess", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "artwork-type" => Some(("artworkType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "authoring-source" => Some(("authoringSource", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "authoring-tool" => Some(("authoringTool", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "auto-advance-images" => Some(("autoAdvanceImages", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "background-color" => Some(("backgroundColor", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "backup-image-click-through-url" => Some(("backupImageClickThroughUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "backup-image-features" => Some(("backupImageFeatures", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "backup-image-reporting-label" => Some(("backupImageReportingLabel", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "backup-image-target-window.custom-html" => Some(("backupImageTargetWindow.customHtml", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "backup-image-target-window.target-window-option" => Some(("backupImageTargetWindow.targetWindowOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "commercial-id" => Some(("commercialId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "companion-creatives" => Some(("companionCreatives", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "compatibility" => Some(("compatibility", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "convert-flash-to-html5" => Some(("convertFlashToHtml5", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "creative-asset-selection.default-asset-id" => Some(("creativeAssetSelection.defaultAssetId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "custom-key-values" => Some(("customKeyValues", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "dynamic-asset-selection" => Some(("dynamicAssetSelection", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "fs-command.left" => Some(("fsCommand.left", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "fs-command.position-option" => Some(("fsCommand.positionOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "fs-command.top" => Some(("fsCommand.top", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "fs-command.window-height" => Some(("fsCommand.windowHeight", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "fs-command.window-width" => Some(("fsCommand.windowWidth", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "html-code" => Some(("htmlCode", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "html-code-locked" => Some(("htmlCodeLocked", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "latest-trafficked-creative-id" => Some(("latestTraffickedCreativeId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "override-css" => Some(("overrideCss", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "progress-offset.offset-percentage" => Some(("progressOffset.offsetPercentage", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "progress-offset.offset-seconds" => Some(("progressOffset.offsetSeconds", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "redirect-url" => Some(("redirectUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id" => Some(("renderingId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.dimension-name" => Some(("renderingIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.etag" => Some(("renderingIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.id" => Some(("renderingIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.kind" => Some(("renderingIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.match-type" => Some(("renderingIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.value" => Some(("renderingIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "required-flash-plugin-version" => Some(("requiredFlashPluginVersion", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "required-flash-version" => Some(("requiredFlashVersion", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "size.height" => Some(("size.height", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "size.iab" => Some(("size.iab", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "size.id" => Some(("size.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.kind" => Some(("size.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.width" => Some(("size.width", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "skip-offset.offset-percentage" => Some(("skipOffset.offsetPercentage", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "skip-offset.offset-seconds" => Some(("skipOffset.offsetSeconds", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "skippable" => Some(("skippable", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-compliant" => Some(("sslCompliant", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-override" => Some(("sslOverride", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "studio-advertiser-id" => Some(("studioAdvertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "studio-creative-id" => Some(("studioCreativeId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "studio-trafficked-creative-id" => Some(("studioTraffickedCreativeId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "third-party-backup-image-impressions-url" => Some(("thirdPartyBackupImageImpressionsUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "third-party-rich-media-impressions-url" => Some(("thirdPartyRichMediaImpressionsUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "total-file-size" => Some(("totalFileSize", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "universal-ad-id.registry" => Some(("universalAdId.registry", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "universal-ad-id.value" => Some(("universalAdId.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "version" => Some(("version", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-description" => Some(("videoDescription", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-duration" => Some(("videoDuration", JsonTypeInfo { jtype: JsonType::Float, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "ad-parameters", "ad-tag-keys", "advertiser-id", "allow-script-access", "archived", "artwork-type", "authoring-source", "authoring-tool", "auto-advance-images", "background-color", "backup-image-click-through-url", "backup-image-features", "backup-image-reporting-label", "backup-image-target-window", "commercial-id", "companion-creatives", "compatibility", "convert-flash-to-html5", "creative-asset-selection", "custom-html", "custom-key-values", "default-asset-id", "dimension-name", "dynamic-asset-selection", "etag", "fs-command", "height", "html-code", "html-code-locked", "iab", "id", "id-dimension-value", "kind", "last-modified-info", "latest-trafficked-creative-id", "left", "match-type", "name", "offset-percentage", "offset-seconds", "override-css", "position-option", "progress-offset", "redirect-url", "registry", "rendering-id", "rendering-id-dimension-value", "required-flash-plugin-version", "required-flash-version", "size", "skip-offset", "skippable", "ssl-compliant", "ssl-override", "studio-advertiser-id", "studio-creative-id", "studio-trafficked-creative-id", "subaccount-id", "target-window-option", "third-party-backup-image-impressions-url", "third-party-rich-media-impressions-url", "time", "top", "total-file-size", "type", "universal-ad-id", "value", "version", "video-description", "video-duration", "width", "window-height", "window-width"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Creative = json::value::from_value(object).unwrap();
        let mut call = self.hub.creatives().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _creatives_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ad-parameters" => Some(("adParameters", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-tag-keys" => Some(("adTagKeys", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "allow-script-access" => Some(("allowScriptAccess", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "artwork-type" => Some(("artworkType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "authoring-source" => Some(("authoringSource", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "authoring-tool" => Some(("authoringTool", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "auto-advance-images" => Some(("autoAdvanceImages", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "background-color" => Some(("backgroundColor", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "backup-image-click-through-url" => Some(("backupImageClickThroughUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "backup-image-features" => Some(("backupImageFeatures", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "backup-image-reporting-label" => Some(("backupImageReportingLabel", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "backup-image-target-window.custom-html" => Some(("backupImageTargetWindow.customHtml", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "backup-image-target-window.target-window-option" => Some(("backupImageTargetWindow.targetWindowOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "commercial-id" => Some(("commercialId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "companion-creatives" => Some(("companionCreatives", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "compatibility" => Some(("compatibility", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "convert-flash-to-html5" => Some(("convertFlashToHtml5", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "creative-asset-selection.default-asset-id" => Some(("creativeAssetSelection.defaultAssetId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "custom-key-values" => Some(("customKeyValues", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "dynamic-asset-selection" => Some(("dynamicAssetSelection", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "fs-command.left" => Some(("fsCommand.left", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "fs-command.position-option" => Some(("fsCommand.positionOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "fs-command.top" => Some(("fsCommand.top", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "fs-command.window-height" => Some(("fsCommand.windowHeight", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "fs-command.window-width" => Some(("fsCommand.windowWidth", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "html-code" => Some(("htmlCode", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "html-code-locked" => Some(("htmlCodeLocked", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "latest-trafficked-creative-id" => Some(("latestTraffickedCreativeId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "override-css" => Some(("overrideCss", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "progress-offset.offset-percentage" => Some(("progressOffset.offsetPercentage", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "progress-offset.offset-seconds" => Some(("progressOffset.offsetSeconds", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "redirect-url" => Some(("redirectUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id" => Some(("renderingId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.dimension-name" => Some(("renderingIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.etag" => Some(("renderingIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.id" => Some(("renderingIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.kind" => Some(("renderingIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.match-type" => Some(("renderingIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "rendering-id-dimension-value.value" => Some(("renderingIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "required-flash-plugin-version" => Some(("requiredFlashPluginVersion", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "required-flash-version" => Some(("requiredFlashVersion", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "size.height" => Some(("size.height", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "size.iab" => Some(("size.iab", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "size.id" => Some(("size.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.kind" => Some(("size.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.width" => Some(("size.width", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "skip-offset.offset-percentage" => Some(("skipOffset.offsetPercentage", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "skip-offset.offset-seconds" => Some(("skipOffset.offsetSeconds", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "skippable" => Some(("skippable", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-compliant" => Some(("sslCompliant", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-override" => Some(("sslOverride", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "studio-advertiser-id" => Some(("studioAdvertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "studio-creative-id" => Some(("studioCreativeId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "studio-trafficked-creative-id" => Some(("studioTraffickedCreativeId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "third-party-backup-image-impressions-url" => Some(("thirdPartyBackupImageImpressionsUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "third-party-rich-media-impressions-url" => Some(("thirdPartyRichMediaImpressionsUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "total-file-size" => Some(("totalFileSize", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "universal-ad-id.registry" => Some(("universalAdId.registry", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "universal-ad-id.value" => Some(("universalAdId.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "version" => Some(("version", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-description" => Some(("videoDescription", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-duration" => Some(("videoDuration", JsonTypeInfo { jtype: JsonType::Float, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "ad-parameters", "ad-tag-keys", "advertiser-id", "allow-script-access", "archived", "artwork-type", "authoring-source", "authoring-tool", "auto-advance-images", "background-color", "backup-image-click-through-url", "backup-image-features", "backup-image-reporting-label", "backup-image-target-window", "commercial-id", "companion-creatives", "compatibility", "convert-flash-to-html5", "creative-asset-selection", "custom-html", "custom-key-values", "default-asset-id", "dimension-name", "dynamic-asset-selection", "etag", "fs-command", "height", "html-code", "html-code-locked", "iab", "id", "id-dimension-value", "kind", "last-modified-info", "latest-trafficked-creative-id", "left", "match-type", "name", "offset-percentage", "offset-seconds", "override-css", "position-option", "progress-offset", "redirect-url", "registry", "rendering-id", "rendering-id-dimension-value", "required-flash-plugin-version", "required-flash-version", "size", "skip-offset", "skippable", "ssl-compliant", "ssl-override", "studio-advertiser-id", "studio-creative-id", "studio-trafficked-creative-id", "subaccount-id", "target-window-option", "third-party-backup-image-impressions-url", "third-party-rich-media-impressions-url", "time", "top", "total-file-size", "type", "universal-ad-id", "value", "version", "video-description", "video-duration", "width", "window-height", "window-width"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Creative = json::value::from_value(object).unwrap();
        let mut call = self.hub.creatives().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _dimension_values_query(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "dimension-name" => Some(("dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "end-date" => Some(("endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "start-date" => Some(("startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["dimension-name", "end-date", "kind", "start-date"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::DimensionValueRequest = json::value::from_value(object).unwrap();
        let mut call = self.hub.dimension_values().query(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["max-results", "page-token"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _directory_site_contacts_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.directory_site_contacts().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _directory_site_contacts_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.directory_site_contacts().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "directory-site-ids" => {
                    call = call.add_directory_site_ids(        value.map(|v| arg_from_str(v, err, "directory-site-ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["directory-site-ids", "ids", "max-results", "page-token", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _directory_sites_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.directory_sites().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _directory_sites_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "country-id" => Some(("countryId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "currency-id" => Some(("currencyId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "description" => Some(("description", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "inpage-tag-formats" => Some(("inpageTagFormats", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "interstitial-tag-formats" => Some(("interstitialTagFormats", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "parent-id" => Some(("parentId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "settings.active-view-opt-out" => Some(("settings.activeViewOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "settings.dfp-settings.dfp-network-code" => Some(("settings.dfpSettings.dfpNetworkCode", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "settings.dfp-settings.dfp-network-name" => Some(("settings.dfpSettings.dfpNetworkName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "settings.dfp-settings.programmatic-placement-accepted" => Some(("settings.dfpSettings.programmaticPlacementAccepted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "settings.dfp-settings.pub-paid-placement-accepted" => Some(("settings.dfpSettings.pubPaidPlacementAccepted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "settings.dfp-settings.publisher-portal-only" => Some(("settings.dfpSettings.publisherPortalOnly", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "settings.instream-video-placement-accepted" => Some(("settings.instreamVideoPlacementAccepted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "settings.interstitial-placement-accepted" => Some(("settings.interstitialPlacementAccepted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "settings.nielsen-ocr-opt-out" => Some(("settings.nielsenOcrOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "settings.verification-tag-opt-out" => Some(("settings.verificationTagOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "settings.video-active-view-opt-out" => Some(("settings.videoActiveViewOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "url" => Some(("url", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["active", "active-view-opt-out", "country-id", "currency-id", "description", "dfp-network-code", "dfp-network-name", "dfp-settings", "dimension-name", "etag", "id", "id-dimension-value", "inpage-tag-formats", "instream-video-placement-accepted", "interstitial-placement-accepted", "interstitial-tag-formats", "kind", "match-type", "name", "nielsen-ocr-opt-out", "parent-id", "programmatic-placement-accepted", "pub-paid-placement-accepted", "publisher-portal-only", "settings", "url", "value", "verification-tag-opt-out", "video-active-view-opt-out"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::DirectorySite = json::value::from_value(object).unwrap();
        let mut call = self.hub.directory_sites().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _directory_sites_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.directory_sites().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "parent-id" => {
                    call = call.parent_id(        value.map(|v| arg_from_str(v, err, "parent-id", "int64")).unwrap_or(-0));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "dfp-network-code" => {
                    call = call.dfp_network_code(value.unwrap_or(""));
                },
                "country-id" => {
                    call = call.country_id(        value.map(|v| arg_from_str(v, err, "country-id", "int64")).unwrap_or(-0));
                },
                "active" => {
                    call = call.active(        value.map(|v| arg_from_str(v, err, "active", "boolean")).unwrap_or(false));
                },
                "accepts-publisher-paid-placements" => {
                    call = call.accepts_publisher_paid_placements(        value.map(|v| arg_from_str(v, err, "accepts-publisher-paid-placements", "boolean")).unwrap_or(false));
                },
                "accepts-interstitial-placements" => {
                    call = call.accepts_interstitial_placements(        value.map(|v| arg_from_str(v, err, "accepts-interstitial-placements", "boolean")).unwrap_or(false));
                },
                "accepts-in-stream-video-placements" => {
                    call = call.accepts_in_stream_video_placements(        value.map(|v| arg_from_str(v, err, "accepts-in-stream-video-placements", "boolean")).unwrap_or(false));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["accepts-in-stream-video-placements", "accepts-interstitial-placements", "accepts-publisher-paid-placements", "active", "country-id", "dfp-network-code", "ids", "max-results", "page-token", "parent-id", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _dynamic_targeting_keys_delete(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.dynamic_targeting_keys().delete(opt.value_of("profile-id").unwrap_or(""), opt.value_of("object-id").unwrap_or(""), opt.value_of("name").unwrap_or(""), opt.value_of("object-type").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok(mut response) => {
                    Ok(())
                }
            }
        }
    }

    async fn _dynamic_targeting_keys_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "object-id" => Some(("objectId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "object-type" => Some(("objectType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["kind", "name", "object-id", "object-type"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::DynamicTargetingKey = json::value::from_value(object).unwrap();
        let mut call = self.hub.dynamic_targeting_keys().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _dynamic_targeting_keys_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.dynamic_targeting_keys().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "object-type" => {
                    call = call.object_type(value.unwrap_or(""));
                },
                "object-id" => {
                    call = call.object_id(        value.map(|v| arg_from_str(v, err, "object-id", "int64")).unwrap_or(-0));
                },
                "names" => {
                    call = call.add_names(value.unwrap_or(""));
                },
                "advertiser-id" => {
                    call = call.advertiser_id(        value.map(|v| arg_from_str(v, err, "advertiser-id", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["advertiser-id", "names", "object-id", "object-type"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _event_tags_delete(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.event_tags().delete(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok(mut response) => {
                    Ok(())
                }
            }
        }
    }

    async fn _event_tags_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.event_tags().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _event_tags_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id" => Some(("campaignId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.dimension-name" => Some(("campaignIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.etag" => Some(("campaignIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.id" => Some(("campaignIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.kind" => Some(("campaignIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.match-type" => Some(("campaignIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.value" => Some(("campaignIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "enabled-by-default" => Some(("enabledByDefault", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "exclude-from-adx-requests" => Some(("excludeFromAdxRequests", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-filter-type" => Some(("siteFilterType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-ids" => Some(("siteIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "ssl-compliant" => Some(("sslCompliant", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "status" => Some(("status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "url" => Some(("url", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "url-escape-levels" => Some(("urlEscapeLevels", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "campaign-id", "campaign-id-dimension-value", "dimension-name", "enabled-by-default", "etag", "exclude-from-adx-requests", "id", "kind", "match-type", "name", "site-filter-type", "site-ids", "ssl-compliant", "status", "subaccount-id", "type", "url", "url-escape-levels", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::EventTag = json::value::from_value(object).unwrap();
        let mut call = self.hub.event_tags().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _event_tags_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.event_tags().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "event-tag-types" => {
                    call = call.add_event_tag_types(value.unwrap_or(""));
                },
                "enabled" => {
                    call = call.enabled(        value.map(|v| arg_from_str(v, err, "enabled", "boolean")).unwrap_or(false));
                },
                "definitions-only" => {
                    call = call.definitions_only(        value.map(|v| arg_from_str(v, err, "definitions-only", "boolean")).unwrap_or(false));
                },
                "campaign-id" => {
                    call = call.campaign_id(        value.map(|v| arg_from_str(v, err, "campaign-id", "int64")).unwrap_or(-0));
                },
                "advertiser-id" => {
                    call = call.advertiser_id(        value.map(|v| arg_from_str(v, err, "advertiser-id", "int64")).unwrap_or(-0));
                },
                "ad-id" => {
                    call = call.ad_id(        value.map(|v| arg_from_str(v, err, "ad-id", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["ad-id", "advertiser-id", "campaign-id", "definitions-only", "enabled", "event-tag-types", "ids", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _event_tags_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id" => Some(("campaignId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.dimension-name" => Some(("campaignIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.etag" => Some(("campaignIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.id" => Some(("campaignIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.kind" => Some(("campaignIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.match-type" => Some(("campaignIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.value" => Some(("campaignIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "enabled-by-default" => Some(("enabledByDefault", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "exclude-from-adx-requests" => Some(("excludeFromAdxRequests", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-filter-type" => Some(("siteFilterType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-ids" => Some(("siteIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "ssl-compliant" => Some(("sslCompliant", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "status" => Some(("status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "url" => Some(("url", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "url-escape-levels" => Some(("urlEscapeLevels", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "campaign-id", "campaign-id-dimension-value", "dimension-name", "enabled-by-default", "etag", "exclude-from-adx-requests", "id", "kind", "match-type", "name", "site-filter-type", "site-ids", "ssl-compliant", "status", "subaccount-id", "type", "url", "url-escape-levels", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::EventTag = json::value::from_value(object).unwrap();
        let mut call = self.hub.event_tags().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _event_tags_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id" => Some(("campaignId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.dimension-name" => Some(("campaignIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.etag" => Some(("campaignIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.id" => Some(("campaignIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.kind" => Some(("campaignIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.match-type" => Some(("campaignIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.value" => Some(("campaignIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "enabled-by-default" => Some(("enabledByDefault", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "exclude-from-adx-requests" => Some(("excludeFromAdxRequests", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-filter-type" => Some(("siteFilterType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-ids" => Some(("siteIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "ssl-compliant" => Some(("sslCompliant", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "status" => Some(("status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "url" => Some(("url", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "url-escape-levels" => Some(("urlEscapeLevels", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "campaign-id", "campaign-id-dimension-value", "dimension-name", "enabled-by-default", "etag", "exclude-from-adx-requests", "id", "kind", "match-type", "name", "site-filter-type", "site-ids", "ssl-compliant", "status", "subaccount-id", "type", "url", "url-escape-levels", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::EventTag = json::value::from_value(object).unwrap();
        let mut call = self.hub.event_tags().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _files_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut download_mode = false;
        let mut call = self.hub.files().get(opt.value_of("report-id").unwrap_or(""), opt.value_of("file-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            if key == "alt" && value.unwrap_or("unset") == "media" {
                                download_mode = true;
                            }
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    if !download_mode {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    } else {
                    let bytes = hyper::body::to_bytes(response.into_body()).await.expect("a string as API currently is inefficient").to_vec();
                    ostream.write_all(&bytes).expect("write to be complete");
                    ostream.flush().expect("io to never fail which should really be fixed one day");
                    }
                    Ok(())
                }
            }
        }
    }

    async fn _files_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.files().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "scope" => {
                    call = call.scope(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["max-results", "page-token", "scope", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_activities_delete(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.floodlight_activities().delete(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok(mut response) => {
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_activities_generatetag(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.floodlight_activities().generatetag(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "floodlight-activity-id" => {
                    call = call.floodlight_activity_id(        value.map(|v| arg_from_str(v, err, "floodlight-activity-id", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["floodlight-activity-id"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_activities_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.floodlight_activities().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_activities_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cache-busting-type" => Some(("cacheBustingType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "counting-method" => Some(("countingMethod", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "expected-url" => Some(("expectedUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-activity-group-id" => Some(("floodlightActivityGroupId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-activity-group-name" => Some(("floodlightActivityGroupName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-activity-group-tag-string" => Some(("floodlightActivityGroupTagString", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-activity-group-type" => Some(("floodlightActivityGroupType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id" => Some(("floodlightConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.dimension-name" => Some(("floodlightConfigurationIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.etag" => Some(("floodlightConfigurationIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.id" => Some(("floodlightConfigurationIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.kind" => Some(("floodlightConfigurationIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.match-type" => Some(("floodlightConfigurationIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.value" => Some(("floodlightConfigurationIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "hidden" => Some(("hidden", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "image-tag-enabled" => Some(("imageTagEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "notes" => Some(("notes", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "secure" => Some(("secure", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-compliant" => Some(("sslCompliant", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-required" => Some(("sslRequired", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-format" => Some(("tagFormat", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-string" => Some(("tagString", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-defined-variable-types" => Some(("userDefinedVariableTypes", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "cache-busting-type", "counting-method", "dimension-name", "etag", "expected-url", "floodlight-activity-group-id", "floodlight-activity-group-name", "floodlight-activity-group-tag-string", "floodlight-activity-group-type", "floodlight-configuration-id", "floodlight-configuration-id-dimension-value", "hidden", "id", "id-dimension-value", "image-tag-enabled", "kind", "match-type", "name", "notes", "secure", "ssl-compliant", "ssl-required", "subaccount-id", "tag-format", "tag-string", "user-defined-variable-types", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::FloodlightActivity = json::value::from_value(object).unwrap();
        let mut call = self.hub.floodlight_activities().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_activities_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.floodlight_activities().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "tag-string" => {
                    call = call.tag_string(value.unwrap_or(""));
                },
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "floodlight-configuration-id" => {
                    call = call.floodlight_configuration_id(        value.map(|v| arg_from_str(v, err, "floodlight-configuration-id", "int64")).unwrap_or(-0));
                },
                "floodlight-activity-group-type" => {
                    call = call.floodlight_activity_group_type(value.unwrap_or(""));
                },
                "floodlight-activity-group-tag-string" => {
                    call = call.floodlight_activity_group_tag_string(value.unwrap_or(""));
                },
                "floodlight-activity-group-name" => {
                    call = call.floodlight_activity_group_name(value.unwrap_or(""));
                },
                "floodlight-activity-group-ids" => {
                    call = call.add_floodlight_activity_group_ids(        value.map(|v| arg_from_str(v, err, "floodlight-activity-group-ids", "int64")).unwrap_or(-0));
                },
                "advertiser-id" => {
                    call = call.advertiser_id(        value.map(|v| arg_from_str(v, err, "advertiser-id", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["advertiser-id", "floodlight-activity-group-ids", "floodlight-activity-group-name", "floodlight-activity-group-tag-string", "floodlight-activity-group-type", "floodlight-configuration-id", "ids", "max-results", "page-token", "search-string", "sort-field", "sort-order", "tag-string"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_activities_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cache-busting-type" => Some(("cacheBustingType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "counting-method" => Some(("countingMethod", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "expected-url" => Some(("expectedUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-activity-group-id" => Some(("floodlightActivityGroupId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-activity-group-name" => Some(("floodlightActivityGroupName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-activity-group-tag-string" => Some(("floodlightActivityGroupTagString", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-activity-group-type" => Some(("floodlightActivityGroupType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id" => Some(("floodlightConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.dimension-name" => Some(("floodlightConfigurationIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.etag" => Some(("floodlightConfigurationIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.id" => Some(("floodlightConfigurationIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.kind" => Some(("floodlightConfigurationIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.match-type" => Some(("floodlightConfigurationIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.value" => Some(("floodlightConfigurationIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "hidden" => Some(("hidden", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "image-tag-enabled" => Some(("imageTagEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "notes" => Some(("notes", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "secure" => Some(("secure", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-compliant" => Some(("sslCompliant", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-required" => Some(("sslRequired", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-format" => Some(("tagFormat", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-string" => Some(("tagString", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-defined-variable-types" => Some(("userDefinedVariableTypes", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "cache-busting-type", "counting-method", "dimension-name", "etag", "expected-url", "floodlight-activity-group-id", "floodlight-activity-group-name", "floodlight-activity-group-tag-string", "floodlight-activity-group-type", "floodlight-configuration-id", "floodlight-configuration-id-dimension-value", "hidden", "id", "id-dimension-value", "image-tag-enabled", "kind", "match-type", "name", "notes", "secure", "ssl-compliant", "ssl-required", "subaccount-id", "tag-format", "tag-string", "user-defined-variable-types", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::FloodlightActivity = json::value::from_value(object).unwrap();
        let mut call = self.hub.floodlight_activities().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_activities_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cache-busting-type" => Some(("cacheBustingType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "counting-method" => Some(("countingMethod", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "expected-url" => Some(("expectedUrl", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-activity-group-id" => Some(("floodlightActivityGroupId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-activity-group-name" => Some(("floodlightActivityGroupName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-activity-group-tag-string" => Some(("floodlightActivityGroupTagString", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-activity-group-type" => Some(("floodlightActivityGroupType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id" => Some(("floodlightConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.dimension-name" => Some(("floodlightConfigurationIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.etag" => Some(("floodlightConfigurationIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.id" => Some(("floodlightConfigurationIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.kind" => Some(("floodlightConfigurationIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.match-type" => Some(("floodlightConfigurationIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.value" => Some(("floodlightConfigurationIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "hidden" => Some(("hidden", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "image-tag-enabled" => Some(("imageTagEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "notes" => Some(("notes", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "secure" => Some(("secure", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-compliant" => Some(("sslCompliant", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "ssl-required" => Some(("sslRequired", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-format" => Some(("tagFormat", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-string" => Some(("tagString", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "user-defined-variable-types" => Some(("userDefinedVariableTypes", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "cache-busting-type", "counting-method", "dimension-name", "etag", "expected-url", "floodlight-activity-group-id", "floodlight-activity-group-name", "floodlight-activity-group-tag-string", "floodlight-activity-group-type", "floodlight-configuration-id", "floodlight-configuration-id-dimension-value", "hidden", "id", "id-dimension-value", "image-tag-enabled", "kind", "match-type", "name", "notes", "secure", "ssl-compliant", "ssl-required", "subaccount-id", "tag-format", "tag-string", "user-defined-variable-types", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::FloodlightActivity = json::value::from_value(object).unwrap();
        let mut call = self.hub.floodlight_activities().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_activity_groups_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.floodlight_activity_groups().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_activity_groups_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id" => Some(("floodlightConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.dimension-name" => Some(("floodlightConfigurationIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.etag" => Some(("floodlightConfigurationIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.id" => Some(("floodlightConfigurationIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.kind" => Some(("floodlightConfigurationIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.match-type" => Some(("floodlightConfigurationIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.value" => Some(("floodlightConfigurationIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-string" => Some(("tagString", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "dimension-name", "etag", "floodlight-configuration-id", "floodlight-configuration-id-dimension-value", "id", "id-dimension-value", "kind", "match-type", "name", "subaccount-id", "tag-string", "type", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::FloodlightActivityGroup = json::value::from_value(object).unwrap();
        let mut call = self.hub.floodlight_activity_groups().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_activity_groups_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.floodlight_activity_groups().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "type" => {
                    call = call.type_(value.unwrap_or(""));
                },
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "floodlight-configuration-id" => {
                    call = call.floodlight_configuration_id(        value.map(|v| arg_from_str(v, err, "floodlight-configuration-id", "int64")).unwrap_or(-0));
                },
                "advertiser-id" => {
                    call = call.advertiser_id(        value.map(|v| arg_from_str(v, err, "advertiser-id", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["advertiser-id", "floodlight-configuration-id", "ids", "max-results", "page-token", "search-string", "sort-field", "sort-order", "type"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_activity_groups_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id" => Some(("floodlightConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.dimension-name" => Some(("floodlightConfigurationIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.etag" => Some(("floodlightConfigurationIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.id" => Some(("floodlightConfigurationIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.kind" => Some(("floodlightConfigurationIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.match-type" => Some(("floodlightConfigurationIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.value" => Some(("floodlightConfigurationIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-string" => Some(("tagString", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "dimension-name", "etag", "floodlight-configuration-id", "floodlight-configuration-id-dimension-value", "id", "id-dimension-value", "kind", "match-type", "name", "subaccount-id", "tag-string", "type", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::FloodlightActivityGroup = json::value::from_value(object).unwrap();
        let mut call = self.hub.floodlight_activity_groups().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_activity_groups_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id" => Some(("floodlightConfigurationId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.dimension-name" => Some(("floodlightConfigurationIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.etag" => Some(("floodlightConfigurationIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.id" => Some(("floodlightConfigurationIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.kind" => Some(("floodlightConfigurationIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.match-type" => Some(("floodlightConfigurationIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-configuration-id-dimension-value.value" => Some(("floodlightConfigurationIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-string" => Some(("tagString", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "dimension-name", "etag", "floodlight-configuration-id", "floodlight-configuration-id-dimension-value", "id", "id-dimension-value", "kind", "match-type", "name", "subaccount-id", "tag-string", "type", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::FloodlightActivityGroup = json::value::from_value(object).unwrap();
        let mut call = self.hub.floodlight_activity_groups().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_configurations_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.floodlight_configurations().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_configurations_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.floodlight_configurations().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["ids"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_configurations_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "analytics-data-sharing-enabled" => Some(("analyticsDataSharingEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "exposure-to-conversion-enabled" => Some(("exposureToConversionEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "first-day-of-week" => Some(("firstDayOfWeek", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "in-app-attribution-tracking-enabled" => Some(("inAppAttributionTrackingEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "lookback-configuration.click-duration" => Some(("lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "lookback-configuration.post-impression-activities-duration" => Some(("lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "natural-search-conversion-attribution-option" => Some(("naturalSearchConversionAttributionOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "omniture-settings.omniture-cost-data-enabled" => Some(("omnitureSettings.omnitureCostDataEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "omniture-settings.omniture-integration-enabled" => Some(("omnitureSettings.omnitureIntegrationEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-settings.dynamic-tag-enabled" => Some(("tagSettings.dynamicTagEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "tag-settings.image-tag-enabled" => Some(("tagSettings.imageTagEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "analytics-data-sharing-enabled", "click-duration", "dimension-name", "dynamic-tag-enabled", "etag", "exposure-to-conversion-enabled", "first-day-of-week", "id", "id-dimension-value", "image-tag-enabled", "in-app-attribution-tracking-enabled", "kind", "lookback-configuration", "match-type", "natural-search-conversion-attribution-option", "omniture-cost-data-enabled", "omniture-integration-enabled", "omniture-settings", "post-impression-activities-duration", "subaccount-id", "tag-settings", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::FloodlightConfiguration = json::value::from_value(object).unwrap();
        let mut call = self.hub.floodlight_configurations().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _floodlight_configurations_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "analytics-data-sharing-enabled" => Some(("analyticsDataSharingEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "exposure-to-conversion-enabled" => Some(("exposureToConversionEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "first-day-of-week" => Some(("firstDayOfWeek", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "in-app-attribution-tracking-enabled" => Some(("inAppAttributionTrackingEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "lookback-configuration.click-duration" => Some(("lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "lookback-configuration.post-impression-activities-duration" => Some(("lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "natural-search-conversion-attribution-option" => Some(("naturalSearchConversionAttributionOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "omniture-settings.omniture-cost-data-enabled" => Some(("omnitureSettings.omnitureCostDataEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "omniture-settings.omniture-integration-enabled" => Some(("omnitureSettings.omnitureIntegrationEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-settings.dynamic-tag-enabled" => Some(("tagSettings.dynamicTagEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "tag-settings.image-tag-enabled" => Some(("tagSettings.imageTagEnabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "analytics-data-sharing-enabled", "click-duration", "dimension-name", "dynamic-tag-enabled", "etag", "exposure-to-conversion-enabled", "first-day-of-week", "id", "id-dimension-value", "image-tag-enabled", "in-app-attribution-tracking-enabled", "kind", "lookback-configuration", "match-type", "natural-search-conversion-attribution-option", "omniture-cost-data-enabled", "omniture-integration-enabled", "omniture-settings", "post-impression-activities-duration", "subaccount-id", "tag-settings", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::FloodlightConfiguration = json::value::from_value(object).unwrap();
        let mut call = self.hub.floodlight_configurations().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _inventory_items_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.inventory_items().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("project-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _inventory_items_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.inventory_items().list(opt.value_of("profile-id").unwrap_or(""), opt.value_of("project-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "type" => {
                    call = call.type_(value.unwrap_or(""));
                },
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "site-id" => {
                    call = call.add_site_id(        value.map(|v| arg_from_str(v, err, "site-id", "int64")).unwrap_or(-0));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "order-id" => {
                    call = call.add_order_id(        value.map(|v| arg_from_str(v, err, "order-id", "int64")).unwrap_or(-0));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "in-plan" => {
                    call = call.in_plan(        value.map(|v| arg_from_str(v, err, "in-plan", "boolean")).unwrap_or(false));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["ids", "in-plan", "max-results", "order-id", "page-token", "site-id", "sort-field", "sort-order", "type"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _landing_pages_delete(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.landing_pages().delete(opt.value_of("profile-id").unwrap_or(""), opt.value_of("campaign-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok(mut response) => {
                    Ok(())
                }
            }
        }
    }

    async fn _landing_pages_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.landing_pages().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("campaign-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _landing_pages_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "default" => Some(("default", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "url" => Some(("url", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["default", "id", "kind", "name", "url"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::LandingPage = json::value::from_value(object).unwrap();
        let mut call = self.hub.landing_pages().insert(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("campaign-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _landing_pages_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.landing_pages().list(opt.value_of("profile-id").unwrap_or(""), opt.value_of("campaign-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _landing_pages_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "default" => Some(("default", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "url" => Some(("url", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["default", "id", "kind", "name", "url"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::LandingPage = json::value::from_value(object).unwrap();
        let mut call = self.hub.landing_pages().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("campaign-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _landing_pages_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "default" => Some(("default", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "url" => Some(("url", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["default", "id", "kind", "name", "url"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::LandingPage = json::value::from_value(object).unwrap();
        let mut call = self.hub.landing_pages().update(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("campaign-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _languages_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.languages().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _metros_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.metros().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _mobile_carriers_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.mobile_carriers().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _mobile_carriers_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.mobile_carriers().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _operating_system_versions_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.operating_system_versions().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _operating_system_versions_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.operating_system_versions().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _operating_systems_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.operating_systems().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("dart-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _operating_systems_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.operating_systems().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _order_documents_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.order_documents().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("project-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _order_documents_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.order_documents().list(opt.value_of("profile-id").unwrap_or(""), opt.value_of("project-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "site-id" => {
                    call = call.add_site_id(        value.map(|v| arg_from_str(v, err, "site-id", "int64")).unwrap_or(-0));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "order-id" => {
                    call = call.add_order_id(        value.map(|v| arg_from_str(v, err, "order-id", "int64")).unwrap_or(-0));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "approved" => {
                    call = call.approved(        value.map(|v| arg_from_str(v, err, "approved", "boolean")).unwrap_or(false));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["approved", "ids", "max-results", "order-id", "page-token", "search-string", "site-id", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _orders_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.orders().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("project-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _orders_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.orders().list(opt.value_of("profile-id").unwrap_or(""), opt.value_of("project-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "site-id" => {
                    call = call.add_site_id(        value.map(|v| arg_from_str(v, err, "site-id", "int64")).unwrap_or(-0));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["ids", "max-results", "page-token", "search-string", "site-id", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placement_groups_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.placement_groups().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placement_groups_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "campaign-id" => Some(("campaignId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.dimension-name" => Some(("campaignIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.etag" => Some(("campaignIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.id" => Some(("campaignIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.kind" => Some(("campaignIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.match-type" => Some(("campaignIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.value" => Some(("campaignIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "child-placement-ids" => Some(("childPlacementIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "comment" => Some(("comment", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "content-category-id" => Some(("contentCategoryId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "create-info.time" => Some(("createInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id" => Some(("directorySiteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.dimension-name" => Some(("directorySiteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.etag" => Some(("directorySiteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.id" => Some(("directorySiteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.kind" => Some(("directorySiteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.match-type" => Some(("directorySiteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.value" => Some(("directorySiteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "external-id" => Some(("externalId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-type" => Some(("placementGroupType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-strategy-id" => Some(("placementStrategyId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.cap-cost-option" => Some(("pricingSchedule.capCostOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.disregard-overdelivery" => Some(("pricingSchedule.disregardOverdelivery", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "pricing-schedule.end-date" => Some(("pricingSchedule.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.flighted" => Some(("pricingSchedule.flighted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "pricing-schedule.floodlight-activity-id" => Some(("pricingSchedule.floodlightActivityId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.pricing-type" => Some(("pricingSchedule.pricingType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.start-date" => Some(("pricingSchedule.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.testing-start-date" => Some(("pricingSchedule.testingStartDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id" => Some(("primaryPlacementId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.dimension-name" => Some(("primaryPlacementIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.etag" => Some(("primaryPlacementIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.id" => Some(("primaryPlacementIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.kind" => Some(("primaryPlacementIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.match-type" => Some(("primaryPlacementIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.value" => Some(("primaryPlacementIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id" => Some(("siteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.dimension-name" => Some(("siteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.etag" => Some(("siteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.id" => Some(("siteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.kind" => Some(("siteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.match-type" => Some(("siteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.value" => Some(("siteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "archived", "campaign-id", "campaign-id-dimension-value", "cap-cost-option", "child-placement-ids", "comment", "content-category-id", "create-info", "dimension-name", "directory-site-id", "directory-site-id-dimension-value", "disregard-overdelivery", "end-date", "etag", "external-id", "flighted", "floodlight-activity-id", "id", "id-dimension-value", "kind", "last-modified-info", "match-type", "name", "placement-group-type", "placement-strategy-id", "pricing-schedule", "pricing-type", "primary-placement-id", "primary-placement-id-dimension-value", "site-id", "site-id-dimension-value", "start-date", "subaccount-id", "testing-start-date", "time", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::PlacementGroup = json::value::from_value(object).unwrap();
        let mut call = self.hub.placement_groups().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placement_groups_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.placement_groups().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "site-ids" => {
                    call = call.add_site_ids(        value.map(|v| arg_from_str(v, err, "site-ids", "int64")).unwrap_or(-0));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "pricing-types" => {
                    call = call.add_pricing_types(value.unwrap_or(""));
                },
                "placement-strategy-ids" => {
                    call = call.add_placement_strategy_ids(        value.map(|v| arg_from_str(v, err, "placement-strategy-ids", "int64")).unwrap_or(-0));
                },
                "placement-group-type" => {
                    call = call.placement_group_type(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "min-start-date" => {
                    call = call.min_start_date(value.unwrap_or(""));
                },
                "min-end-date" => {
                    call = call.min_end_date(value.unwrap_or(""));
                },
                "max-start-date" => {
                    call = call.max_start_date(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "max-end-date" => {
                    call = call.max_end_date(value.unwrap_or(""));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "directory-site-ids" => {
                    call = call.add_directory_site_ids(        value.map(|v| arg_from_str(v, err, "directory-site-ids", "int64")).unwrap_or(-0));
                },
                "content-category-ids" => {
                    call = call.add_content_category_ids(        value.map(|v| arg_from_str(v, err, "content-category-ids", "int64")).unwrap_or(-0));
                },
                "campaign-ids" => {
                    call = call.add_campaign_ids(        value.map(|v| arg_from_str(v, err, "campaign-ids", "int64")).unwrap_or(-0));
                },
                "archived" => {
                    call = call.archived(        value.map(|v| arg_from_str(v, err, "archived", "boolean")).unwrap_or(false));
                },
                "advertiser-ids" => {
                    call = call.add_advertiser_ids(        value.map(|v| arg_from_str(v, err, "advertiser-ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["advertiser-ids", "archived", "campaign-ids", "content-category-ids", "directory-site-ids", "ids", "max-end-date", "max-results", "max-start-date", "min-end-date", "min-start-date", "page-token", "placement-group-type", "placement-strategy-ids", "pricing-types", "search-string", "site-ids", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placement_groups_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "campaign-id" => Some(("campaignId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.dimension-name" => Some(("campaignIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.etag" => Some(("campaignIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.id" => Some(("campaignIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.kind" => Some(("campaignIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.match-type" => Some(("campaignIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.value" => Some(("campaignIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "child-placement-ids" => Some(("childPlacementIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "comment" => Some(("comment", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "content-category-id" => Some(("contentCategoryId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "create-info.time" => Some(("createInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id" => Some(("directorySiteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.dimension-name" => Some(("directorySiteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.etag" => Some(("directorySiteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.id" => Some(("directorySiteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.kind" => Some(("directorySiteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.match-type" => Some(("directorySiteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.value" => Some(("directorySiteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "external-id" => Some(("externalId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-type" => Some(("placementGroupType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-strategy-id" => Some(("placementStrategyId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.cap-cost-option" => Some(("pricingSchedule.capCostOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.disregard-overdelivery" => Some(("pricingSchedule.disregardOverdelivery", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "pricing-schedule.end-date" => Some(("pricingSchedule.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.flighted" => Some(("pricingSchedule.flighted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "pricing-schedule.floodlight-activity-id" => Some(("pricingSchedule.floodlightActivityId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.pricing-type" => Some(("pricingSchedule.pricingType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.start-date" => Some(("pricingSchedule.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.testing-start-date" => Some(("pricingSchedule.testingStartDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id" => Some(("primaryPlacementId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.dimension-name" => Some(("primaryPlacementIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.etag" => Some(("primaryPlacementIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.id" => Some(("primaryPlacementIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.kind" => Some(("primaryPlacementIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.match-type" => Some(("primaryPlacementIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.value" => Some(("primaryPlacementIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id" => Some(("siteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.dimension-name" => Some(("siteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.etag" => Some(("siteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.id" => Some(("siteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.kind" => Some(("siteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.match-type" => Some(("siteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.value" => Some(("siteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "archived", "campaign-id", "campaign-id-dimension-value", "cap-cost-option", "child-placement-ids", "comment", "content-category-id", "create-info", "dimension-name", "directory-site-id", "directory-site-id-dimension-value", "disregard-overdelivery", "end-date", "etag", "external-id", "flighted", "floodlight-activity-id", "id", "id-dimension-value", "kind", "last-modified-info", "match-type", "name", "placement-group-type", "placement-strategy-id", "pricing-schedule", "pricing-type", "primary-placement-id", "primary-placement-id-dimension-value", "site-id", "site-id-dimension-value", "start-date", "subaccount-id", "testing-start-date", "time", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::PlacementGroup = json::value::from_value(object).unwrap();
        let mut call = self.hub.placement_groups().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placement_groups_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "campaign-id" => Some(("campaignId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.dimension-name" => Some(("campaignIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.etag" => Some(("campaignIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.id" => Some(("campaignIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.kind" => Some(("campaignIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.match-type" => Some(("campaignIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.value" => Some(("campaignIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "child-placement-ids" => Some(("childPlacementIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "comment" => Some(("comment", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "content-category-id" => Some(("contentCategoryId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "create-info.time" => Some(("createInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id" => Some(("directorySiteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.dimension-name" => Some(("directorySiteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.etag" => Some(("directorySiteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.id" => Some(("directorySiteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.kind" => Some(("directorySiteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.match-type" => Some(("directorySiteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.value" => Some(("directorySiteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "external-id" => Some(("externalId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-type" => Some(("placementGroupType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-strategy-id" => Some(("placementStrategyId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.cap-cost-option" => Some(("pricingSchedule.capCostOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.disregard-overdelivery" => Some(("pricingSchedule.disregardOverdelivery", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "pricing-schedule.end-date" => Some(("pricingSchedule.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.flighted" => Some(("pricingSchedule.flighted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "pricing-schedule.floodlight-activity-id" => Some(("pricingSchedule.floodlightActivityId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.pricing-type" => Some(("pricingSchedule.pricingType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.start-date" => Some(("pricingSchedule.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.testing-start-date" => Some(("pricingSchedule.testingStartDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id" => Some(("primaryPlacementId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.dimension-name" => Some(("primaryPlacementIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.etag" => Some(("primaryPlacementIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.id" => Some(("primaryPlacementIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.kind" => Some(("primaryPlacementIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.match-type" => Some(("primaryPlacementIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary-placement-id-dimension-value.value" => Some(("primaryPlacementIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id" => Some(("siteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.dimension-name" => Some(("siteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.etag" => Some(("siteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.id" => Some(("siteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.kind" => Some(("siteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.match-type" => Some(("siteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.value" => Some(("siteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "archived", "campaign-id", "campaign-id-dimension-value", "cap-cost-option", "child-placement-ids", "comment", "content-category-id", "create-info", "dimension-name", "directory-site-id", "directory-site-id-dimension-value", "disregard-overdelivery", "end-date", "etag", "external-id", "flighted", "floodlight-activity-id", "id", "id-dimension-value", "kind", "last-modified-info", "match-type", "name", "placement-group-type", "placement-strategy-id", "pricing-schedule", "pricing-type", "primary-placement-id", "primary-placement-id-dimension-value", "site-id", "site-id-dimension-value", "start-date", "subaccount-id", "testing-start-date", "time", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::PlacementGroup = json::value::from_value(object).unwrap();
        let mut call = self.hub.placement_groups().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placement_strategies_delete(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.placement_strategies().delete(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok(mut response) => {
                    Ok(())
                }
            }
        }
    }

    async fn _placement_strategies_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.placement_strategies().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placement_strategies_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "id", "kind", "name"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::PlacementStrategy = json::value::from_value(object).unwrap();
        let mut call = self.hub.placement_strategies().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placement_strategies_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.placement_strategies().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["ids", "max-results", "page-token", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placement_strategies_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "id", "kind", "name"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::PlacementStrategy = json::value::from_value(object).unwrap();
        let mut call = self.hub.placement_strategies().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placement_strategies_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "id", "kind", "name"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::PlacementStrategy = json::value::from_value(object).unwrap();
        let mut call = self.hub.placement_strategies().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placements_generatetags(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.placements().generatetags(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "tag-formats" => {
                    call = call.add_tag_formats(value.unwrap_or(""));
                },
                "placement-ids" => {
                    call = call.add_placement_ids(        value.map(|v| arg_from_str(v, err, "placement-ids", "int64")).unwrap_or(-0));
                },
                "campaign-id" => {
                    call = call.campaign_id(        value.map(|v| arg_from_str(v, err, "campaign-id", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["campaign-id", "placement-ids", "tag-formats"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placements_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.placements().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placements_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-blocking-opt-out" => Some(("adBlockingOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "campaign-id" => Some(("campaignId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.dimension-name" => Some(("campaignIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.etag" => Some(("campaignIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.id" => Some(("campaignIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.kind" => Some(("campaignIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.match-type" => Some(("campaignIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.value" => Some(("campaignIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "comment" => Some(("comment", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "compatibility" => Some(("compatibility", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "content-category-id" => Some(("contentCategoryId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "create-info.time" => Some(("createInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id" => Some(("directorySiteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.dimension-name" => Some(("directorySiteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.etag" => Some(("directorySiteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.id" => Some(("directorySiteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.kind" => Some(("directorySiteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.match-type" => Some(("directorySiteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.value" => Some(("directorySiteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "external-id" => Some(("externalId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "key-name" => Some(("keyName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "lookback-configuration.click-duration" => Some(("lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "lookback-configuration.post-impression-activities-duration" => Some(("lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "payment-approved" => Some(("paymentApproved", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "payment-source" => Some(("paymentSource", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id" => Some(("placementGroupId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.dimension-name" => Some(("placementGroupIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.etag" => Some(("placementGroupIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.id" => Some(("placementGroupIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.kind" => Some(("placementGroupIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.match-type" => Some(("placementGroupIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.value" => Some(("placementGroupIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-strategy-id" => Some(("placementStrategyId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.cap-cost-option" => Some(("pricingSchedule.capCostOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.disregard-overdelivery" => Some(("pricingSchedule.disregardOverdelivery", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "pricing-schedule.end-date" => Some(("pricingSchedule.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.flighted" => Some(("pricingSchedule.flighted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "pricing-schedule.floodlight-activity-id" => Some(("pricingSchedule.floodlightActivityId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.pricing-type" => Some(("pricingSchedule.pricingType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.start-date" => Some(("pricingSchedule.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.testing-start-date" => Some(("pricingSchedule.testingStartDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary" => Some(("primary", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "publisher-update-info.time" => Some(("publisherUpdateInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id" => Some(("siteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.dimension-name" => Some(("siteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.etag" => Some(("siteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.id" => Some(("siteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.kind" => Some(("siteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.match-type" => Some(("siteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.value" => Some(("siteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.height" => Some(("size.height", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "size.iab" => Some(("size.iab", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "size.id" => Some(("size.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.kind" => Some(("size.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.width" => Some(("size.width", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "ssl-required" => Some(("sslRequired", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "status" => Some(("status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-formats" => Some(("tagFormats", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "tag-setting.additional-key-values" => Some(("tagSetting.additionalKeyValues", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-setting.include-click-through-urls" => Some(("tagSetting.includeClickThroughUrls", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "tag-setting.include-click-tracking" => Some(("tagSetting.includeClickTracking", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "tag-setting.keyword-option" => Some(("tagSetting.keywordOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-active-view-opt-out" => Some(("videoActiveViewOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "video-settings.companion-settings.companions-disabled" => Some(("videoSettings.companionSettings.companionsDisabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "video-settings.companion-settings.image-only" => Some(("videoSettings.companionSettings.imageOnly", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "video-settings.companion-settings.kind" => Some(("videoSettings.companionSettings.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-settings.kind" => Some(("videoSettings.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.kind" => Some(("videoSettings.skippableSettings.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.progress-offset.offset-percentage" => Some(("videoSettings.skippableSettings.progressOffset.offsetPercentage", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.progress-offset.offset-seconds" => Some(("videoSettings.skippableSettings.progressOffset.offsetSeconds", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.skip-offset.offset-percentage" => Some(("videoSettings.skippableSettings.skipOffset.offsetPercentage", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.skip-offset.offset-seconds" => Some(("videoSettings.skippableSettings.skipOffset.offsetSeconds", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.skippable" => Some(("videoSettings.skippableSettings.skippable", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "video-settings.transcode-settings.enabled-video-formats" => Some(("videoSettings.transcodeSettings.enabledVideoFormats", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Vec })),
                    "video-settings.transcode-settings.kind" => Some(("videoSettings.transcodeSettings.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "vpaid-adapter-choice" => Some(("vpaidAdapterChoice", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "ad-blocking-opt-out", "additional-key-values", "advertiser-id", "advertiser-id-dimension-value", "archived", "campaign-id", "campaign-id-dimension-value", "cap-cost-option", "click-duration", "comment", "companion-settings", "companions-disabled", "compatibility", "content-category-id", "create-info", "dimension-name", "directory-site-id", "directory-site-id-dimension-value", "disregard-overdelivery", "enabled-video-formats", "end-date", "etag", "external-id", "flighted", "floodlight-activity-id", "height", "iab", "id", "id-dimension-value", "image-only", "include-click-through-urls", "include-click-tracking", "key-name", "keyword-option", "kind", "last-modified-info", "lookback-configuration", "match-type", "name", "offset-percentage", "offset-seconds", "payment-approved", "payment-source", "placement-group-id", "placement-group-id-dimension-value", "placement-strategy-id", "post-impression-activities-duration", "pricing-schedule", "pricing-type", "primary", "progress-offset", "publisher-update-info", "site-id", "site-id-dimension-value", "size", "skip-offset", "skippable", "skippable-settings", "ssl-required", "start-date", "status", "subaccount-id", "tag-formats", "tag-setting", "testing-start-date", "time", "transcode-settings", "value", "video-active-view-opt-out", "video-settings", "vpaid-adapter-choice", "width"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Placement = json::value::from_value(object).unwrap();
        let mut call = self.hub.placements().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placements_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.placements().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "size-ids" => {
                    call = call.add_size_ids(        value.map(|v| arg_from_str(v, err, "size-ids", "int64")).unwrap_or(-0));
                },
                "site-ids" => {
                    call = call.add_site_ids(        value.map(|v| arg_from_str(v, err, "site-ids", "int64")).unwrap_or(-0));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "pricing-types" => {
                    call = call.add_pricing_types(value.unwrap_or(""));
                },
                "placement-strategy-ids" => {
                    call = call.add_placement_strategy_ids(        value.map(|v| arg_from_str(v, err, "placement-strategy-ids", "int64")).unwrap_or(-0));
                },
                "payment-source" => {
                    call = call.payment_source(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "min-start-date" => {
                    call = call.min_start_date(value.unwrap_or(""));
                },
                "min-end-date" => {
                    call = call.min_end_date(value.unwrap_or(""));
                },
                "max-start-date" => {
                    call = call.max_start_date(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "max-end-date" => {
                    call = call.max_end_date(value.unwrap_or(""));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "group-ids" => {
                    call = call.add_group_ids(        value.map(|v| arg_from_str(v, err, "group-ids", "int64")).unwrap_or(-0));
                },
                "directory-site-ids" => {
                    call = call.add_directory_site_ids(        value.map(|v| arg_from_str(v, err, "directory-site-ids", "int64")).unwrap_or(-0));
                },
                "content-category-ids" => {
                    call = call.add_content_category_ids(        value.map(|v| arg_from_str(v, err, "content-category-ids", "int64")).unwrap_or(-0));
                },
                "compatibilities" => {
                    call = call.add_compatibilities(value.unwrap_or(""));
                },
                "campaign-ids" => {
                    call = call.add_campaign_ids(        value.map(|v| arg_from_str(v, err, "campaign-ids", "int64")).unwrap_or(-0));
                },
                "archived" => {
                    call = call.archived(        value.map(|v| arg_from_str(v, err, "archived", "boolean")).unwrap_or(false));
                },
                "advertiser-ids" => {
                    call = call.add_advertiser_ids(        value.map(|v| arg_from_str(v, err, "advertiser-ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["advertiser-ids", "archived", "campaign-ids", "compatibilities", "content-category-ids", "directory-site-ids", "group-ids", "ids", "max-end-date", "max-results", "max-start-date", "min-end-date", "min-start-date", "page-token", "payment-source", "placement-strategy-ids", "pricing-types", "search-string", "site-ids", "size-ids", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placements_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-blocking-opt-out" => Some(("adBlockingOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "campaign-id" => Some(("campaignId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.dimension-name" => Some(("campaignIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.etag" => Some(("campaignIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.id" => Some(("campaignIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.kind" => Some(("campaignIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.match-type" => Some(("campaignIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.value" => Some(("campaignIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "comment" => Some(("comment", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "compatibility" => Some(("compatibility", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "content-category-id" => Some(("contentCategoryId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "create-info.time" => Some(("createInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id" => Some(("directorySiteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.dimension-name" => Some(("directorySiteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.etag" => Some(("directorySiteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.id" => Some(("directorySiteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.kind" => Some(("directorySiteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.match-type" => Some(("directorySiteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.value" => Some(("directorySiteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "external-id" => Some(("externalId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "key-name" => Some(("keyName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "lookback-configuration.click-duration" => Some(("lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "lookback-configuration.post-impression-activities-duration" => Some(("lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "payment-approved" => Some(("paymentApproved", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "payment-source" => Some(("paymentSource", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id" => Some(("placementGroupId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.dimension-name" => Some(("placementGroupIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.etag" => Some(("placementGroupIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.id" => Some(("placementGroupIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.kind" => Some(("placementGroupIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.match-type" => Some(("placementGroupIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.value" => Some(("placementGroupIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-strategy-id" => Some(("placementStrategyId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.cap-cost-option" => Some(("pricingSchedule.capCostOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.disregard-overdelivery" => Some(("pricingSchedule.disregardOverdelivery", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "pricing-schedule.end-date" => Some(("pricingSchedule.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.flighted" => Some(("pricingSchedule.flighted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "pricing-schedule.floodlight-activity-id" => Some(("pricingSchedule.floodlightActivityId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.pricing-type" => Some(("pricingSchedule.pricingType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.start-date" => Some(("pricingSchedule.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.testing-start-date" => Some(("pricingSchedule.testingStartDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary" => Some(("primary", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "publisher-update-info.time" => Some(("publisherUpdateInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id" => Some(("siteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.dimension-name" => Some(("siteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.etag" => Some(("siteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.id" => Some(("siteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.kind" => Some(("siteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.match-type" => Some(("siteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.value" => Some(("siteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.height" => Some(("size.height", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "size.iab" => Some(("size.iab", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "size.id" => Some(("size.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.kind" => Some(("size.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.width" => Some(("size.width", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "ssl-required" => Some(("sslRequired", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "status" => Some(("status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-formats" => Some(("tagFormats", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "tag-setting.additional-key-values" => Some(("tagSetting.additionalKeyValues", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-setting.include-click-through-urls" => Some(("tagSetting.includeClickThroughUrls", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "tag-setting.include-click-tracking" => Some(("tagSetting.includeClickTracking", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "tag-setting.keyword-option" => Some(("tagSetting.keywordOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-active-view-opt-out" => Some(("videoActiveViewOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "video-settings.companion-settings.companions-disabled" => Some(("videoSettings.companionSettings.companionsDisabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "video-settings.companion-settings.image-only" => Some(("videoSettings.companionSettings.imageOnly", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "video-settings.companion-settings.kind" => Some(("videoSettings.companionSettings.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-settings.kind" => Some(("videoSettings.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.kind" => Some(("videoSettings.skippableSettings.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.progress-offset.offset-percentage" => Some(("videoSettings.skippableSettings.progressOffset.offsetPercentage", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.progress-offset.offset-seconds" => Some(("videoSettings.skippableSettings.progressOffset.offsetSeconds", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.skip-offset.offset-percentage" => Some(("videoSettings.skippableSettings.skipOffset.offsetPercentage", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.skip-offset.offset-seconds" => Some(("videoSettings.skippableSettings.skipOffset.offsetSeconds", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.skippable" => Some(("videoSettings.skippableSettings.skippable", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "video-settings.transcode-settings.enabled-video-formats" => Some(("videoSettings.transcodeSettings.enabledVideoFormats", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Vec })),
                    "video-settings.transcode-settings.kind" => Some(("videoSettings.transcodeSettings.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "vpaid-adapter-choice" => Some(("vpaidAdapterChoice", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "ad-blocking-opt-out", "additional-key-values", "advertiser-id", "advertiser-id-dimension-value", "archived", "campaign-id", "campaign-id-dimension-value", "cap-cost-option", "click-duration", "comment", "companion-settings", "companions-disabled", "compatibility", "content-category-id", "create-info", "dimension-name", "directory-site-id", "directory-site-id-dimension-value", "disregard-overdelivery", "enabled-video-formats", "end-date", "etag", "external-id", "flighted", "floodlight-activity-id", "height", "iab", "id", "id-dimension-value", "image-only", "include-click-through-urls", "include-click-tracking", "key-name", "keyword-option", "kind", "last-modified-info", "lookback-configuration", "match-type", "name", "offset-percentage", "offset-seconds", "payment-approved", "payment-source", "placement-group-id", "placement-group-id-dimension-value", "placement-strategy-id", "post-impression-activities-duration", "pricing-schedule", "pricing-type", "primary", "progress-offset", "publisher-update-info", "site-id", "site-id-dimension-value", "size", "skip-offset", "skippable", "skippable-settings", "ssl-required", "start-date", "status", "subaccount-id", "tag-formats", "tag-setting", "testing-start-date", "time", "transcode-settings", "value", "video-active-view-opt-out", "video-settings", "vpaid-adapter-choice", "width"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Placement = json::value::from_value(object).unwrap();
        let mut call = self.hub.placements().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _placements_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "ad-blocking-opt-out" => Some(("adBlockingOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "archived" => Some(("archived", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "campaign-id" => Some(("campaignId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.dimension-name" => Some(("campaignIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.etag" => Some(("campaignIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.id" => Some(("campaignIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.kind" => Some(("campaignIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.match-type" => Some(("campaignIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "campaign-id-dimension-value.value" => Some(("campaignIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "comment" => Some(("comment", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "compatibility" => Some(("compatibility", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "content-category-id" => Some(("contentCategoryId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "create-info.time" => Some(("createInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id" => Some(("directorySiteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.dimension-name" => Some(("directorySiteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.etag" => Some(("directorySiteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.id" => Some(("directorySiteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.kind" => Some(("directorySiteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.match-type" => Some(("directorySiteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.value" => Some(("directorySiteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "external-id" => Some(("externalId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "key-name" => Some(("keyName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-info.time" => Some(("lastModifiedInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "lookback-configuration.click-duration" => Some(("lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "lookback-configuration.post-impression-activities-duration" => Some(("lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "payment-approved" => Some(("paymentApproved", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "payment-source" => Some(("paymentSource", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id" => Some(("placementGroupId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.dimension-name" => Some(("placementGroupIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.etag" => Some(("placementGroupIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.id" => Some(("placementGroupIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.kind" => Some(("placementGroupIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.match-type" => Some(("placementGroupIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-group-id-dimension-value.value" => Some(("placementGroupIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "placement-strategy-id" => Some(("placementStrategyId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.cap-cost-option" => Some(("pricingSchedule.capCostOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.disregard-overdelivery" => Some(("pricingSchedule.disregardOverdelivery", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "pricing-schedule.end-date" => Some(("pricingSchedule.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.flighted" => Some(("pricingSchedule.flighted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "pricing-schedule.floodlight-activity-id" => Some(("pricingSchedule.floodlightActivityId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.pricing-type" => Some(("pricingSchedule.pricingType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.start-date" => Some(("pricingSchedule.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "pricing-schedule.testing-start-date" => Some(("pricingSchedule.testingStartDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "primary" => Some(("primary", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "publisher-update-info.time" => Some(("publisherUpdateInfo.time", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id" => Some(("siteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.dimension-name" => Some(("siteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.etag" => Some(("siteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.id" => Some(("siteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.kind" => Some(("siteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.match-type" => Some(("siteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-id-dimension-value.value" => Some(("siteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.height" => Some(("size.height", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "size.iab" => Some(("size.iab", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "size.id" => Some(("size.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.kind" => Some(("size.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "size.width" => Some(("size.width", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "ssl-required" => Some(("sslRequired", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "status" => Some(("status", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-formats" => Some(("tagFormats", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "tag-setting.additional-key-values" => Some(("tagSetting.additionalKeyValues", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "tag-setting.include-click-through-urls" => Some(("tagSetting.includeClickThroughUrls", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "tag-setting.include-click-tracking" => Some(("tagSetting.includeClickTracking", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "tag-setting.keyword-option" => Some(("tagSetting.keywordOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-active-view-opt-out" => Some(("videoActiveViewOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "video-settings.companion-settings.companions-disabled" => Some(("videoSettings.companionSettings.companionsDisabled", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "video-settings.companion-settings.image-only" => Some(("videoSettings.companionSettings.imageOnly", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "video-settings.companion-settings.kind" => Some(("videoSettings.companionSettings.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-settings.kind" => Some(("videoSettings.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.kind" => Some(("videoSettings.skippableSettings.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.progress-offset.offset-percentage" => Some(("videoSettings.skippableSettings.progressOffset.offsetPercentage", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.progress-offset.offset-seconds" => Some(("videoSettings.skippableSettings.progressOffset.offsetSeconds", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.skip-offset.offset-percentage" => Some(("videoSettings.skippableSettings.skipOffset.offsetPercentage", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.skip-offset.offset-seconds" => Some(("videoSettings.skippableSettings.skipOffset.offsetSeconds", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "video-settings.skippable-settings.skippable" => Some(("videoSettings.skippableSettings.skippable", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "video-settings.transcode-settings.enabled-video-formats" => Some(("videoSettings.transcodeSettings.enabledVideoFormats", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Vec })),
                    "video-settings.transcode-settings.kind" => Some(("videoSettings.transcodeSettings.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "vpaid-adapter-choice" => Some(("vpaidAdapterChoice", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "ad-blocking-opt-out", "additional-key-values", "advertiser-id", "advertiser-id-dimension-value", "archived", "campaign-id", "campaign-id-dimension-value", "cap-cost-option", "click-duration", "comment", "companion-settings", "companions-disabled", "compatibility", "content-category-id", "create-info", "dimension-name", "directory-site-id", "directory-site-id-dimension-value", "disregard-overdelivery", "enabled-video-formats", "end-date", "etag", "external-id", "flighted", "floodlight-activity-id", "height", "iab", "id", "id-dimension-value", "image-only", "include-click-through-urls", "include-click-tracking", "key-name", "keyword-option", "kind", "last-modified-info", "lookback-configuration", "match-type", "name", "offset-percentage", "offset-seconds", "payment-approved", "payment-source", "placement-group-id", "placement-group-id-dimension-value", "placement-strategy-id", "post-impression-activities-duration", "pricing-schedule", "pricing-type", "primary", "progress-offset", "publisher-update-info", "site-id", "site-id-dimension-value", "size", "skip-offset", "skippable", "skippable-settings", "ssl-required", "start-date", "status", "subaccount-id", "tag-formats", "tag-setting", "testing-start-date", "time", "transcode-settings", "value", "video-active-view-opt-out", "video-settings", "vpaid-adapter-choice", "width"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Placement = json::value::from_value(object).unwrap();
        let mut call = self.hub.placements().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _platform_types_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.platform_types().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _platform_types_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.platform_types().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _postal_codes_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.postal_codes().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("code").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _postal_codes_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.postal_codes().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _projects_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.projects().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _projects_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.projects().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "advertiser-ids" => {
                    call = call.add_advertiser_ids(        value.map(|v| arg_from_str(v, err, "advertiser-ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["advertiser-ids", "ids", "max-results", "page-token", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _regions_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.regions().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _remarketing_list_shares_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.remarketing_list_shares().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("remarketing-list-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _remarketing_list_shares_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "remarketing-list-id" => Some(("remarketingListId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "shared-account-ids" => Some(("sharedAccountIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "shared-advertiser-ids" => Some(("sharedAdvertiserIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["kind", "remarketing-list-id", "shared-account-ids", "shared-advertiser-ids"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::RemarketingListShare = json::value::from_value(object).unwrap();
        let mut call = self.hub.remarketing_list_shares().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("remarketing-list-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _remarketing_list_shares_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "remarketing-list-id" => Some(("remarketingListId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "shared-account-ids" => Some(("sharedAccountIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "shared-advertiser-ids" => Some(("sharedAdvertiserIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["kind", "remarketing-list-id", "shared-account-ids", "shared-advertiser-ids"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::RemarketingListShare = json::value::from_value(object).unwrap();
        let mut call = self.hub.remarketing_list_shares().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _remarketing_lists_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.remarketing_lists().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _remarketing_lists_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "description" => Some(("description", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "life-span" => Some(("lifeSpan", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-population-rule.floodlight-activity-id" => Some(("listPopulationRule.floodlightActivityId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-population-rule.floodlight-activity-name" => Some(("listPopulationRule.floodlightActivityName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-size" => Some(("listSize", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-source" => Some(("listSource", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "advertiser-id", "advertiser-id-dimension-value", "description", "dimension-name", "etag", "floodlight-activity-id", "floodlight-activity-name", "id", "kind", "life-span", "list-population-rule", "list-size", "list-source", "match-type", "name", "subaccount-id", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::RemarketingList = json::value::from_value(object).unwrap();
        let mut call = self.hub.remarketing_lists().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _remarketing_lists_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.remarketing_lists().list(opt.value_of("profile-id").unwrap_or(""), opt.value_of("advertiser-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "name" => {
                    call = call.name(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "floodlight-activity-id" => {
                    call = call.floodlight_activity_id(        value.map(|v| arg_from_str(v, err, "floodlight-activity-id", "int64")).unwrap_or(-0));
                },
                "active" => {
                    call = call.active(        value.map(|v| arg_from_str(v, err, "active", "boolean")).unwrap_or(false));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["active", "floodlight-activity-id", "max-results", "name", "page-token", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _remarketing_lists_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "description" => Some(("description", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "life-span" => Some(("lifeSpan", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-population-rule.floodlight-activity-id" => Some(("listPopulationRule.floodlightActivityId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-population-rule.floodlight-activity-name" => Some(("listPopulationRule.floodlightActivityName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-size" => Some(("listSize", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-source" => Some(("listSource", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "advertiser-id", "advertiser-id-dimension-value", "description", "dimension-name", "etag", "floodlight-activity-id", "floodlight-activity-name", "id", "kind", "life-span", "list-population-rule", "list-size", "list-source", "match-type", "name", "subaccount-id", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::RemarketingList = json::value::from_value(object).unwrap();
        let mut call = self.hub.remarketing_lists().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _remarketing_lists_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "active" => Some(("active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "description" => Some(("description", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "life-span" => Some(("lifeSpan", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-population-rule.floodlight-activity-id" => Some(("listPopulationRule.floodlightActivityId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-population-rule.floodlight-activity-name" => Some(("listPopulationRule.floodlightActivityName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-size" => Some(("listSize", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-source" => Some(("listSource", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "advertiser-id", "advertiser-id-dimension-value", "description", "dimension-name", "etag", "floodlight-activity-id", "floodlight-activity-name", "id", "kind", "life-span", "list-population-rule", "list-size", "list-source", "match-type", "name", "subaccount-id", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::RemarketingList = json::value::from_value(object).unwrap();
        let mut call = self.hub.remarketing_lists().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _reports_compatible_fields_query(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.activities.kind" => Some(("criteria.activities.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.activities.metric-names" => Some(("criteria.activities.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "criteria.custom-rich-media-events.kind" => Some(("criteria.customRichMediaEvents.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.end-date" => Some(("criteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.kind" => Some(("criteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.relative-date-range" => Some(("criteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.start-date" => Some(("criteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.metric-names" => Some(("criteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "cross-dimension-reach-criteria.date-range.end-date" => Some(("crossDimensionReachCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.date-range.kind" => Some(("crossDimensionReachCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.date-range.relative-date-range" => Some(("crossDimensionReachCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.date-range.start-date" => Some(("crossDimensionReachCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.dimension" => Some(("crossDimensionReachCriteria.dimension", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.metric-names" => Some(("crossDimensionReachCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "cross-dimension-reach-criteria.overlap-metric-names" => Some(("crossDimensionReachCriteria.overlapMetricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "cross-dimension-reach-criteria.pivoted" => Some(("crossDimensionReachCriteria.pivoted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery.email-owner" => Some(("delivery.emailOwner", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery.email-owner-delivery-type" => Some(("delivery.emailOwnerDeliveryType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery.message" => Some(("delivery.message", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "etag" => Some(("etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "file-name" => Some(("fileName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.end-date" => Some(("floodlightCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.kind" => Some(("floodlightCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.relative-date-range" => Some(("floodlightCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.start-date" => Some(("floodlightCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.dimension-name" => Some(("floodlightCriteria.floodlightConfigId.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.etag" => Some(("floodlightCriteria.floodlightConfigId.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.id" => Some(("floodlightCriteria.floodlightConfigId.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.kind" => Some(("floodlightCriteria.floodlightConfigId.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.match-type" => Some(("floodlightCriteria.floodlightConfigId.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.value" => Some(("floodlightCriteria.floodlightConfigId.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.metric-names" => Some(("floodlightCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "floodlight-criteria.report-properties.include-attributed-ip-conversions" => Some(("floodlightCriteria.reportProperties.includeAttributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "floodlight-criteria.report-properties.include-unattributed-cookie-conversions" => Some(("floodlightCriteria.reportProperties.includeUnattributedCookieConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "floodlight-criteria.report-properties.include-unattributed-ip-conversions" => Some(("floodlightCriteria.reportProperties.includeUnattributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "format" => Some(("format", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-time" => Some(("lastModifiedTime", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "owner-profile-id" => Some(("ownerProfileId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.end-date" => Some(("pathToConversionCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.kind" => Some(("pathToConversionCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.relative-date-range" => Some(("pathToConversionCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.start-date" => Some(("pathToConversionCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.dimension-name" => Some(("pathToConversionCriteria.floodlightConfigId.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.etag" => Some(("pathToConversionCriteria.floodlightConfigId.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.id" => Some(("pathToConversionCriteria.floodlightConfigId.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.kind" => Some(("pathToConversionCriteria.floodlightConfigId.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.match-type" => Some(("pathToConversionCriteria.floodlightConfigId.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.value" => Some(("pathToConversionCriteria.floodlightConfigId.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.metric-names" => Some(("pathToConversionCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "path-to-conversion-criteria.report-properties.clicks-lookback-window" => Some(("pathToConversionCriteria.reportProperties.clicksLookbackWindow", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.impressions-lookback-window" => Some(("pathToConversionCriteria.reportProperties.impressionsLookbackWindow", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.include-attributed-ip-conversions" => Some(("pathToConversionCriteria.reportProperties.includeAttributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.include-unattributed-cookie-conversions" => Some(("pathToConversionCriteria.reportProperties.includeUnattributedCookieConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.include-unattributed-ip-conversions" => Some(("pathToConversionCriteria.reportProperties.includeUnattributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.maximum-click-interactions" => Some(("pathToConversionCriteria.reportProperties.maximumClickInteractions", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.maximum-impression-interactions" => Some(("pathToConversionCriteria.reportProperties.maximumImpressionInteractions", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.maximum-interaction-gap" => Some(("pathToConversionCriteria.reportProperties.maximumInteractionGap", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.pivot-on-interaction-path" => Some(("pathToConversionCriteria.reportProperties.pivotOnInteractionPath", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "reach-criteria.activities.kind" => Some(("reachCriteria.activities.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.activities.metric-names" => Some(("reachCriteria.activities.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "reach-criteria.custom-rich-media-events.kind" => Some(("reachCriteria.customRichMediaEvents.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.end-date" => Some(("reachCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.kind" => Some(("reachCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.relative-date-range" => Some(("reachCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.start-date" => Some(("reachCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.enable-all-dimension-combinations" => Some(("reachCriteria.enableAllDimensionCombinations", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "reach-criteria.metric-names" => Some(("reachCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "reach-criteria.reach-by-frequency-metric-names" => Some(("reachCriteria.reachByFrequencyMetricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "schedule.active" => Some(("schedule.active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "schedule.every" => Some(("schedule.every", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "schedule.expiration-date" => Some(("schedule.expirationDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "schedule.repeats" => Some(("schedule.repeats", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "schedule.repeats-on-week-days" => Some(("schedule.repeatsOnWeekDays", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "schedule.runs-on-day-of-month" => Some(("schedule.runsOnDayOfMonth", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "schedule.start-date" => Some(("schedule.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "sub-account-id" => Some(("subAccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "activities", "clicks-lookback-window", "criteria", "cross-dimension-reach-criteria", "custom-rich-media-events", "date-range", "delivery", "dimension", "dimension-name", "email-owner", "email-owner-delivery-type", "enable-all-dimension-combinations", "end-date", "etag", "every", "expiration-date", "file-name", "floodlight-config-id", "floodlight-criteria", "format", "id", "impressions-lookback-window", "include-attributed-ip-conversions", "include-unattributed-cookie-conversions", "include-unattributed-ip-conversions", "kind", "last-modified-time", "match-type", "maximum-click-interactions", "maximum-impression-interactions", "maximum-interaction-gap", "message", "metric-names", "name", "overlap-metric-names", "owner-profile-id", "path-to-conversion-criteria", "pivot-on-interaction-path", "pivoted", "reach-by-frequency-metric-names", "reach-criteria", "relative-date-range", "repeats", "repeats-on-week-days", "report-properties", "runs-on-day-of-month", "schedule", "start-date", "sub-account-id", "type", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Report = json::value::from_value(object).unwrap();
        let mut call = self.hub.reports().compatible_fields_query(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _reports_delete(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.reports().delete(opt.value_of("profile-id").unwrap_or(""), opt.value_of("report-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok(mut response) => {
                    Ok(())
                }
            }
        }
    }

    async fn _reports_files_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut download_mode = false;
        let mut call = self.hub.reports().files_get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("report-id").unwrap_or(""), opt.value_of("file-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            if key == "alt" && value.unwrap_or("unset") == "media" {
                                download_mode = true;
                            }
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    if !download_mode {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    } else {
                    let bytes = hyper::body::to_bytes(response.into_body()).await.expect("a string as API currently is inefficient").to_vec();
                    ostream.write_all(&bytes).expect("write to be complete");
                    ostream.flush().expect("io to never fail which should really be fixed one day");
                    }
                    Ok(())
                }
            }
        }
    }

    async fn _reports_files_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.reports().files_list(opt.value_of("profile-id").unwrap_or(""), opt.value_of("report-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["max-results", "page-token", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _reports_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.reports().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("report-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _reports_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.activities.kind" => Some(("criteria.activities.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.activities.metric-names" => Some(("criteria.activities.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "criteria.custom-rich-media-events.kind" => Some(("criteria.customRichMediaEvents.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.end-date" => Some(("criteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.kind" => Some(("criteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.relative-date-range" => Some(("criteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.start-date" => Some(("criteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.metric-names" => Some(("criteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "cross-dimension-reach-criteria.date-range.end-date" => Some(("crossDimensionReachCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.date-range.kind" => Some(("crossDimensionReachCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.date-range.relative-date-range" => Some(("crossDimensionReachCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.date-range.start-date" => Some(("crossDimensionReachCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.dimension" => Some(("crossDimensionReachCriteria.dimension", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.metric-names" => Some(("crossDimensionReachCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "cross-dimension-reach-criteria.overlap-metric-names" => Some(("crossDimensionReachCriteria.overlapMetricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "cross-dimension-reach-criteria.pivoted" => Some(("crossDimensionReachCriteria.pivoted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery.email-owner" => Some(("delivery.emailOwner", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery.email-owner-delivery-type" => Some(("delivery.emailOwnerDeliveryType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery.message" => Some(("delivery.message", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "etag" => Some(("etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "file-name" => Some(("fileName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.end-date" => Some(("floodlightCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.kind" => Some(("floodlightCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.relative-date-range" => Some(("floodlightCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.start-date" => Some(("floodlightCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.dimension-name" => Some(("floodlightCriteria.floodlightConfigId.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.etag" => Some(("floodlightCriteria.floodlightConfigId.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.id" => Some(("floodlightCriteria.floodlightConfigId.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.kind" => Some(("floodlightCriteria.floodlightConfigId.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.match-type" => Some(("floodlightCriteria.floodlightConfigId.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.value" => Some(("floodlightCriteria.floodlightConfigId.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.metric-names" => Some(("floodlightCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "floodlight-criteria.report-properties.include-attributed-ip-conversions" => Some(("floodlightCriteria.reportProperties.includeAttributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "floodlight-criteria.report-properties.include-unattributed-cookie-conversions" => Some(("floodlightCriteria.reportProperties.includeUnattributedCookieConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "floodlight-criteria.report-properties.include-unattributed-ip-conversions" => Some(("floodlightCriteria.reportProperties.includeUnattributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "format" => Some(("format", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-time" => Some(("lastModifiedTime", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "owner-profile-id" => Some(("ownerProfileId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.end-date" => Some(("pathToConversionCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.kind" => Some(("pathToConversionCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.relative-date-range" => Some(("pathToConversionCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.start-date" => Some(("pathToConversionCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.dimension-name" => Some(("pathToConversionCriteria.floodlightConfigId.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.etag" => Some(("pathToConversionCriteria.floodlightConfigId.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.id" => Some(("pathToConversionCriteria.floodlightConfigId.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.kind" => Some(("pathToConversionCriteria.floodlightConfigId.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.match-type" => Some(("pathToConversionCriteria.floodlightConfigId.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.value" => Some(("pathToConversionCriteria.floodlightConfigId.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.metric-names" => Some(("pathToConversionCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "path-to-conversion-criteria.report-properties.clicks-lookback-window" => Some(("pathToConversionCriteria.reportProperties.clicksLookbackWindow", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.impressions-lookback-window" => Some(("pathToConversionCriteria.reportProperties.impressionsLookbackWindow", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.include-attributed-ip-conversions" => Some(("pathToConversionCriteria.reportProperties.includeAttributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.include-unattributed-cookie-conversions" => Some(("pathToConversionCriteria.reportProperties.includeUnattributedCookieConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.include-unattributed-ip-conversions" => Some(("pathToConversionCriteria.reportProperties.includeUnattributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.maximum-click-interactions" => Some(("pathToConversionCriteria.reportProperties.maximumClickInteractions", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.maximum-impression-interactions" => Some(("pathToConversionCriteria.reportProperties.maximumImpressionInteractions", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.maximum-interaction-gap" => Some(("pathToConversionCriteria.reportProperties.maximumInteractionGap", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.pivot-on-interaction-path" => Some(("pathToConversionCriteria.reportProperties.pivotOnInteractionPath", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "reach-criteria.activities.kind" => Some(("reachCriteria.activities.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.activities.metric-names" => Some(("reachCriteria.activities.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "reach-criteria.custom-rich-media-events.kind" => Some(("reachCriteria.customRichMediaEvents.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.end-date" => Some(("reachCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.kind" => Some(("reachCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.relative-date-range" => Some(("reachCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.start-date" => Some(("reachCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.enable-all-dimension-combinations" => Some(("reachCriteria.enableAllDimensionCombinations", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "reach-criteria.metric-names" => Some(("reachCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "reach-criteria.reach-by-frequency-metric-names" => Some(("reachCriteria.reachByFrequencyMetricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "schedule.active" => Some(("schedule.active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "schedule.every" => Some(("schedule.every", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "schedule.expiration-date" => Some(("schedule.expirationDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "schedule.repeats" => Some(("schedule.repeats", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "schedule.repeats-on-week-days" => Some(("schedule.repeatsOnWeekDays", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "schedule.runs-on-day-of-month" => Some(("schedule.runsOnDayOfMonth", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "schedule.start-date" => Some(("schedule.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "sub-account-id" => Some(("subAccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "activities", "clicks-lookback-window", "criteria", "cross-dimension-reach-criteria", "custom-rich-media-events", "date-range", "delivery", "dimension", "dimension-name", "email-owner", "email-owner-delivery-type", "enable-all-dimension-combinations", "end-date", "etag", "every", "expiration-date", "file-name", "floodlight-config-id", "floodlight-criteria", "format", "id", "impressions-lookback-window", "include-attributed-ip-conversions", "include-unattributed-cookie-conversions", "include-unattributed-ip-conversions", "kind", "last-modified-time", "match-type", "maximum-click-interactions", "maximum-impression-interactions", "maximum-interaction-gap", "message", "metric-names", "name", "overlap-metric-names", "owner-profile-id", "path-to-conversion-criteria", "pivot-on-interaction-path", "pivoted", "reach-by-frequency-metric-names", "reach-criteria", "relative-date-range", "repeats", "repeats-on-week-days", "report-properties", "runs-on-day-of-month", "schedule", "start-date", "sub-account-id", "type", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Report = json::value::from_value(object).unwrap();
        let mut call = self.hub.reports().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _reports_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.reports().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "scope" => {
                    call = call.scope(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["max-results", "page-token", "scope", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _reports_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.activities.kind" => Some(("criteria.activities.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.activities.metric-names" => Some(("criteria.activities.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "criteria.custom-rich-media-events.kind" => Some(("criteria.customRichMediaEvents.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.end-date" => Some(("criteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.kind" => Some(("criteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.relative-date-range" => Some(("criteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.start-date" => Some(("criteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.metric-names" => Some(("criteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "cross-dimension-reach-criteria.date-range.end-date" => Some(("crossDimensionReachCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.date-range.kind" => Some(("crossDimensionReachCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.date-range.relative-date-range" => Some(("crossDimensionReachCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.date-range.start-date" => Some(("crossDimensionReachCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.dimension" => Some(("crossDimensionReachCriteria.dimension", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.metric-names" => Some(("crossDimensionReachCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "cross-dimension-reach-criteria.overlap-metric-names" => Some(("crossDimensionReachCriteria.overlapMetricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "cross-dimension-reach-criteria.pivoted" => Some(("crossDimensionReachCriteria.pivoted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery.email-owner" => Some(("delivery.emailOwner", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery.email-owner-delivery-type" => Some(("delivery.emailOwnerDeliveryType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery.message" => Some(("delivery.message", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "etag" => Some(("etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "file-name" => Some(("fileName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.end-date" => Some(("floodlightCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.kind" => Some(("floodlightCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.relative-date-range" => Some(("floodlightCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.start-date" => Some(("floodlightCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.dimension-name" => Some(("floodlightCriteria.floodlightConfigId.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.etag" => Some(("floodlightCriteria.floodlightConfigId.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.id" => Some(("floodlightCriteria.floodlightConfigId.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.kind" => Some(("floodlightCriteria.floodlightConfigId.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.match-type" => Some(("floodlightCriteria.floodlightConfigId.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.value" => Some(("floodlightCriteria.floodlightConfigId.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.metric-names" => Some(("floodlightCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "floodlight-criteria.report-properties.include-attributed-ip-conversions" => Some(("floodlightCriteria.reportProperties.includeAttributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "floodlight-criteria.report-properties.include-unattributed-cookie-conversions" => Some(("floodlightCriteria.reportProperties.includeUnattributedCookieConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "floodlight-criteria.report-properties.include-unattributed-ip-conversions" => Some(("floodlightCriteria.reportProperties.includeUnattributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "format" => Some(("format", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-time" => Some(("lastModifiedTime", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "owner-profile-id" => Some(("ownerProfileId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.end-date" => Some(("pathToConversionCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.kind" => Some(("pathToConversionCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.relative-date-range" => Some(("pathToConversionCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.start-date" => Some(("pathToConversionCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.dimension-name" => Some(("pathToConversionCriteria.floodlightConfigId.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.etag" => Some(("pathToConversionCriteria.floodlightConfigId.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.id" => Some(("pathToConversionCriteria.floodlightConfigId.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.kind" => Some(("pathToConversionCriteria.floodlightConfigId.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.match-type" => Some(("pathToConversionCriteria.floodlightConfigId.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.value" => Some(("pathToConversionCriteria.floodlightConfigId.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.metric-names" => Some(("pathToConversionCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "path-to-conversion-criteria.report-properties.clicks-lookback-window" => Some(("pathToConversionCriteria.reportProperties.clicksLookbackWindow", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.impressions-lookback-window" => Some(("pathToConversionCriteria.reportProperties.impressionsLookbackWindow", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.include-attributed-ip-conversions" => Some(("pathToConversionCriteria.reportProperties.includeAttributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.include-unattributed-cookie-conversions" => Some(("pathToConversionCriteria.reportProperties.includeUnattributedCookieConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.include-unattributed-ip-conversions" => Some(("pathToConversionCriteria.reportProperties.includeUnattributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.maximum-click-interactions" => Some(("pathToConversionCriteria.reportProperties.maximumClickInteractions", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.maximum-impression-interactions" => Some(("pathToConversionCriteria.reportProperties.maximumImpressionInteractions", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.maximum-interaction-gap" => Some(("pathToConversionCriteria.reportProperties.maximumInteractionGap", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.pivot-on-interaction-path" => Some(("pathToConversionCriteria.reportProperties.pivotOnInteractionPath", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "reach-criteria.activities.kind" => Some(("reachCriteria.activities.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.activities.metric-names" => Some(("reachCriteria.activities.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "reach-criteria.custom-rich-media-events.kind" => Some(("reachCriteria.customRichMediaEvents.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.end-date" => Some(("reachCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.kind" => Some(("reachCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.relative-date-range" => Some(("reachCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.start-date" => Some(("reachCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.enable-all-dimension-combinations" => Some(("reachCriteria.enableAllDimensionCombinations", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "reach-criteria.metric-names" => Some(("reachCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "reach-criteria.reach-by-frequency-metric-names" => Some(("reachCriteria.reachByFrequencyMetricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "schedule.active" => Some(("schedule.active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "schedule.every" => Some(("schedule.every", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "schedule.expiration-date" => Some(("schedule.expirationDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "schedule.repeats" => Some(("schedule.repeats", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "schedule.repeats-on-week-days" => Some(("schedule.repeatsOnWeekDays", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "schedule.runs-on-day-of-month" => Some(("schedule.runsOnDayOfMonth", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "schedule.start-date" => Some(("schedule.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "sub-account-id" => Some(("subAccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "activities", "clicks-lookback-window", "criteria", "cross-dimension-reach-criteria", "custom-rich-media-events", "date-range", "delivery", "dimension", "dimension-name", "email-owner", "email-owner-delivery-type", "enable-all-dimension-combinations", "end-date", "etag", "every", "expiration-date", "file-name", "floodlight-config-id", "floodlight-criteria", "format", "id", "impressions-lookback-window", "include-attributed-ip-conversions", "include-unattributed-cookie-conversions", "include-unattributed-ip-conversions", "kind", "last-modified-time", "match-type", "maximum-click-interactions", "maximum-impression-interactions", "maximum-interaction-gap", "message", "metric-names", "name", "overlap-metric-names", "owner-profile-id", "path-to-conversion-criteria", "pivot-on-interaction-path", "pivoted", "reach-by-frequency-metric-names", "reach-criteria", "relative-date-range", "repeats", "repeats-on-week-days", "report-properties", "runs-on-day-of-month", "schedule", "start-date", "sub-account-id", "type", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Report = json::value::from_value(object).unwrap();
        let mut call = self.hub.reports().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("report-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _reports_run(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.reports().run(opt.value_of("profile-id").unwrap_or(""), opt.value_of("report-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "synchronous" => {
                    call = call.synchronous(        value.map(|v| arg_from_str(v, err, "synchronous", "boolean")).unwrap_or(false));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["synchronous"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _reports_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.activities.kind" => Some(("criteria.activities.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.activities.metric-names" => Some(("criteria.activities.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "criteria.custom-rich-media-events.kind" => Some(("criteria.customRichMediaEvents.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.end-date" => Some(("criteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.kind" => Some(("criteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.relative-date-range" => Some(("criteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.date-range.start-date" => Some(("criteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "criteria.metric-names" => Some(("criteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "cross-dimension-reach-criteria.date-range.end-date" => Some(("crossDimensionReachCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.date-range.kind" => Some(("crossDimensionReachCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.date-range.relative-date-range" => Some(("crossDimensionReachCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.date-range.start-date" => Some(("crossDimensionReachCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.dimension" => Some(("crossDimensionReachCriteria.dimension", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "cross-dimension-reach-criteria.metric-names" => Some(("crossDimensionReachCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "cross-dimension-reach-criteria.overlap-metric-names" => Some(("crossDimensionReachCriteria.overlapMetricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "cross-dimension-reach-criteria.pivoted" => Some(("crossDimensionReachCriteria.pivoted", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery.email-owner" => Some(("delivery.emailOwner", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "delivery.email-owner-delivery-type" => Some(("delivery.emailOwnerDeliveryType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "delivery.message" => Some(("delivery.message", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "etag" => Some(("etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "file-name" => Some(("fileName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.end-date" => Some(("floodlightCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.kind" => Some(("floodlightCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.relative-date-range" => Some(("floodlightCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.date-range.start-date" => Some(("floodlightCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.dimension-name" => Some(("floodlightCriteria.floodlightConfigId.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.etag" => Some(("floodlightCriteria.floodlightConfigId.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.id" => Some(("floodlightCriteria.floodlightConfigId.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.kind" => Some(("floodlightCriteria.floodlightConfigId.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.match-type" => Some(("floodlightCriteria.floodlightConfigId.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.floodlight-config-id.value" => Some(("floodlightCriteria.floodlightConfigId.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "floodlight-criteria.metric-names" => Some(("floodlightCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "floodlight-criteria.report-properties.include-attributed-ip-conversions" => Some(("floodlightCriteria.reportProperties.includeAttributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "floodlight-criteria.report-properties.include-unattributed-cookie-conversions" => Some(("floodlightCriteria.reportProperties.includeUnattributedCookieConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "floodlight-criteria.report-properties.include-unattributed-ip-conversions" => Some(("floodlightCriteria.reportProperties.includeUnattributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "format" => Some(("format", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "last-modified-time" => Some(("lastModifiedTime", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "owner-profile-id" => Some(("ownerProfileId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.end-date" => Some(("pathToConversionCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.kind" => Some(("pathToConversionCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.relative-date-range" => Some(("pathToConversionCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.date-range.start-date" => Some(("pathToConversionCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.dimension-name" => Some(("pathToConversionCriteria.floodlightConfigId.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.etag" => Some(("pathToConversionCriteria.floodlightConfigId.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.id" => Some(("pathToConversionCriteria.floodlightConfigId.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.kind" => Some(("pathToConversionCriteria.floodlightConfigId.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.match-type" => Some(("pathToConversionCriteria.floodlightConfigId.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.floodlight-config-id.value" => Some(("pathToConversionCriteria.floodlightConfigId.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.metric-names" => Some(("pathToConversionCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "path-to-conversion-criteria.report-properties.clicks-lookback-window" => Some(("pathToConversionCriteria.reportProperties.clicksLookbackWindow", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.impressions-lookback-window" => Some(("pathToConversionCriteria.reportProperties.impressionsLookbackWindow", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.include-attributed-ip-conversions" => Some(("pathToConversionCriteria.reportProperties.includeAttributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.include-unattributed-cookie-conversions" => Some(("pathToConversionCriteria.reportProperties.includeUnattributedCookieConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.include-unattributed-ip-conversions" => Some(("pathToConversionCriteria.reportProperties.includeUnattributedIPConversions", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.maximum-click-interactions" => Some(("pathToConversionCriteria.reportProperties.maximumClickInteractions", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.maximum-impression-interactions" => Some(("pathToConversionCriteria.reportProperties.maximumImpressionInteractions", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.maximum-interaction-gap" => Some(("pathToConversionCriteria.reportProperties.maximumInteractionGap", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "path-to-conversion-criteria.report-properties.pivot-on-interaction-path" => Some(("pathToConversionCriteria.reportProperties.pivotOnInteractionPath", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "reach-criteria.activities.kind" => Some(("reachCriteria.activities.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.activities.metric-names" => Some(("reachCriteria.activities.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "reach-criteria.custom-rich-media-events.kind" => Some(("reachCriteria.customRichMediaEvents.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.end-date" => Some(("reachCriteria.dateRange.endDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.kind" => Some(("reachCriteria.dateRange.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.relative-date-range" => Some(("reachCriteria.dateRange.relativeDateRange", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.date-range.start-date" => Some(("reachCriteria.dateRange.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "reach-criteria.enable-all-dimension-combinations" => Some(("reachCriteria.enableAllDimensionCombinations", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "reach-criteria.metric-names" => Some(("reachCriteria.metricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "reach-criteria.reach-by-frequency-metric-names" => Some(("reachCriteria.reachByFrequencyMetricNames", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "schedule.active" => Some(("schedule.active", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "schedule.every" => Some(("schedule.every", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "schedule.expiration-date" => Some(("schedule.expirationDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "schedule.repeats" => Some(("schedule.repeats", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "schedule.repeats-on-week-days" => Some(("schedule.repeatsOnWeekDays", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "schedule.runs-on-day-of-month" => Some(("schedule.runsOnDayOfMonth", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "schedule.start-date" => Some(("schedule.startDate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "sub-account-id" => Some(("subAccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "type" => Some(("type", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active", "activities", "clicks-lookback-window", "criteria", "cross-dimension-reach-criteria", "custom-rich-media-events", "date-range", "delivery", "dimension", "dimension-name", "email-owner", "email-owner-delivery-type", "enable-all-dimension-combinations", "end-date", "etag", "every", "expiration-date", "file-name", "floodlight-config-id", "floodlight-criteria", "format", "id", "impressions-lookback-window", "include-attributed-ip-conversions", "include-unattributed-cookie-conversions", "include-unattributed-ip-conversions", "kind", "last-modified-time", "match-type", "maximum-click-interactions", "maximum-impression-interactions", "maximum-interaction-gap", "message", "metric-names", "name", "overlap-metric-names", "owner-profile-id", "path-to-conversion-criteria", "pivot-on-interaction-path", "pivoted", "reach-by-frequency-metric-names", "reach-criteria", "relative-date-range", "repeats", "repeats-on-week-days", "report-properties", "runs-on-day-of-month", "schedule", "start-date", "sub-account-id", "type", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Report = json::value::from_value(object).unwrap();
        let mut call = self.hub.reports().update(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("report-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _sites_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.sites().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _sites_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "approved" => Some(("approved", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "directory-site-id" => Some(("directorySiteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.dimension-name" => Some(("directorySiteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.etag" => Some(("directorySiteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.id" => Some(("directorySiteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.kind" => Some(("directorySiteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.match-type" => Some(("directorySiteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.value" => Some(("directorySiteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "key-name" => Some(("keyName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.active-view-opt-out" => Some(("siteSettings.activeViewOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.ad-blocking-opt-out" => Some(("siteSettings.adBlockingOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.creative-settings.i-frame-footer" => Some(("siteSettings.creativeSettings.iFrameFooter", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.creative-settings.i-frame-header" => Some(("siteSettings.creativeSettings.iFrameHeader", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.disable-new-cookie" => Some(("siteSettings.disableNewCookie", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.lookback-configuration.click-duration" => Some(("siteSettings.lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "site-settings.lookback-configuration.post-impression-activities-duration" => Some(("siteSettings.lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "site-settings.tag-setting.additional-key-values" => Some(("siteSettings.tagSetting.additionalKeyValues", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.tag-setting.include-click-through-urls" => Some(("siteSettings.tagSetting.includeClickThroughUrls", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.tag-setting.include-click-tracking" => Some(("siteSettings.tagSetting.includeClickTracking", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.tag-setting.keyword-option" => Some(("siteSettings.tagSetting.keywordOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.video-active-view-opt-out-template" => Some(("siteSettings.videoActiveViewOptOutTemplate", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.vpaid-adapter-choice-template" => Some(("siteSettings.vpaidAdapterChoiceTemplate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active-view-opt-out", "ad-blocking-opt-out", "additional-key-values", "approved", "click-duration", "creative-settings", "dimension-name", "directory-site-id", "directory-site-id-dimension-value", "disable-new-cookie", "etag", "i-frame-footer", "i-frame-header", "id", "id-dimension-value", "include-click-through-urls", "include-click-tracking", "key-name", "keyword-option", "kind", "lookback-configuration", "match-type", "name", "post-impression-activities-duration", "site-settings", "subaccount-id", "tag-setting", "value", "video-active-view-opt-out-template", "vpaid-adapter-choice-template"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Site = json::value::from_value(object).unwrap();
        let mut call = self.hub.sites().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _sites_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.sites().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "unmapped-site" => {
                    call = call.unmapped_site(        value.map(|v| arg_from_str(v, err, "unmapped-site", "boolean")).unwrap_or(false));
                },
                "subaccount-id" => {
                    call = call.subaccount_id(        value.map(|v| arg_from_str(v, err, "subaccount-id", "int64")).unwrap_or(-0));
                },
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "directory-site-ids" => {
                    call = call.add_directory_site_ids(        value.map(|v| arg_from_str(v, err, "directory-site-ids", "int64")).unwrap_or(-0));
                },
                "campaign-ids" => {
                    call = call.add_campaign_ids(        value.map(|v| arg_from_str(v, err, "campaign-ids", "int64")).unwrap_or(-0));
                },
                "approved" => {
                    call = call.approved(        value.map(|v| arg_from_str(v, err, "approved", "boolean")).unwrap_or(false));
                },
                "ad-words-site" => {
                    call = call.ad_words_site(        value.map(|v| arg_from_str(v, err, "ad-words-site", "boolean")).unwrap_or(false));
                },
                "accepts-publisher-paid-placements" => {
                    call = call.accepts_publisher_paid_placements(        value.map(|v| arg_from_str(v, err, "accepts-publisher-paid-placements", "boolean")).unwrap_or(false));
                },
                "accepts-interstitial-placements" => {
                    call = call.accepts_interstitial_placements(        value.map(|v| arg_from_str(v, err, "accepts-interstitial-placements", "boolean")).unwrap_or(false));
                },
                "accepts-in-stream-video-placements" => {
                    call = call.accepts_in_stream_video_placements(        value.map(|v| arg_from_str(v, err, "accepts-in-stream-video-placements", "boolean")).unwrap_or(false));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["accepts-in-stream-video-placements", "accepts-interstitial-placements", "accepts-publisher-paid-placements", "ad-words-site", "approved", "campaign-ids", "directory-site-ids", "ids", "max-results", "page-token", "search-string", "sort-field", "sort-order", "subaccount-id", "unmapped-site"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _sites_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "approved" => Some(("approved", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "directory-site-id" => Some(("directorySiteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.dimension-name" => Some(("directorySiteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.etag" => Some(("directorySiteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.id" => Some(("directorySiteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.kind" => Some(("directorySiteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.match-type" => Some(("directorySiteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.value" => Some(("directorySiteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "key-name" => Some(("keyName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.active-view-opt-out" => Some(("siteSettings.activeViewOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.ad-blocking-opt-out" => Some(("siteSettings.adBlockingOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.creative-settings.i-frame-footer" => Some(("siteSettings.creativeSettings.iFrameFooter", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.creative-settings.i-frame-header" => Some(("siteSettings.creativeSettings.iFrameHeader", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.disable-new-cookie" => Some(("siteSettings.disableNewCookie", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.lookback-configuration.click-duration" => Some(("siteSettings.lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "site-settings.lookback-configuration.post-impression-activities-duration" => Some(("siteSettings.lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "site-settings.tag-setting.additional-key-values" => Some(("siteSettings.tagSetting.additionalKeyValues", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.tag-setting.include-click-through-urls" => Some(("siteSettings.tagSetting.includeClickThroughUrls", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.tag-setting.include-click-tracking" => Some(("siteSettings.tagSetting.includeClickTracking", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.tag-setting.keyword-option" => Some(("siteSettings.tagSetting.keywordOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.video-active-view-opt-out-template" => Some(("siteSettings.videoActiveViewOptOutTemplate", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.vpaid-adapter-choice-template" => Some(("siteSettings.vpaidAdapterChoiceTemplate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active-view-opt-out", "ad-blocking-opt-out", "additional-key-values", "approved", "click-duration", "creative-settings", "dimension-name", "directory-site-id", "directory-site-id-dimension-value", "disable-new-cookie", "etag", "i-frame-footer", "i-frame-header", "id", "id-dimension-value", "include-click-through-urls", "include-click-tracking", "key-name", "keyword-option", "kind", "lookback-configuration", "match-type", "name", "post-impression-activities-duration", "site-settings", "subaccount-id", "tag-setting", "value", "video-active-view-opt-out-template", "vpaid-adapter-choice-template"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Site = json::value::from_value(object).unwrap();
        let mut call = self.hub.sites().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _sites_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "approved" => Some(("approved", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "directory-site-id" => Some(("directorySiteId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.dimension-name" => Some(("directorySiteIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.etag" => Some(("directorySiteIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.id" => Some(("directorySiteIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.kind" => Some(("directorySiteIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.match-type" => Some(("directorySiteIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "directory-site-id-dimension-value.value" => Some(("directorySiteIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.dimension-name" => Some(("idDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.etag" => Some(("idDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.id" => Some(("idDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.kind" => Some(("idDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.match-type" => Some(("idDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "id-dimension-value.value" => Some(("idDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "key-name" => Some(("keyName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.active-view-opt-out" => Some(("siteSettings.activeViewOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.ad-blocking-opt-out" => Some(("siteSettings.adBlockingOptOut", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.creative-settings.i-frame-footer" => Some(("siteSettings.creativeSettings.iFrameFooter", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.creative-settings.i-frame-header" => Some(("siteSettings.creativeSettings.iFrameHeader", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.disable-new-cookie" => Some(("siteSettings.disableNewCookie", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.lookback-configuration.click-duration" => Some(("siteSettings.lookbackConfiguration.clickDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "site-settings.lookback-configuration.post-impression-activities-duration" => Some(("siteSettings.lookbackConfiguration.postImpressionActivitiesDuration", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "site-settings.tag-setting.additional-key-values" => Some(("siteSettings.tagSetting.additionalKeyValues", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.tag-setting.include-click-through-urls" => Some(("siteSettings.tagSetting.includeClickThroughUrls", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.tag-setting.include-click-tracking" => Some(("siteSettings.tagSetting.includeClickTracking", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.tag-setting.keyword-option" => Some(("siteSettings.tagSetting.keywordOption", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "site-settings.video-active-view-opt-out-template" => Some(("siteSettings.videoActiveViewOptOutTemplate", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "site-settings.vpaid-adapter-choice-template" => Some(("siteSettings.vpaidAdapterChoiceTemplate", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "active-view-opt-out", "ad-blocking-opt-out", "additional-key-values", "approved", "click-duration", "creative-settings", "dimension-name", "directory-site-id", "directory-site-id-dimension-value", "disable-new-cookie", "etag", "i-frame-footer", "i-frame-header", "id", "id-dimension-value", "include-click-through-urls", "include-click-tracking", "key-name", "keyword-option", "kind", "lookback-configuration", "match-type", "name", "post-impression-activities-duration", "site-settings", "subaccount-id", "tag-setting", "value", "video-active-view-opt-out-template", "vpaid-adapter-choice-template"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Site = json::value::from_value(object).unwrap();
        let mut call = self.hub.sites().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _sizes_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.sizes().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _sizes_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "height" => Some(("height", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    "iab" => Some(("iab", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "width" => Some(("width", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["height", "iab", "id", "kind", "width"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Size = json::value::from_value(object).unwrap();
        let mut call = self.hub.sizes().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _sizes_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.sizes().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "width" => {
                    call = call.width(        value.map(|v| arg_from_str(v, err, "width", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "iab-standard" => {
                    call = call.iab_standard(        value.map(|v| arg_from_str(v, err, "iab-standard", "boolean")).unwrap_or(false));
                },
                "height" => {
                    call = call.height(        value.map(|v| arg_from_str(v, err, "height", "int32")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["height", "iab-standard", "ids", "width"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _subaccounts_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.subaccounts().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _subaccounts_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "available-permission-ids" => Some(("availablePermissionIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "available-permission-ids", "id", "kind", "name"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Subaccount = json::value::from_value(object).unwrap();
        let mut call = self.hub.subaccounts().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _subaccounts_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.subaccounts().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["ids", "max-results", "page-token", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _subaccounts_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "available-permission-ids" => Some(("availablePermissionIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "available-permission-ids", "id", "kind", "name"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Subaccount = json::value::from_value(object).unwrap();
        let mut call = self.hub.subaccounts().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _subaccounts_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "available-permission-ids" => Some(("availablePermissionIds", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "available-permission-ids", "id", "kind", "name"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::Subaccount = json::value::from_value(object).unwrap();
        let mut call = self.hub.subaccounts().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _targetable_remarketing_lists_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.targetable_remarketing_lists().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _targetable_remarketing_lists_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.targetable_remarketing_lists().list(opt.value_of("profile-id").unwrap_or(""), opt.value_of("advertiser-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "name" => {
                    call = call.name(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "active" => {
                    call = call.active(        value.map(|v| arg_from_str(v, err, "active", "boolean")).unwrap_or(false));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["active", "max-results", "name", "page-token", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _targeting_templates_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.targeting_templates().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _targeting_templates_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "day-part-targeting.days-of-week" => Some(("dayPartTargeting.daysOfWeek", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "day-part-targeting.hours-of-day" => Some(("dayPartTargeting.hoursOfDay", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Vec })),
                    "day-part-targeting.user-local-time" => Some(("dayPartTargeting.userLocalTime", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "geo-targeting.exclude-countries" => Some(("geoTargeting.excludeCountries", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "key-value-targeting-expression.expression" => Some(("keyValueTargetingExpression.expression", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-targeting-expression.expression" => Some(("listTargetingExpression.expression", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "day-part-targeting", "days-of-week", "dimension-name", "etag", "exclude-countries", "expression", "geo-targeting", "hours-of-day", "id", "key-value-targeting-expression", "kind", "list-targeting-expression", "match-type", "name", "subaccount-id", "user-local-time", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::TargetingTemplate = json::value::from_value(object).unwrap();
        let mut call = self.hub.targeting_templates().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _targeting_templates_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.targeting_templates().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "advertiser-id" => {
                    call = call.advertiser_id(        value.map(|v| arg_from_str(v, err, "advertiser-id", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["advertiser-id", "ids", "max-results", "page-token", "search-string", "sort-field", "sort-order"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _targeting_templates_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "day-part-targeting.days-of-week" => Some(("dayPartTargeting.daysOfWeek", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "day-part-targeting.hours-of-day" => Some(("dayPartTargeting.hoursOfDay", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Vec })),
                    "day-part-targeting.user-local-time" => Some(("dayPartTargeting.userLocalTime", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "geo-targeting.exclude-countries" => Some(("geoTargeting.excludeCountries", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "key-value-targeting-expression.expression" => Some(("keyValueTargetingExpression.expression", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-targeting-expression.expression" => Some(("listTargetingExpression.expression", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "day-part-targeting", "days-of-week", "dimension-name", "etag", "exclude-countries", "expression", "geo-targeting", "hours-of-day", "id", "key-value-targeting-expression", "kind", "list-targeting-expression", "match-type", "name", "subaccount-id", "user-local-time", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::TargetingTemplate = json::value::from_value(object).unwrap();
        let mut call = self.hub.targeting_templates().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _targeting_templates_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id" => Some(("advertiserId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.dimension-name" => Some(("advertiserIdDimensionValue.dimensionName", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.etag" => Some(("advertiserIdDimensionValue.etag", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.id" => Some(("advertiserIdDimensionValue.id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.kind" => Some(("advertiserIdDimensionValue.kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.match-type" => Some(("advertiserIdDimensionValue.matchType", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "advertiser-id-dimension-value.value" => Some(("advertiserIdDimensionValue.value", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "day-part-targeting.days-of-week" => Some(("dayPartTargeting.daysOfWeek", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Vec })),
                    "day-part-targeting.hours-of-day" => Some(("dayPartTargeting.hoursOfDay", JsonTypeInfo { jtype: JsonType::Int, ctype: ComplexType::Vec })),
                    "day-part-targeting.user-local-time" => Some(("dayPartTargeting.userLocalTime", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "geo-targeting.exclude-countries" => Some(("geoTargeting.excludeCountries", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "key-value-targeting-expression.expression" => Some(("keyValueTargetingExpression.expression", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "list-targeting-expression.expression" => Some(("listTargetingExpression.expression", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "advertiser-id", "advertiser-id-dimension-value", "day-part-targeting", "days-of-week", "dimension-name", "etag", "exclude-countries", "expression", "geo-targeting", "hours-of-day", "id", "key-value-targeting-expression", "kind", "list-targeting-expression", "match-type", "name", "subaccount-id", "user-local-time", "value"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::TargetingTemplate = json::value::from_value(object).unwrap();
        let mut call = self.hub.targeting_templates().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _user_profiles_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.user_profiles().get(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _user_profiles_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.user_profiles().list();
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _user_role_permission_groups_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.user_role_permission_groups().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _user_role_permission_groups_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.user_role_permission_groups().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _user_role_permissions_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.user_role_permissions().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _user_role_permissions_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.user_role_permissions().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["ids"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _user_roles_delete(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.user_roles().delete(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok(mut response) => {
                    Ok(())
                }
            }
        }
    }

    async fn _user_roles_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.user_roles().get(opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _user_roles_insert(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-user-role" => Some(("defaultUserRole", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "parent-user-role-id" => Some(("parentUserRoleId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "default-user-role", "id", "kind", "name", "parent-user-role-id", "subaccount-id"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::UserRole = json::value::from_value(object).unwrap();
        let mut call = self.hub.user_roles().insert(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _user_roles_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.user_roles().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                "subaccount-id" => {
                    call = call.subaccount_id(        value.map(|v| arg_from_str(v, err, "subaccount-id", "int64")).unwrap_or(-0));
                },
                "sort-order" => {
                    call = call.sort_order(value.unwrap_or(""));
                },
                "sort-field" => {
                    call = call.sort_field(value.unwrap_or(""));
                },
                "search-string" => {
                    call = call.search_string(value.unwrap_or(""));
                },
                "page-token" => {
                    call = call.page_token(value.unwrap_or(""));
                },
                "max-results" => {
                    call = call.max_results(        value.map(|v| arg_from_str(v, err, "max-results", "int32")).unwrap_or(-0));
                },
                "ids" => {
                    call = call.add_ids(        value.map(|v| arg_from_str(v, err, "ids", "int64")).unwrap_or(-0));
                },
                "account-user-role-only" => {
                    call = call.account_user_role_only(        value.map(|v| arg_from_str(v, err, "account-user-role-only", "boolean")).unwrap_or(false));
                },
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v.extend(["account-user-role-only", "ids", "max-results", "page-token", "search-string", "sort-field", "sort-order", "subaccount-id"].iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _user_roles_patch(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-user-role" => Some(("defaultUserRole", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "parent-user-role-id" => Some(("parentUserRoleId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "default-user-role", "id", "kind", "name", "parent-user-role-id", "subaccount-id"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::UserRole = json::value::from_value(object).unwrap();
        let mut call = self.hub.user_roles().patch(request, opt.value_of("profile-id").unwrap_or(""), opt.value_of("id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _user_roles_update(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        
        let mut field_cursor = FieldCursor::default();
        let mut object = json::value::Value::Object(Default::default());
        
        for kvarg in opt.values_of("kv").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let last_errc = err.issues.len();
            let (key, value) = parse_kv_arg(&*kvarg, err, false);
            let mut temp_cursor = field_cursor.clone();
            if let Err(field_err) = temp_cursor.set(&*key) {
                err.issues.push(field_err);
            }
            if value.is_none() {
                field_cursor = temp_cursor.clone();
                if err.issues.len() > last_errc {
                    err.issues.remove(last_errc);
                }
                continue;
            }
        
            let type_info: Option<(&'static str, JsonTypeInfo)> =
                match &temp_cursor.to_string()[..] {
                    "account-id" => Some(("accountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "default-user-role" => Some(("defaultUserRole", JsonTypeInfo { jtype: JsonType::Boolean, ctype: ComplexType::Pod })),
                    "id" => Some(("id", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "kind" => Some(("kind", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "name" => Some(("name", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "parent-user-role-id" => Some(("parentUserRoleId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    "subaccount-id" => Some(("subaccountId", JsonTypeInfo { jtype: JsonType::String, ctype: ComplexType::Pod })),
                    _ => {
                        let suggestion = FieldCursor::did_you_mean(key, &vec!["account-id", "default-user-role", "id", "kind", "name", "parent-user-role-id", "subaccount-id"]);
                        err.issues.push(CLIError::Field(FieldError::Unknown(temp_cursor.to_string(), suggestion, value.map(|v| v.to_string()))));
                        None
                    }
                };
            if let Some((field_cursor_str, type_info)) = type_info {
                FieldCursor::from(field_cursor_str).set_json_value(&mut object, value.unwrap(), type_info, err, &temp_cursor);
            }
        }
        let mut request: api::UserRole = json::value::from_value(object).unwrap();
        let mut call = self.hub.user_roles().update(request, opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _video_formats_get(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let id: i32 = arg_from_str(&opt.value_of("id").unwrap_or(""), err, "<id>", "integer");
        let mut call = self.hub.video_formats().get(opt.value_of("profile-id").unwrap_or(""), id);
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _video_formats_list(&self, opt: &ArgMatches<'n>, dry_run: bool, err: &mut InvalidOptionsError)
                                                    -> Result<(), DoitError> {
        let mut call = self.hub.video_formats().list(opt.value_of("profile-id").unwrap_or(""));
        for parg in opt.values_of("v").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
            let (key, value) = parse_kv_arg(&*parg, err, false);
            match key {
                _ => {
                    let mut found = false;
                    for param in &self.gp {
                        if key == *param {
                            found = true;
                            call = call.param(self.gpm.iter().find(|t| t.0 == key).unwrap_or(&("", key)).1, value.unwrap_or("unset"));
                            break;
                        }
                    }
                    if !found {
                        err.issues.push(CLIError::UnknownParameter(key.to_string(),
                                                                  {let mut v = Vec::new();
                                                                           v.extend(self.gp.iter().map(|v|*v));
                                                                           v } ));
                    }
                }
            }
        }
        let protocol = CallType::Standard;
        if dry_run {
            Ok(())
        } else {
            assert!(err.issues.len() == 0);
            for scope in self.opt.values_of("url").map(|i|i.collect()).unwrap_or(Vec::new()).iter() {
                call = call.add_scope(scope);
            }
            let mut ostream = match writer_from_opts(opt.value_of("out")) {
                Ok(mut f) => f,
                Err(io_err) => return Err(DoitError::IoError(opt.value_of("out").unwrap_or("-").to_string(), io_err)),
            };
            match match protocol {
                CallType::Standard => call.doit().await,
                _ => unreachable!()
            } {
                Err(api_err) => Err(DoitError::ApiError(api_err)),
                Ok((mut response, output_schema)) => {
                    let mut value = json::value::to_value(&output_schema).expect("serde to work");
                    remove_json_null_values(&mut value);
                    json::to_writer_pretty(&mut ostream, &value).unwrap();
                    ostream.flush().unwrap();
                    Ok(())
                }
            }
        }
    }

    async fn _doit(&self, dry_run: bool) -> Result<Result<(), DoitError>, Option<InvalidOptionsError>> {
        let mut err = InvalidOptionsError::new();
        let mut call_result: Result<(), DoitError> = Ok(());
        let mut err_opt: Option<InvalidOptionsError> = None;
        match self.opt.subcommand() {
            ("account-active-ad-summaries", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._account_active_ad_summaries_get(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("account-active-ad-summaries".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("account-permission-groups", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._account_permission_groups_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._account_permission_groups_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("account-permission-groups".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("account-permissions", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._account_permissions_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._account_permissions_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("account-permissions".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("account-user-profiles", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._account_user_profiles_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._account_user_profiles_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._account_user_profiles_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._account_user_profiles_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._account_user_profiles_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("account-user-profiles".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("accounts", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._accounts_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._accounts_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._accounts_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._accounts_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("accounts".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("ads", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._ads_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._ads_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._ads_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._ads_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._ads_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("ads".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("advertiser-groups", Some(opt)) => {
                match opt.subcommand() {
                    ("delete", Some(opt)) => {
                        call_result = self._advertiser_groups_delete(opt, dry_run, &mut err).await;
                    },
                    ("get", Some(opt)) => {
                        call_result = self._advertiser_groups_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._advertiser_groups_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._advertiser_groups_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._advertiser_groups_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._advertiser_groups_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("advertiser-groups".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("advertisers", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._advertisers_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._advertisers_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._advertisers_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._advertisers_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._advertisers_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("advertisers".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("browsers", Some(opt)) => {
                match opt.subcommand() {
                    ("list", Some(opt)) => {
                        call_result = self._browsers_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("browsers".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("campaign-creative-associations", Some(opt)) => {
                match opt.subcommand() {
                    ("insert", Some(opt)) => {
                        call_result = self._campaign_creative_associations_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._campaign_creative_associations_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("campaign-creative-associations".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("campaigns", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._campaigns_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._campaigns_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._campaigns_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._campaigns_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._campaigns_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("campaigns".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("change-logs", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._change_logs_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._change_logs_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("change-logs".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("cities", Some(opt)) => {
                match opt.subcommand() {
                    ("list", Some(opt)) => {
                        call_result = self._cities_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("cities".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("connection-types", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._connection_types_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._connection_types_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("connection-types".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("content-categories", Some(opt)) => {
                match opt.subcommand() {
                    ("delete", Some(opt)) => {
                        call_result = self._content_categories_delete(opt, dry_run, &mut err).await;
                    },
                    ("get", Some(opt)) => {
                        call_result = self._content_categories_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._content_categories_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._content_categories_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._content_categories_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._content_categories_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("content-categories".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("conversions", Some(opt)) => {
                match opt.subcommand() {
                    ("batchinsert", Some(opt)) => {
                        call_result = self._conversions_batchinsert(opt, dry_run, &mut err).await;
                    },
                    ("batchupdate", Some(opt)) => {
                        call_result = self._conversions_batchupdate(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("conversions".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("countries", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._countries_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._countries_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("countries".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("creative-assets", Some(opt)) => {
                match opt.subcommand() {
                    ("insert", Some(opt)) => {
                        call_result = self._creative_assets_insert(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("creative-assets".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("creative-field-values", Some(opt)) => {
                match opt.subcommand() {
                    ("delete", Some(opt)) => {
                        call_result = self._creative_field_values_delete(opt, dry_run, &mut err).await;
                    },
                    ("get", Some(opt)) => {
                        call_result = self._creative_field_values_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._creative_field_values_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._creative_field_values_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._creative_field_values_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._creative_field_values_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("creative-field-values".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("creative-fields", Some(opt)) => {
                match opt.subcommand() {
                    ("delete", Some(opt)) => {
                        call_result = self._creative_fields_delete(opt, dry_run, &mut err).await;
                    },
                    ("get", Some(opt)) => {
                        call_result = self._creative_fields_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._creative_fields_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._creative_fields_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._creative_fields_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._creative_fields_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("creative-fields".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("creative-groups", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._creative_groups_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._creative_groups_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._creative_groups_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._creative_groups_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._creative_groups_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("creative-groups".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("creatives", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._creatives_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._creatives_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._creatives_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._creatives_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._creatives_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("creatives".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("dimension-values", Some(opt)) => {
                match opt.subcommand() {
                    ("query", Some(opt)) => {
                        call_result = self._dimension_values_query(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("dimension-values".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("directory-site-contacts", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._directory_site_contacts_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._directory_site_contacts_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("directory-site-contacts".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("directory-sites", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._directory_sites_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._directory_sites_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._directory_sites_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("directory-sites".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("dynamic-targeting-keys", Some(opt)) => {
                match opt.subcommand() {
                    ("delete", Some(opt)) => {
                        call_result = self._dynamic_targeting_keys_delete(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._dynamic_targeting_keys_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._dynamic_targeting_keys_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("dynamic-targeting-keys".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("event-tags", Some(opt)) => {
                match opt.subcommand() {
                    ("delete", Some(opt)) => {
                        call_result = self._event_tags_delete(opt, dry_run, &mut err).await;
                    },
                    ("get", Some(opt)) => {
                        call_result = self._event_tags_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._event_tags_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._event_tags_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._event_tags_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._event_tags_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("event-tags".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("files", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._files_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._files_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("files".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("floodlight-activities", Some(opt)) => {
                match opt.subcommand() {
                    ("delete", Some(opt)) => {
                        call_result = self._floodlight_activities_delete(opt, dry_run, &mut err).await;
                    },
                    ("generatetag", Some(opt)) => {
                        call_result = self._floodlight_activities_generatetag(opt, dry_run, &mut err).await;
                    },
                    ("get", Some(opt)) => {
                        call_result = self._floodlight_activities_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._floodlight_activities_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._floodlight_activities_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._floodlight_activities_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._floodlight_activities_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("floodlight-activities".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("floodlight-activity-groups", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._floodlight_activity_groups_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._floodlight_activity_groups_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._floodlight_activity_groups_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._floodlight_activity_groups_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._floodlight_activity_groups_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("floodlight-activity-groups".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("floodlight-configurations", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._floodlight_configurations_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._floodlight_configurations_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._floodlight_configurations_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._floodlight_configurations_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("floodlight-configurations".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("inventory-items", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._inventory_items_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._inventory_items_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("inventory-items".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("landing-pages", Some(opt)) => {
                match opt.subcommand() {
                    ("delete", Some(opt)) => {
                        call_result = self._landing_pages_delete(opt, dry_run, &mut err).await;
                    },
                    ("get", Some(opt)) => {
                        call_result = self._landing_pages_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._landing_pages_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._landing_pages_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._landing_pages_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._landing_pages_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("landing-pages".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("languages", Some(opt)) => {
                match opt.subcommand() {
                    ("list", Some(opt)) => {
                        call_result = self._languages_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("languages".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("metros", Some(opt)) => {
                match opt.subcommand() {
                    ("list", Some(opt)) => {
                        call_result = self._metros_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("metros".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("mobile-carriers", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._mobile_carriers_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._mobile_carriers_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("mobile-carriers".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("operating-system-versions", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._operating_system_versions_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._operating_system_versions_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("operating-system-versions".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("operating-systems", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._operating_systems_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._operating_systems_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("operating-systems".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("order-documents", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._order_documents_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._order_documents_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("order-documents".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("orders", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._orders_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._orders_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("orders".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("placement-groups", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._placement_groups_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._placement_groups_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._placement_groups_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._placement_groups_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._placement_groups_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("placement-groups".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("placement-strategies", Some(opt)) => {
                match opt.subcommand() {
                    ("delete", Some(opt)) => {
                        call_result = self._placement_strategies_delete(opt, dry_run, &mut err).await;
                    },
                    ("get", Some(opt)) => {
                        call_result = self._placement_strategies_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._placement_strategies_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._placement_strategies_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._placement_strategies_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._placement_strategies_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("placement-strategies".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("placements", Some(opt)) => {
                match opt.subcommand() {
                    ("generatetags", Some(opt)) => {
                        call_result = self._placements_generatetags(opt, dry_run, &mut err).await;
                    },
                    ("get", Some(opt)) => {
                        call_result = self._placements_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._placements_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._placements_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._placements_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._placements_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("placements".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("platform-types", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._platform_types_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._platform_types_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("platform-types".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("postal-codes", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._postal_codes_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._postal_codes_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("postal-codes".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("projects", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._projects_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._projects_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("projects".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("regions", Some(opt)) => {
                match opt.subcommand() {
                    ("list", Some(opt)) => {
                        call_result = self._regions_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("regions".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("remarketing-list-shares", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._remarketing_list_shares_get(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._remarketing_list_shares_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._remarketing_list_shares_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("remarketing-list-shares".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("remarketing-lists", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._remarketing_lists_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._remarketing_lists_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._remarketing_lists_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._remarketing_lists_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._remarketing_lists_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("remarketing-lists".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("reports", Some(opt)) => {
                match opt.subcommand() {
                    ("compatible-fields-query", Some(opt)) => {
                        call_result = self._reports_compatible_fields_query(opt, dry_run, &mut err).await;
                    },
                    ("delete", Some(opt)) => {
                        call_result = self._reports_delete(opt, dry_run, &mut err).await;
                    },
                    ("files-get", Some(opt)) => {
                        call_result = self._reports_files_get(opt, dry_run, &mut err).await;
                    },
                    ("files-list", Some(opt)) => {
                        call_result = self._reports_files_list(opt, dry_run, &mut err).await;
                    },
                    ("get", Some(opt)) => {
                        call_result = self._reports_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._reports_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._reports_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._reports_patch(opt, dry_run, &mut err).await;
                    },
                    ("run", Some(opt)) => {
                        call_result = self._reports_run(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._reports_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("reports".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("sites", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._sites_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._sites_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._sites_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._sites_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._sites_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("sites".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("sizes", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._sizes_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._sizes_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._sizes_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("sizes".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("subaccounts", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._subaccounts_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._subaccounts_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._subaccounts_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._subaccounts_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._subaccounts_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("subaccounts".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("targetable-remarketing-lists", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._targetable_remarketing_lists_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._targetable_remarketing_lists_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("targetable-remarketing-lists".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("targeting-templates", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._targeting_templates_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._targeting_templates_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._targeting_templates_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._targeting_templates_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._targeting_templates_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("targeting-templates".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("user-profiles", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._user_profiles_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._user_profiles_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("user-profiles".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("user-role-permission-groups", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._user_role_permission_groups_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._user_role_permission_groups_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("user-role-permission-groups".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("user-role-permissions", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._user_role_permissions_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._user_role_permissions_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("user-role-permissions".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("user-roles", Some(opt)) => {
                match opt.subcommand() {
                    ("delete", Some(opt)) => {
                        call_result = self._user_roles_delete(opt, dry_run, &mut err).await;
                    },
                    ("get", Some(opt)) => {
                        call_result = self._user_roles_get(opt, dry_run, &mut err).await;
                    },
                    ("insert", Some(opt)) => {
                        call_result = self._user_roles_insert(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._user_roles_list(opt, dry_run, &mut err).await;
                    },
                    ("patch", Some(opt)) => {
                        call_result = self._user_roles_patch(opt, dry_run, &mut err).await;
                    },
                    ("update", Some(opt)) => {
                        call_result = self._user_roles_update(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("user-roles".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            ("video-formats", Some(opt)) => {
                match opt.subcommand() {
                    ("get", Some(opt)) => {
                        call_result = self._video_formats_get(opt, dry_run, &mut err).await;
                    },
                    ("list", Some(opt)) => {
                        call_result = self._video_formats_list(opt, dry_run, &mut err).await;
                    },
                    _ => {
                        err.issues.push(CLIError::MissingMethodError("video-formats".to_string()));
                        writeln!(io::stderr(), "{}\n", opt.usage()).ok();
                    }
                }
            },
            _ => {
                err.issues.push(CLIError::MissingCommandError);
                writeln!(io::stderr(), "{}\n", self.opt.usage()).ok();
            }
        }

        if dry_run {
            if err.issues.len() > 0 {
                err_opt = Some(err);
            }
            Err(err_opt)
        } else {
            Ok(call_result)
        }
    }

    // Please note that this call will fail if any part of the opt can't be handled
    async fn new(opt: ArgMatches<'n>, connector: S) -> Result<Engine<'n, S>, InvalidOptionsError> {
        let (config_dir, secret) = {
            let config_dir = match client::assure_config_dir_exists(opt.value_of("folder").unwrap_or("~/.google-service-cli")) {
                Err(e) => return Err(InvalidOptionsError::single(e, 3)),
                Ok(p) => p,
            };

            match client::application_secret_from_directory(&config_dir, "dfareporting2d8-secret.json",
                                                         "{\"installed\":{\"auth_uri\":\"https://accounts.google.com/o/oauth2/auth\",\"client_secret\":\"hCsslbCUyfehWMmbkG8vTYxG\",\"token_uri\":\"https://accounts.google.com/o/oauth2/token\",\"client_email\":\"\",\"redirect_uris\":[\"urn:ietf:wg:oauth:2.0:oob\",\"oob\"],\"client_x509_cert_url\":\"\",\"client_id\":\"620010449518-9ngf7o4dhs0dka470npqvor6dc5lqb9b.apps.googleusercontent.com\",\"auth_provider_x509_cert_url\":\"https://www.googleapis.com/oauth2/v1/certs\"}}") {
                Ok(secret) => (config_dir, secret),
                Err(e) => return Err(InvalidOptionsError::single(e, 4))
            }
        };

        let client = hyper::Client::builder().build(connector);

        let auth = oauth2::InstalledFlowAuthenticator::with_client(
            secret,
            oauth2::InstalledFlowReturnMethod::HTTPRedirect,
            client.clone(),
        ).persist_tokens_to_disk(format!("{}/dfareporting2d8", config_dir)).build().await.unwrap();

        let engine = Engine {
            opt: opt,
            hub: api::Dfareporting::new(client, auth),
            gp: vec!["alt", "fields", "key", "oauth-token", "pretty-print", "quota-user", "user-ip"],
            gpm: vec![
                    ("oauth-token", "oauth_token"),
                    ("pretty-print", "prettyPrint"),
                    ("quota-user", "quotaUser"),
                    ("user-ip", "userIp"),
                ]
        };

        match engine._doit(true).await {
            Err(Some(err)) => Err(err),
            Err(None)      => Ok(engine),
            Ok(_)          => unreachable!(),
        }
    }

    async fn doit(&self) -> Result<(), DoitError> {
        match self._doit(false).await {
            Ok(res) => res,
            Err(_) => unreachable!(),
        }
    }
}

#[tokio::main]
async fn main() {
    let mut exit_status = 0i32;
    let upload_value_names = ["mode", "file"];
    let arg_data = [
        ("account-active-ad-summaries", "methods: 'get'", vec![
            ("get",
                    Some(r##"Gets the account's active ad summary by account ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/account-active-ad-summaries_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"summary-account-id"##),
                     None,
                     Some(r##"Account ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("account-permission-groups", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one account permission group by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/account-permission-groups_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Account permission group ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves the list of account permission groups."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/account-permission-groups_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("account-permissions", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one account permission by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/account-permissions_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Account permission ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves the list of account permissions."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/account-permissions_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("account-user-profiles", "methods: 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one account user profile by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/account-user-profiles_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"User profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new account user profile."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/account-user-profiles_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of account user profiles, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/account-user-profiles_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing account user profile. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/account-user-profiles_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"User profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing account user profile."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/account-user-profiles_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("accounts", "methods: 'get', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one account by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/accounts_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Account ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves the list of accounts, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/accounts_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing account. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/accounts_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Account ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing account."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/accounts_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("ads", "methods: 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one ad by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/ads_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Ad ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new ad."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/ads_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of ads, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/ads_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing ad. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/ads_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Ad ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing ad."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/ads_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("advertiser-groups", "methods: 'delete', 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("delete",
                    Some(r##"Deletes an existing advertiser group."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/advertiser-groups_delete",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Advertiser group ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
                  ]),
            ("get",
                    Some(r##"Gets one advertiser group by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/advertiser-groups_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Advertiser group ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new advertiser group."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/advertiser-groups_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of advertiser groups, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/advertiser-groups_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing advertiser group. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/advertiser-groups_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Advertiser group ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing advertiser group."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/advertiser-groups_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("advertisers", "methods: 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one advertiser by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/advertisers_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Advertiser ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new advertiser."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/advertisers_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of advertisers, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/advertisers_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing advertiser. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/advertisers_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Advertiser ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing advertiser."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/advertisers_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("browsers", "methods: 'list'", vec![
            ("list",
                    Some(r##"Retrieves a list of browsers."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/browsers_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("campaign-creative-associations", "methods: 'insert' and 'list'", vec![
            ("insert",
                    Some(r##"Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/campaign-creative-associations_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"campaign-id"##),
                     None,
                     Some(r##"Campaign ID in this association."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves the list of creative IDs associated with the specified campaign. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/campaign-creative-associations_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"campaign-id"##),
                     None,
                     Some(r##"Campaign ID in this association."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("campaigns", "methods: 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one campaign by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/campaigns_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Campaign ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new campaign."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/campaigns_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"default-landing-page-name"##),
                     None,
                     Some(r##"Default landing page name for this new campaign. Must be less than 256 characters long."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"default-landing-page-url"##),
                     None,
                     Some(r##"Default landing page URL for this new campaign."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of campaigns, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/campaigns_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing campaign. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/campaigns_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Campaign ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing campaign."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/campaigns_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("change-logs", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one change log by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/change-logs_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Change log ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of change logs. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/change-logs_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("cities", "methods: 'list'", vec![
            ("list",
                    Some(r##"Retrieves a list of cities, possibly filtered."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/cities_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("connection-types", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one connection type by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/connection-types_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Connection type ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of connection types."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/connection-types_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("content-categories", "methods: 'delete', 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("delete",
                    Some(r##"Deletes an existing content category."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/content-categories_delete",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Content category ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
                  ]),
            ("get",
                    Some(r##"Gets one content category by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/content-categories_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Content category ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new content category."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/content-categories_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of content categories, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/content-categories_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing content category. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/content-categories_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Content category ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing content category."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/content-categories_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("conversions", "methods: 'batchinsert' and 'batchupdate'", vec![
            ("batchinsert",
                    Some(r##"Inserts conversions."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/conversions_batchinsert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("batchupdate",
                    Some(r##"Updates existing conversions."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/conversions_batchupdate",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("countries", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one country by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/countries_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"dart-id"##),
                     None,
                     Some(r##"Country DART ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of countries."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/countries_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("creative-assets", "methods: 'insert'", vec![
            ("insert",
                    Some(r##"Inserts a new creative asset."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-assets_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"advertiser-id"##),
                     None,
                     Some(r##"Advertiser ID of this creative. This is a required field."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"mode"##),
                     Some(r##"u"##),
                     Some(r##"Specify the upload protocol (simple) and the file to upload"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("creative-field-values", "methods: 'delete', 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("delete",
                    Some(r##"Deletes an existing creative field value."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-field-values_delete",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"creative-field-id"##),
                     None,
                     Some(r##"Creative field ID for this creative field value."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Creative Field Value ID"##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
                  ]),
            ("get",
                    Some(r##"Gets one creative field value by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-field-values_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"creative-field-id"##),
                     None,
                     Some(r##"Creative field ID for this creative field value."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Creative Field Value ID"##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new creative field value."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-field-values_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"creative-field-id"##),
                     None,
                     Some(r##"Creative field ID for this creative field value."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of creative field values, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-field-values_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"creative-field-id"##),
                     None,
                     Some(r##"Creative field ID for this creative field value."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing creative field value. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-field-values_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"creative-field-id"##),
                     None,
                     Some(r##"Creative field ID for this creative field value."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Creative Field Value ID"##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing creative field value."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-field-values_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"creative-field-id"##),
                     None,
                     Some(r##"Creative field ID for this creative field value."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("creative-fields", "methods: 'delete', 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("delete",
                    Some(r##"Deletes an existing creative field."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-fields_delete",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Creative Field ID"##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
                  ]),
            ("get",
                    Some(r##"Gets one creative field by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-fields_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Creative Field ID"##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new creative field."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-fields_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of creative fields, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-fields_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing creative field. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-fields_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Creative Field ID"##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing creative field."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-fields_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("creative-groups", "methods: 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one creative group by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-groups_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Creative group ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new creative group."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-groups_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of creative groups, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-groups_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing creative group. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-groups_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Creative group ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing creative group."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creative-groups_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("creatives", "methods: 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one creative by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creatives_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Creative ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new creative."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creatives_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of creatives, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creatives_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing creative. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creatives_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Creative ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing creative."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/creatives_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("dimension-values", "methods: 'query'", vec![
            ("query",
                    Some(r##"Retrieves list of report dimension values for a list of filters."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/dimension-values_query",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The DFA user profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("directory-site-contacts", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one directory site contact by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/directory-site-contacts_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Directory site contact ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of directory site contacts, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/directory-site-contacts_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("directory-sites", "methods: 'get', 'insert' and 'list'", vec![
            ("get",
                    Some(r##"Gets one directory site by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/directory-sites_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Directory site ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new directory site."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/directory-sites_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of directory sites, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/directory-sites_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("dynamic-targeting-keys", "methods: 'delete', 'insert' and 'list'", vec![
            ("delete",
                    Some(r##"Deletes an existing dynamic targeting key."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/dynamic-targeting-keys_delete",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"object-id"##),
                     None,
                     Some(r##"ID of the object of this dynamic targeting key. This is a required field."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"name"##),
                     None,
                     Some(r##"Name of this dynamic targeting key. This is a required field. Must be less than 256 characters long and cannot contain commas. All characters are converted to lowercase."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"object-type"##),
                     None,
                     Some(r##"Type of the object of this dynamic targeting key. This is a required field."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/dynamic-targeting-keys_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of dynamic targeting keys."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/dynamic-targeting-keys_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("event-tags", "methods: 'delete', 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("delete",
                    Some(r##"Deletes an existing event tag."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/event-tags_delete",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Event tag ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
                  ]),
            ("get",
                    Some(r##"Gets one event tag by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/event-tags_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Event tag ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new event tag."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/event-tags_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of event tags, possibly filtered."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/event-tags_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing event tag. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/event-tags_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Event tag ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing event tag."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/event-tags_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("files", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Retrieves a report file by its report ID and file ID. This method supports media download."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/files_get",
                  vec![
                    (Some(r##"report-id"##),
                     None,
                     Some(r##"The ID of the report."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"file-id"##),
                     None,
                     Some(r##"The ID of the report file."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Lists files for a user profile."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/files_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The DFA profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("floodlight-activities", "methods: 'delete', 'generatetag', 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("delete",
                    Some(r##"Deletes an existing floodlight activity."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-activities_delete",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Floodlight activity ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
                  ]),
            ("generatetag",
                    Some(r##"Generates a tag for a floodlight activity."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-activities_generatetag",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("get",
                    Some(r##"Gets one floodlight activity by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-activities_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Floodlight activity ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new floodlight activity."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-activities_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of floodlight activities, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-activities_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing floodlight activity. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-activities_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Floodlight activity ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing floodlight activity."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-activities_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("floodlight-activity-groups", "methods: 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one floodlight activity group by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-activity-groups_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Floodlight activity Group ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new floodlight activity group."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-activity-groups_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-activity-groups_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing floodlight activity group. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-activity-groups_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Floodlight activity Group ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing floodlight activity group."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-activity-groups_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("floodlight-configurations", "methods: 'get', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one floodlight configuration by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-configurations_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Floodlight configuration ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of floodlight configurations, possibly filtered."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-configurations_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing floodlight configuration. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-configurations_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Floodlight configuration ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing floodlight configuration."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/floodlight-configurations_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("inventory-items", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one inventory item by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/inventory-items_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"project-id"##),
                     None,
                     Some(r##"Project ID for order documents."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Inventory item ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of inventory items, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/inventory-items_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"project-id"##),
                     None,
                     Some(r##"Project ID for order documents."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("landing-pages", "methods: 'delete', 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("delete",
                    Some(r##"Deletes an existing campaign landing page."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/landing-pages_delete",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"campaign-id"##),
                     None,
                     Some(r##"Landing page campaign ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Landing page ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
                  ]),
            ("get",
                    Some(r##"Gets one campaign landing page by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/landing-pages_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"campaign-id"##),
                     None,
                     Some(r##"Landing page campaign ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Landing page ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new landing page for the specified campaign."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/landing-pages_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"campaign-id"##),
                     None,
                     Some(r##"Landing page campaign ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves the list of landing pages for the specified campaign."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/landing-pages_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"campaign-id"##),
                     None,
                     Some(r##"Landing page campaign ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing campaign landing page. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/landing-pages_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"campaign-id"##),
                     None,
                     Some(r##"Landing page campaign ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Landing page ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing campaign landing page."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/landing-pages_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"campaign-id"##),
                     None,
                     Some(r##"Landing page campaign ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("languages", "methods: 'list'", vec![
            ("list",
                    Some(r##"Retrieves a list of languages."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/languages_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("metros", "methods: 'list'", vec![
            ("list",
                    Some(r##"Retrieves a list of metros."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/metros_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("mobile-carriers", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one mobile carrier by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/mobile-carriers_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Mobile carrier ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of mobile carriers."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/mobile-carriers_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("operating-system-versions", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one operating system version by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/operating-system-versions_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Operating system version ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of operating system versions."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/operating-system-versions_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("operating-systems", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one operating system by DART ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/operating-systems_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"dart-id"##),
                     None,
                     Some(r##"Operating system DART ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of operating systems."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/operating-systems_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("order-documents", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one order document by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/order-documents_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"project-id"##),
                     None,
                     Some(r##"Project ID for order documents."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Order document ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of order documents, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/order-documents_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"project-id"##),
                     None,
                     Some(r##"Project ID for order documents."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("orders", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one order by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/orders_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"project-id"##),
                     None,
                     Some(r##"Project ID for orders."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Order ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of orders, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/orders_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"project-id"##),
                     None,
                     Some(r##"Project ID for orders."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("placement-groups", "methods: 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one placement group by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placement-groups_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Placement group ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new placement group."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placement-groups_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of placement groups, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placement-groups_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing placement group. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placement-groups_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Placement group ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing placement group."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placement-groups_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("placement-strategies", "methods: 'delete', 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("delete",
                    Some(r##"Deletes an existing placement strategy."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placement-strategies_delete",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Placement strategy ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
                  ]),
            ("get",
                    Some(r##"Gets one placement strategy by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placement-strategies_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Placement strategy ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new placement strategy."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placement-strategies_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of placement strategies, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placement-strategies_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing placement strategy. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placement-strategies_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Placement strategy ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing placement strategy."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placement-strategies_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("placements", "methods: 'generatetags', 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("generatetags",
                    Some(r##"Generates tags for a placement."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placements_generatetags",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("get",
                    Some(r##"Gets one placement by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placements_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Placement ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new placement."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placements_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of placements, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placements_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing placement. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placements_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Placement ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing placement."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/placements_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("platform-types", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one platform type by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/platform-types_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Platform type ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of platform types."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/platform-types_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("postal-codes", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one postal code by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/postal-codes_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"code"##),
                     None,
                     Some(r##"Postal code ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of postal codes."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/postal-codes_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("projects", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one project by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/projects_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Project ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of projects, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/projects_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("regions", "methods: 'list'", vec![
            ("list",
                    Some(r##"Retrieves a list of regions."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/regions_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("remarketing-list-shares", "methods: 'get', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one remarketing list share by remarketing list ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/remarketing-list-shares_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"remarketing-list-id"##),
                     None,
                     Some(r##"Remarketing list ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing remarketing list share. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/remarketing-list-shares_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"remarketing-list-id"##),
                     None,
                     Some(r##"Remarketing list ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing remarketing list share."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/remarketing-list-shares_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("remarketing-lists", "methods: 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one remarketing list by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/remarketing-lists_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Remarketing list ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new remarketing list."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/remarketing-lists_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of remarketing lists, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/remarketing-lists_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"advertiser-id"##),
                     None,
                     Some(r##"Select only remarketing lists owned by this advertiser."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing remarketing list. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/remarketing-lists_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Remarketing list ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing remarketing list."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/remarketing-lists_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("reports", "methods: 'compatible-fields-query', 'delete', 'files-get', 'files-list', 'get', 'insert', 'list', 'patch', 'run' and 'update'", vec![
            ("compatible-fields-query",
                    Some(r##"Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/reports_compatible-fields-query",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The DFA user profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("delete",
                    Some(r##"Deletes a report by its ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/reports_delete",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The DFA user profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"report-id"##),
                     None,
                     Some(r##"The ID of the report."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
                  ]),
            ("files-get",
                    Some(r##"Retrieves a report file. This method supports media download."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/reports_files-get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The DFA profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"report-id"##),
                     None,
                     Some(r##"The ID of the report."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"file-id"##),
                     None,
                     Some(r##"The ID of the report file."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("files-list",
                    Some(r##"Lists files for a report."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/reports_files-list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The DFA profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"report-id"##),
                     None,
                     Some(r##"The ID of the parent report."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("get",
                    Some(r##"Retrieves a report by its ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/reports_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The DFA user profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"report-id"##),
                     None,
                     Some(r##"The ID of the report."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Creates a report."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/reports_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The DFA user profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves list of reports."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/reports_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The DFA user profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates a report. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/reports_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The DFA user profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"report-id"##),
                     None,
                     Some(r##"The ID of the report."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("run",
                    Some(r##"Runs a report."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/reports_run",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The DFA profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"report-id"##),
                     None,
                     Some(r##"The ID of the report."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates a report."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/reports_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The DFA user profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"report-id"##),
                     None,
                     Some(r##"The ID of the report."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("sites", "methods: 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one site by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/sites_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Site ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new site."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/sites_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of sites, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/sites_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing site. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/sites_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Site ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing site."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/sites_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("sizes", "methods: 'get', 'insert' and 'list'", vec![
            ("get",
                    Some(r##"Gets one size by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/sizes_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Size ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new size."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/sizes_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of sizes, possibly filtered. Retrieved sizes are globally unique and may include values not currently in use by your account. Due to this, the list of sizes returned by this method may differ from the list seen in the Trafficking UI."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/sizes_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("subaccounts", "methods: 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one subaccount by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/subaccounts_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Subaccount ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new subaccount."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/subaccounts_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Gets a list of subaccounts, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/subaccounts_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing subaccount. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/subaccounts_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Subaccount ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing subaccount."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/subaccounts_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("targetable-remarketing-lists", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one remarketing list by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/targetable-remarketing-lists_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Remarketing list ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/targetable-remarketing-lists_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"advertiser-id"##),
                     None,
                     Some(r##"Select only targetable remarketing lists targetable by these advertisers."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("targeting-templates", "methods: 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("get",
                    Some(r##"Gets one targeting template by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/targeting-templates_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Targeting template ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new targeting template."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/targeting-templates_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of targeting templates, optionally filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/targeting-templates_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing targeting template. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/targeting-templates_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Targeting template ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing targeting template."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/targeting-templates_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("user-profiles", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one user profile by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/user-profiles_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"The user profile ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves list of user profiles for a user."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/user-profiles_list",
                  vec![
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("user-role-permission-groups", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one user role permission group by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/user-role-permission-groups_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"User role permission group ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Gets a list of all supported user role permission groups."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/user-role-permission-groups_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("user-role-permissions", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one user role permission by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/user-role-permissions_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"User role permission ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Gets a list of user role permissions, possibly filtered."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/user-role-permissions_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("user-roles", "methods: 'delete', 'get', 'insert', 'list', 'patch' and 'update'", vec![
            ("delete",
                    Some(r##"Deletes an existing user role."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/user-roles_delete",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"User role ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
                  ]),
            ("get",
                    Some(r##"Gets one user role by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/user-roles_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"User role ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("insert",
                    Some(r##"Inserts a new user role."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/user-roles_insert",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Retrieves a list of user roles, possibly filtered. This method supports paging."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/user-roles_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("patch",
                    Some(r##"Updates an existing user role. This method supports patch semantics."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/user-roles_patch",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"User role ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("update",
                    Some(r##"Updates an existing user role."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/user-roles_update",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"kv"##),
                     Some(r##"r"##),
                     Some(r##"Set various fields of the request structure, matching the key=value form"##),
                     Some(true),
                     Some(true)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
        ("video-formats", "methods: 'get' and 'list'", vec![
            ("get",
                    Some(r##"Gets one video format by ID."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/video-formats_get",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"id"##),
                     None,
                     Some(r##"Video format ID."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ("list",
                    Some(r##"Lists available video formats."##),
                    "Details at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli/video-formats_list",
                  vec![
                    (Some(r##"profile-id"##),
                     None,
                     Some(r##"User profile ID associated with this request."##),
                     Some(true),
                     Some(false)),
        
                    (Some(r##"v"##),
                     Some(r##"p"##),
                     Some(r##"Set various optional parameters, matching the key=value form"##),
                     Some(false),
                     Some(true)),
        
                    (Some(r##"out"##),
                     Some(r##"o"##),
                     Some(r##"Specify the file into which to write the program's output"##),
                     Some(false),
                     Some(false)),
                  ]),
            ]),
        
    ];
    
    let mut app = App::new("dfareporting2d8")
           .author("Sebastian Thiel <byronimo@gmail.com>")
           .version("5.0.5+20180830")
           .about("Manages your DoubleClick Campaign Manager ad campaigns and reports.")
           .after_help("All documentation details can be found at http://byron.github.io/google-apis-rs/google_dfareporting2d8_cli")
           .arg(Arg::with_name("url")
                   .long("scope")
                   .help("Specify the authentication a method should be executed in. Each scope requires the user to grant this application permission to use it.If unset, it defaults to the shortest scope url for a particular method.")
                   .multiple(true)
                   .takes_value(true))
           .arg(Arg::with_name("folder")
                   .long("config-dir")
                   .help("A directory into which we will store our persistent data. Defaults to a user-writable directory that we will create during the first invocation.[default: ~/.google-service-cli")
                   .multiple(false)
                   .takes_value(true))
           .arg(Arg::with_name("debug")
                   .long("debug")
                   .help("Debug print all errors")
                   .multiple(false)
                   .takes_value(false));
           
           for &(main_command_name, about, ref subcommands) in arg_data.iter() {
               let mut mcmd = SubCommand::with_name(main_command_name).about(about);
           
               for &(sub_command_name, ref desc, url_info, ref args) in subcommands {
                   let mut scmd = SubCommand::with_name(sub_command_name);
                   if let &Some(desc) = desc {
                       scmd = scmd.about(desc);
                   }
                   scmd = scmd.after_help(url_info);
           
                   for &(ref arg_name, ref flag, ref desc, ref required, ref multi) in args {
                       let arg_name_str =
                           match (arg_name, flag) {
                                   (&Some(an), _       ) => an,
                                   (_        , &Some(f)) => f,
                                    _                    => unreachable!(),
                            };
                       let mut arg = Arg::with_name(arg_name_str)
                                         .empty_values(false);
                       if let &Some(short_flag) = flag {
                           arg = arg.short(short_flag);
                       }
                       if let &Some(desc) = desc {
                           arg = arg.help(desc);
                       }
                       if arg_name.is_some() && flag.is_some() {
                           arg = arg.takes_value(true);
                       }
                       if let &Some(required) = required {
                           arg = arg.required(required);
                       }
                       if let &Some(multi) = multi {
                           arg = arg.multiple(multi);
                       }
                       if arg_name_str == "mode" {
                           arg = arg.number_of_values(2);
                           arg = arg.value_names(&upload_value_names);
           
                           scmd = scmd.arg(Arg::with_name("mime")
                                               .short("m")
                                               .requires("mode")
                                               .required(false)
                                               .help("The file's mime time, like 'application/octet-stream'")
                                               .takes_value(true));
                       }
                       scmd = scmd.arg(arg);
                   }
                   mcmd = mcmd.subcommand(scmd);
               }
               app = app.subcommand(mcmd);
           }
           
        let matches = app.get_matches();

    let debug = matches.is_present("adebug");
    let connector = hyper_rustls::HttpsConnectorBuilder::new().with_native_roots()
        .unwrap()
        .https_or_http()
        .enable_http1()
        .build();

    match Engine::new(matches, connector).await {
        Err(err) => {
            exit_status = err.exit_code;
            writeln!(io::stderr(), "{}", err).ok();
        },
        Ok(engine) => {
            if let Err(doit_err) = engine.doit().await {
                exit_status = 1;
                match doit_err {
                    DoitError::IoError(path, err) => {
                        writeln!(io::stderr(), "Failed to open output file '{}': {}", path, err).ok();
                    },
                    DoitError::ApiError(err) => {
                        if debug {
                            writeln!(io::stderr(), "{:#?}", err).ok();
                        } else {
                            writeln!(io::stderr(), "{}", err).ok();
                        }
                    }
                }
            }
        }
    }

    std::process::exit(exit_status);
}

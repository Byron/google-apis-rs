// DO NOT EDIT !
// This file was generated automatically from 'src/mako/api/lib.rs.mako'
// DO NOT EDIT !

//! This documentation was generated from *YouTube* crate version *1.0.14+20200709*, where *20200709* is the exact revision of the *youtube:v3* schema built by the [mako](http://www.makotemplates.org/) code generator *v1.0.14*.
//! 
//! Everything else about the *YouTube* *v3* API can be found at the
//! [official documentation site](https://developers.google.com/youtube/).
//! The original source code is [on github](https://github.com/Byron/google-apis-rs/tree/master/gen/youtube3).
//! # Features
//! 
//! Handle the following *Resources* with ease from the central [hub](struct.YouTube.html) ... 
//! 
//! * [abuse reports](struct.AbuseReport.html)
//!  * [*insert*](struct.AbuseReportInsertCall.html)
//! * [activities](struct.Activity.html)
//!  * [*list*](struct.ActivityListCall.html)
//! * [captions](struct.Caption.html)
//!  * [*delete*](struct.CaptionDeleteCall.html), [*download*](struct.CaptionDownloadCall.html), [*insert*](struct.CaptionInsertCall.html), [*list*](struct.CaptionListCall.html) and [*update*](struct.CaptionUpdateCall.html)
//! * channel banners
//!  * [*insert*](struct.ChannelBannerInsertCall.html)
//! * [channel sections](struct.ChannelSection.html)
//!  * [*delete*](struct.ChannelSectionDeleteCall.html), [*insert*](struct.ChannelSectionInsertCall.html), [*list*](struct.ChannelSectionListCall.html) and [*update*](struct.ChannelSectionUpdateCall.html)
//! * [channels](struct.Channel.html)
//!  * [*list*](struct.ChannelListCall.html) and [*update*](struct.ChannelUpdateCall.html)
//! * [comment threads](struct.CommentThread.html)
//!  * [*insert*](struct.CommentThreadInsertCall.html), [*list*](struct.CommentThreadListCall.html) and [*update*](struct.CommentThreadUpdateCall.html)
//! * [comments](struct.Comment.html)
//!  * [*delete*](struct.CommentDeleteCall.html), [*insert*](struct.CommentInsertCall.html), [*list*](struct.CommentListCall.html), [*mark as spam*](struct.CommentMarkAsSpamCall.html), [*set moderation status*](struct.CommentSetModerationStatuCall.html) and [*update*](struct.CommentUpdateCall.html)
//! * [guide categories](struct.GuideCategory.html)
//!  * [*list*](struct.GuideCategoryListCall.html)
//! * [i18n languages](struct.I18nLanguage.html)
//!  * [*list*](struct.I18nLanguageListCall.html)
//! * [i18n regions](struct.I18nRegion.html)
//!  * [*list*](struct.I18nRegionListCall.html)
//! * [live broadcasts](struct.LiveBroadcast.html)
//!  * [*bind*](struct.LiveBroadcastBindCall.html), [*control*](struct.LiveBroadcastControlCall.html), [*delete*](struct.LiveBroadcastDeleteCall.html), [*insert*](struct.LiveBroadcastInsertCall.html), [*list*](struct.LiveBroadcastListCall.html), [*transition*](struct.LiveBroadcastTransitionCall.html) and [*update*](struct.LiveBroadcastUpdateCall.html)
//! * [live chat bans](struct.LiveChatBan.html)
//!  * [*delete*](struct.LiveChatBanDeleteCall.html) and [*insert*](struct.LiveChatBanInsertCall.html)
//! * [live chat messages](struct.LiveChatMessage.html)
//!  * [*delete*](struct.LiveChatMessageDeleteCall.html), [*insert*](struct.LiveChatMessageInsertCall.html) and [*list*](struct.LiveChatMessageListCall.html)
//! * [live chat moderators](struct.LiveChatModerator.html)
//!  * [*delete*](struct.LiveChatModeratorDeleteCall.html), [*insert*](struct.LiveChatModeratorInsertCall.html) and [*list*](struct.LiveChatModeratorListCall.html)
//! * [live streams](struct.LiveStream.html)
//!  * [*delete*](struct.LiveStreamDeleteCall.html), [*insert*](struct.LiveStreamInsertCall.html), [*list*](struct.LiveStreamListCall.html) and [*update*](struct.LiveStreamUpdateCall.html)
//! * [members](struct.Member.html)
//!  * [*list*](struct.MemberListCall.html)
//! * [memberships levels](struct.MembershipsLevel.html)
//!  * [*list*](struct.MembershipsLevelListCall.html)
//! * [playlist items](struct.PlaylistItem.html)
//!  * [*delete*](struct.PlaylistItemDeleteCall.html), [*insert*](struct.PlaylistItemInsertCall.html), [*list*](struct.PlaylistItemListCall.html) and [*update*](struct.PlaylistItemUpdateCall.html)
//! * [playlists](struct.Playlist.html)
//!  * [*delete*](struct.PlaylistDeleteCall.html), [*insert*](struct.PlaylistInsertCall.html), [*list*](struct.PlaylistListCall.html) and [*update*](struct.PlaylistUpdateCall.html)
//! * search
//!  * [*list*](struct.SearchListCall.html)
//! * [sponsors](struct.Sponsor.html)
//!  * [*list*](struct.SponsorListCall.html)
//! * [subscriptions](struct.Subscription.html)
//!  * [*delete*](struct.SubscriptionDeleteCall.html), [*insert*](struct.SubscriptionInsertCall.html) and [*list*](struct.SubscriptionListCall.html)
//! * [super chat events](struct.SuperChatEvent.html)
//!  * [*list*](struct.SuperChatEventListCall.html)
//! * [third party links](struct.ThirdPartyLink.html)
//!  * [*delete*](struct.ThirdPartyLinkDeleteCall.html), [*insert*](struct.ThirdPartyLinkInsertCall.html), [*list*](struct.ThirdPartyLinkListCall.html) and [*update*](struct.ThirdPartyLinkUpdateCall.html)
//! * [thumbnails](struct.Thumbnail.html)
//!  * [*set*](struct.ThumbnailSetCall.html)
//! * [video abuse report reasons](struct.VideoAbuseReportReason.html)
//!  * [*list*](struct.VideoAbuseReportReasonListCall.html)
//! * [video categories](struct.VideoCategory.html)
//!  * [*list*](struct.VideoCategoryListCall.html)
//! * [videos](struct.Video.html)
//!  * [*delete*](struct.VideoDeleteCall.html), [*get rating*](struct.VideoGetRatingCall.html), [*insert*](struct.VideoInsertCall.html), [*list*](struct.VideoListCall.html), [*rate*](struct.VideoRateCall.html), [*report abuse*](struct.VideoReportAbuseCall.html) and [*update*](struct.VideoUpdateCall.html)
//! * watermarks
//!  * [*set*](struct.WatermarkSetCall.html) and [*unset*](struct.WatermarkUnsetCall.html)
//! * youtube
//!  * [*v3 infocards*](struct.YoutubeV3InfocardCall.html), [*v3 infocards list*](struct.YoutubeV3InfocardListCall.html) and [*v3 tests create*](struct.YoutubeV3TestCreateCall.html)
//! 
//! 
//! Upload supported by ...
//! 
//! * [*set thumbnails*](struct.ThumbnailSetCall.html)
//! * [*insert captions*](struct.CaptionInsertCall.html)
//! * [*insert videos*](struct.VideoInsertCall.html)
//! * [*set watermarks*](struct.WatermarkSetCall.html)
//! * [*insert channel banners*](struct.ChannelBannerInsertCall.html)
//! * [*update captions*](struct.CaptionUpdateCall.html)
//! 
//! Download supported by ...
//! 
//! * [*download captions*](struct.CaptionDownloadCall.html)
//! 
//! 
//! 
//! Not what you are looking for ? Find all other Google APIs in their Rust [documentation index](http://byron.github.io/google-apis-rs).
//! 
//! # Structure of this Library
//! 
//! The API is structured into the following primary items:
//! 
//! * **[Hub](struct.YouTube.html)**
//!     * a central object to maintain state and allow accessing all *Activities*
//!     * creates [*Method Builders*](trait.MethodsBuilder.html) which in turn
//!       allow access to individual [*Call Builders*](trait.CallBuilder.html)
//! * **[Resources](trait.Resource.html)**
//!     * primary types that you can apply *Activities* to
//!     * a collection of properties and *Parts*
//!     * **[Parts](trait.Part.html)**
//!         * a collection of properties
//!         * never directly used in *Activities*
//! * **[Activities](trait.CallBuilder.html)**
//!     * operations to apply to *Resources*
//! 
//! All *structures* are marked with applicable traits to further categorize them and ease browsing.
//! 
//! Generally speaking, you can invoke *Activities* like this:
//! 
//! ```Rust,ignore
//! let r = hub.resource().activity(...).doit()
//! ```
//! 
//! Or specifically ...
//! 
//! ```ignore
//! let r = hub.videos().rate(...).doit()
//! let r = hub.videos().report_abuse(...).doit()
//! let r = hub.videos().get_rating(...).doit()
//! let r = hub.videos().list(...).doit()
//! let r = hub.videos().insert(...).doit()
//! let r = hub.videos().update(...).doit()
//! let r = hub.videos().delete(...).doit()
//! ```
//! 
//! The `resource()` and `activity(...)` calls create [builders][builder-pattern]. The second one dealing with `Activities` 
//! supports various methods to configure the impending operation (not shown here). It is made such that all required arguments have to be 
//! specified right away (i.e. `(...)`), whereas all optional ones can be [build up][builder-pattern] as desired.
//! The `doit()` method performs the actual communication with the server and returns the respective result.
//! 
//! # Usage
//! 
//! ## Setting up your Project
//! 
//! To use this library, you would put the following lines into your `Cargo.toml` file:
//! 
//! ```toml
//! [dependencies]
//! google-youtube3 = "*"
//! # This project intentionally uses an old version of Hyper. See
//! # https://github.com/Byron/google-apis-rs/issues/173 for more
//! # information.
//! hyper = "^0.10"
//! hyper-rustls = "^0.6"
//! serde = "^1.0"
//! serde_json = "^1.0"
//! yup-oauth2 = "^1.0"
//! ```
//! 
//! ## A complete example
//! 
//! ```test_harness,no_run
//! extern crate hyper;
//! extern crate hyper_rustls;
//! extern crate yup_oauth2 as oauth2;
//! extern crate google_youtube3 as youtube3;
//! use youtube3::{Result, Error};
//! # #[test] fn egal() {
//! use std::default::Default;
//! use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
//! use youtube3::YouTube;
//! 
//! // Get an ApplicationSecret instance by some means. It contains the `client_id` and 
//! // `client_secret`, among other things.
//! let secret: ApplicationSecret = Default::default();
//! // Instantiate the authenticator. It will choose a suitable authentication flow for you, 
//! // unless you replace  `None` with the desired Flow.
//! // Provide your own `AuthenticatorDelegate` to adjust the way it operates and get feedback about 
//! // what's going on. You probably want to bring in your own `TokenStorage` to persist tokens and
//! // retrieve them from storage.
//! let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
//!                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
//!                               <MemoryStorage as Default>::default(), None);
//! let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
//! // You can configure optional parameters by calling the respective setters at will, and
//! // execute the final call using `doit()`.
//! // Values shown here are possibly random and not representative !
//! let result = hub.videos().list("part")
//!              .video_category_id("nonumy")
//!              .region_code("dolores")
//!              .page_token("gubergren")
//!              .on_behalf_of_content_owner("sadipscing")
//!              .my_rating("aliquyam")
//!              .max_width(-66)
//!              .max_results(40)
//!              .max_height(-21)
//!              .locale("justo")
//!              .add_id("et")
//!              .hl("et")
//!              .chart("diam")
//!              .doit();
//! 
//! match result {
//!     Err(e) => match e {
//!         // The Error enum provides details about what exactly happened.
//!         // You can also just use its `Debug`, `Display` or `Error` traits
//!          Error::HttpError(_)
//!         |Error::MissingAPIKey
//!         |Error::MissingToken(_)
//!         |Error::Cancelled
//!         |Error::UploadSizeLimitExceeded(_, _)
//!         |Error::Failure(_)
//!         |Error::BadRequest(_)
//!         |Error::FieldClash(_)
//!         |Error::JsonDecodeError(_, _) => println!("{}", e),
//!     },
//!     Ok(res) => println!("Success: {:?}", res),
//! }
//! # }
//! ```
//! ## Handling Errors
//! 
//! All errors produced by the system are provided either as [Result](enum.Result.html) enumeration as return value of 
//! the doit() methods, or handed as possibly intermediate results to either the 
//! [Hub Delegate](trait.Delegate.html), or the [Authenticator Delegate](https://docs.rs/yup-oauth2/*/yup_oauth2/trait.AuthenticatorDelegate.html).
//! 
//! When delegates handle errors or intermediate values, they may have a chance to instruct the system to retry. This 
//! makes the system potentially resilient to all kinds of errors.
//! 
//! ## Uploads and Downloads
//! If a method supports downloads, the response body, which is part of the [Result](enum.Result.html), should be
//! read by you to obtain the media.
//! If such a method also supports a [Response Result](trait.ResponseResult.html), it will return that by default.
//! You can see it as meta-data for the actual media. To trigger a media download, you will have to set up the builder by making
//! this call: `.param("alt", "media")`.
//! 
//! Methods supporting uploads can do so using up to 2 different protocols: 
//! *simple* and *resumable*. The distinctiveness of each is represented by customized 
//! `doit(...)` methods, which are then named `upload(...)` and `upload_resumable(...)` respectively.
//! 
//! ## Customization and Callbacks
//! 
//! You may alter the way an `doit()` method is called by providing a [delegate](trait.Delegate.html) to the 
//! [Method Builder](trait.CallBuilder.html) before making the final `doit()` call. 
//! Respective methods will be called to provide progress information, as well as determine whether the system should 
//! retry on failure.
//! 
//! The [delegate trait](trait.Delegate.html) is default-implemented, allowing you to customize it with minimal effort.
//! 
//! ## Optional Parts in Server-Requests
//! 
//! All structures provided by this library are made to be [encodable](trait.RequestValue.html) and 
//! [decodable](trait.ResponseResult.html) via *json*. Optionals are used to indicate that partial requests are responses 
//! are valid.
//! Most optionals are are considered [Parts](trait.Part.html) which are identifiable by name, which will be sent to 
//! the server to indicate either the set parts of the request or the desired parts in the response.
//! 
//! ## Builder Arguments
//! 
//! Using [method builders](trait.CallBuilder.html), you are able to prepare an action call by repeatedly calling it's methods.
//! These will always take a single argument, for which the following statements are true.
//! 
//! * [PODs][wiki-pod] are handed by copy
//! * strings are passed as `&str`
//! * [request values](trait.RequestValue.html) are moved
//! 
//! Arguments will always be copied or cloned into the builder, to make them independent of their original life times.
//! 
//! [wiki-pod]: http://en.wikipedia.org/wiki/Plain_old_data_structure
//! [builder-pattern]: http://en.wikipedia.org/wiki/Builder_pattern
//! [google-go-api]: https://github.com/google/google-api-go-client
//! 
//! 

// Unused attributes happen thanks to defined, but unused structures
// We don't warn about this, as depending on the API, some data structures or facilities are never used.
// Instead of pre-determining this, we just disable the lint. It's manually tuned to not have any
// unused imports in fully featured APIs. Same with unused_mut ... .
#![allow(unused_imports, unused_mut, dead_code)]

// DO NOT EDIT !
// This file was generated automatically from 'src/mako/api/lib.rs.mako'
// DO NOT EDIT !

#[macro_use]
extern crate serde_derive;

extern crate hyper;
extern crate serde;
extern crate serde_json;
extern crate yup_oauth2 as oauth2;
extern crate mime;
extern crate url;

mod cmn;

use std::collections::HashMap;
use std::cell::RefCell;
use std::borrow::BorrowMut;
use std::default::Default;
use std::collections::BTreeMap;
use serde_json as json;
use std::io;
use std::fs;
use std::mem;
use std::thread::sleep;
use std::time::Duration;

pub use cmn::*;


// ##############
// UTILITIES ###
// ############

/// Identifies the an OAuth2 authorization scope.
/// A scope is needed when requesting an
/// [authorization token](https://developers.google.com/youtube/v3/guides/authentication).
#[derive(PartialEq, Eq, Hash)]
pub enum Scope {
    /// View private information of your YouTube channel relevant during the audit process with a YouTube partner
    PartnerChannelAudit,

    /// View your YouTube account
    Readonly,

    /// Manage your YouTube account
    Full,

    /// See a list of your current active channel members, their current level, and when they became a member
    ChannelMembershipCreator,

    /// See, edit, and permanently delete your YouTube videos, ratings, comments and captions
    ForceSsl,

    /// View and manage your assets and associated content on YouTube
    Partner,

    /// Manage your YouTube videos
    Upload,
}

impl AsRef<str> for Scope {
    fn as_ref(&self) -> &str {
        match *self {
            Scope::PartnerChannelAudit => "https://www.googleapis.com/auth/youtubepartner-channel-audit",
            Scope::Readonly => "https://www.googleapis.com/auth/youtube.readonly",
            Scope::Full => "https://www.googleapis.com/auth/youtube",
            Scope::ChannelMembershipCreator => "https://www.googleapis.com/auth/youtube.channel-memberships.creator",
            Scope::ForceSsl => "https://www.googleapis.com/auth/youtube.force-ssl",
            Scope::Partner => "https://www.googleapis.com/auth/youtubepartner",
            Scope::Upload => "https://www.googleapis.com/auth/youtube.upload",
        }
    }
}

impl Default for Scope {
    fn default() -> Scope {
        Scope::Readonly
    }
}



// ########
// HUB ###
// ######

/// Central instance to access all YouTube related resource activities
///
/// # Examples
///
/// Instantiate a new hub
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// use youtube3::{Result, Error};
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// // Get an ApplicationSecret instance by some means. It contains the `client_id` and 
/// // `client_secret`, among other things.
/// let secret: ApplicationSecret = Default::default();
/// // Instantiate the authenticator. It will choose a suitable authentication flow for you, 
/// // unless you replace  `None` with the desired Flow.
/// // Provide your own `AuthenticatorDelegate` to adjust the way it operates and get feedback about 
/// // what's going on. You probably want to bring in your own `TokenStorage` to persist tokens and
/// // retrieve them from storage.
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.videos().list("part")
///              .video_category_id("Lorem")
///              .region_code("et")
///              .page_token("duo")
///              .on_behalf_of_content_owner("aliquyam")
///              .my_rating("sea")
///              .max_width(-55)
///              .max_results(26)
///              .max_height(-81)
///              .locale("sadipscing")
///              .add_id("dolor")
///              .hl("eirmod")
///              .chart("elitr")
///              .doit();
/// 
/// match result {
///     Err(e) => match e {
///         // The Error enum provides details about what exactly happened.
///         // You can also just use its `Debug`, `Display` or `Error` traits
///          Error::HttpError(_)
///         |Error::MissingAPIKey
///         |Error::MissingToken(_)
///         |Error::Cancelled
///         |Error::UploadSizeLimitExceeded(_, _)
///         |Error::Failure(_)
///         |Error::BadRequest(_)
///         |Error::FieldClash(_)
///         |Error::JsonDecodeError(_, _) => println!("{}", e),
///     },
///     Ok(res) => println!("Success: {:?}", res),
/// }
/// # }
/// ```
pub struct YouTube<C, A> {
    client: RefCell<C>,
    auth: RefCell<A>,
    _user_agent: String,
    _base_url: String,
    _root_url: String,
}

impl<'a, C, A> Hub for YouTube<C, A> {}

impl<'a, C, A> YouTube<C, A>
    where  C: BorrowMut<hyper::Client>, A: oauth2::GetToken {

    pub fn new(client: C, authenticator: A) -> YouTube<C, A> {
        YouTube {
            client: RefCell::new(client),
            auth: RefCell::new(authenticator),
            _user_agent: "google-api-rust-client/1.0.14".to_string(),
            _base_url: "https://www.googleapis.com/".to_string(),
            _root_url: "https://www.googleapis.com/".to_string(),
        }
    }

    pub fn abuse_reports(&'a self) -> AbuseReportMethods<'a, C, A> {
        AbuseReportMethods { hub: &self }
    }
    pub fn activities(&'a self) -> ActivityMethods<'a, C, A> {
        ActivityMethods { hub: &self }
    }
    pub fn captions(&'a self) -> CaptionMethods<'a, C, A> {
        CaptionMethods { hub: &self }
    }
    pub fn channel_banners(&'a self) -> ChannelBannerMethods<'a, C, A> {
        ChannelBannerMethods { hub: &self }
    }
    pub fn channel_sections(&'a self) -> ChannelSectionMethods<'a, C, A> {
        ChannelSectionMethods { hub: &self }
    }
    pub fn channels(&'a self) -> ChannelMethods<'a, C, A> {
        ChannelMethods { hub: &self }
    }
    pub fn comment_threads(&'a self) -> CommentThreadMethods<'a, C, A> {
        CommentThreadMethods { hub: &self }
    }
    pub fn comments(&'a self) -> CommentMethods<'a, C, A> {
        CommentMethods { hub: &self }
    }
    pub fn guide_categories(&'a self) -> GuideCategoryMethods<'a, C, A> {
        GuideCategoryMethods { hub: &self }
    }
    pub fn i18n_languages(&'a self) -> I18nLanguageMethods<'a, C, A> {
        I18nLanguageMethods { hub: &self }
    }
    pub fn i18n_regions(&'a self) -> I18nRegionMethods<'a, C, A> {
        I18nRegionMethods { hub: &self }
    }
    pub fn live_broadcasts(&'a self) -> LiveBroadcastMethods<'a, C, A> {
        LiveBroadcastMethods { hub: &self }
    }
    pub fn live_chat_bans(&'a self) -> LiveChatBanMethods<'a, C, A> {
        LiveChatBanMethods { hub: &self }
    }
    pub fn live_chat_messages(&'a self) -> LiveChatMessageMethods<'a, C, A> {
        LiveChatMessageMethods { hub: &self }
    }
    pub fn live_chat_moderators(&'a self) -> LiveChatModeratorMethods<'a, C, A> {
        LiveChatModeratorMethods { hub: &self }
    }
    pub fn live_streams(&'a self) -> LiveStreamMethods<'a, C, A> {
        LiveStreamMethods { hub: &self }
    }
    pub fn members(&'a self) -> MemberMethods<'a, C, A> {
        MemberMethods { hub: &self }
    }
    pub fn memberships_levels(&'a self) -> MembershipsLevelMethods<'a, C, A> {
        MembershipsLevelMethods { hub: &self }
    }
    pub fn playlist_items(&'a self) -> PlaylistItemMethods<'a, C, A> {
        PlaylistItemMethods { hub: &self }
    }
    pub fn playlists(&'a self) -> PlaylistMethods<'a, C, A> {
        PlaylistMethods { hub: &self }
    }
    pub fn search(&'a self) -> SearchMethods<'a, C, A> {
        SearchMethods { hub: &self }
    }
    pub fn sponsors(&'a self) -> SponsorMethods<'a, C, A> {
        SponsorMethods { hub: &self }
    }
    pub fn subscriptions(&'a self) -> SubscriptionMethods<'a, C, A> {
        SubscriptionMethods { hub: &self }
    }
    pub fn super_chat_events(&'a self) -> SuperChatEventMethods<'a, C, A> {
        SuperChatEventMethods { hub: &self }
    }
    pub fn third_party_links(&'a self) -> ThirdPartyLinkMethods<'a, C, A> {
        ThirdPartyLinkMethods { hub: &self }
    }
    pub fn thumbnails(&'a self) -> ThumbnailMethods<'a, C, A> {
        ThumbnailMethods { hub: &self }
    }
    pub fn video_abuse_report_reasons(&'a self) -> VideoAbuseReportReasonMethods<'a, C, A> {
        VideoAbuseReportReasonMethods { hub: &self }
    }
    pub fn video_categories(&'a self) -> VideoCategoryMethods<'a, C, A> {
        VideoCategoryMethods { hub: &self }
    }
    pub fn videos(&'a self) -> VideoMethods<'a, C, A> {
        VideoMethods { hub: &self }
    }
    pub fn watermarks(&'a self) -> WatermarkMethods<'a, C, A> {
        WatermarkMethods { hub: &self }
    }
    pub fn youtube(&'a self) -> YoutubeMethods<'a, C, A> {
        YoutubeMethods { hub: &self }
    }

    /// Set the user-agent header field to use in all requests to the server.
    /// It defaults to `google-api-rust-client/1.0.14`.
    ///
    /// Returns the previously set user-agent.
    pub fn user_agent(&mut self, agent_name: String) -> String {
        mem::replace(&mut self._user_agent, agent_name)
    }

    /// Set the base url to use in all requests to the server.
    /// It defaults to `https://www.googleapis.com/`.
    ///
    /// Returns the previously set base url.
    pub fn base_url(&mut self, new_base_url: String) -> String {
        mem::replace(&mut self._base_url, new_base_url)
    }

    /// Set the root url to use in all requests to the server.
    /// It defaults to `https://www.googleapis.com/`.
    ///
    /// Returns the previously set root url.
    pub fn root_url(&mut self, new_root_url: String) -> String {
        mem::replace(&mut self._root_url, new_root_url)
    }
}


// ############
// SCHEMAS ###
// ##########
/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LinkCard {
    /// URL to an externally hosted image.
    #[serde(rename="externalImageUrl")]
    pub external_image_url: Option<String>,
    /// Previously uploaded image.
    #[serde(rename="uploadedImage")]
    pub uploaded_image: Option<LinkCardUploadedImage>,
    /// The URL to which this card points.
    /// Required.
    #[serde(rename="targetUrl")]
    pub target_url: Option<String>,
    /// Custom text to show as the website link.
    /// Required.
    #[serde(rename="customLinkText")]
    pub custom_link_text: Option<String>,
    /// The title to show on the card.
    /// Required.
    pub title: Option<String>,
}

impl Part for LinkCard {}


/// Describes an invideo promotion campaign consisting of multiple promoted
/// items. A campaign belongs to a single channel_id.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct InvideoPromotion {
    /// The default temporal position within the video where the promoted item will
    /// be displayed. Can be overridden by more specific timing in the item.
    #[serde(rename="defaultTiming")]
    pub default_timing: Option<InvideoTiming>,
    /// List of promoted items in decreasing priority.
    pub items: Option<Vec<PromotedItem>>,
    /// Indicates whether the channel's promotional campaign uses "smart timing."
    /// This feature attempts to show promotions at a point in the video when they
    /// are more likely to be clicked and less likely to disrupt the viewing
    /// experience. This feature also picks up a single promotion to show on each
    /// video.
    #[serde(rename="useSmartTiming")]
    pub use_smart_timing: Option<bool>,
    /// The spatial position within the video where the promoted item will be
    /// displayed.
    pub position: Option<InvideoPosition>,
}

impl Part for InvideoPromotion {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list subscriptions](struct.SubscriptionListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SubscriptionListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#subscriptionListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of subscriptions that match the request criteria.
    pub items: Option<Vec<Subscription>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the previous page in the result set.
    #[serde(rename="prevPageToken")]
    pub prev_page_token: Option<String>,
    /// no description provided
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for SubscriptionListResponse {}

impl ToParts for SubscriptionListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.prev_page_token.is_some() { r = r + "prevPageToken,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// Basic details about a playlist, including title, description and thumbnails.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PlaylistSnippet {
    /// The playlist's description.
    pub description: Option<String>,
    /// The playlist's title.
    pub title: Option<String>,
    /// The ID that YouTube uses to uniquely identify the channel that
    /// published the playlist.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The date and time that the playlist was created. The value is specified
    /// in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="publishedAt")]
    pub published_at: Option<String>,
    /// Keyword tags associated with the playlist.
    pub tags: Option<Vec<String>>,
    /// The channel title of the channel that the video belongs to.
    #[serde(rename="channelTitle")]
    pub channel_title: Option<String>,
    /// The language of the playlist's default title and description.
    #[serde(rename="defaultLanguage")]
    pub default_language: Option<String>,
    /// Localized title and description, read-only.
    pub localized: Option<PlaylistLocalization>,
    /// A map of thumbnail images associated with the playlist. For each object
    /// in the map, the key is the name of the thumbnail image, and the value
    /// is an object that contains other information about the thumbnail.
    pub thumbnails: Option<ThumbnailDetails>,
}

impl Part for PlaylistSnippet {}


/// Information about a resource that received a positive (like) rating.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityContentDetailsLike {
    /// The <code>resourceId</code> object contains information that identifies
    /// the rated resource.
    #[serde(rename="resourceId")]
    pub resource_id: Option<ResourceId>,
}

impl Part for ActivityContentDetailsLike {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [set thumbnails](struct.ThumbnailSetCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ThumbnailSetResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// A list of thumbnails.
    pub items: Option<Vec<ThumbnailDetails>>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#thumbnailSetResponse"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
}

impl ResponseResult for ThumbnailSetResponse {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SponsorSnippet {
    /// The cumulative time a user has been a sponsor in months.
    #[serde(rename="cumulativeDurationMonths")]
    pub cumulative_duration_months: Option<i32>,
    /// Details about the sponsor.
    #[serde(rename="sponsorDetails")]
    pub sponsor_details: Option<ChannelProfileDetails>,
    /// The id of the channel being sponsored.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The date and time when the user became a sponsor. The value is
    /// specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// (`YYYY-MM-DDThh:mm:ss.sZ`) format.
    #[serde(rename="sponsorSince")]
    pub sponsor_since: Option<String>,
}

impl Part for SponsorSnippet {}


/// Branding properties for the channel view.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelSettings {
    /// Specifies the channel description.
    pub description: Option<String>,
    /// Specifies the channel title.
    pub title: Option<String>,
    /// The country of the channel.
    pub country: Option<String>,
    /// Whether the tab to browse the videos should be displayed.
    #[serde(rename="showBrowseView")]
    pub show_browse_view: Option<bool>,
    /// Title for the featured channels tab.
    #[serde(rename="featuredChannelsTitle")]
    pub featured_channels_title: Option<String>,
    /// no description provided
    #[serde(rename="defaultLanguage")]
    pub default_language: Option<String>,
    /// The trailer of the channel, for users that are not subscribers.
    #[serde(rename="unsubscribedTrailer")]
    pub unsubscribed_trailer: Option<String>,
    /// The list of featured channels.
    #[serde(rename="featuredChannelsUrls")]
    pub featured_channels_urls: Option<Vec<String>>,
    /// A prominent color that can be rendered on this channel page.
    #[serde(rename="profileColor")]
    pub profile_color: Option<String>,
    /// Which content tab users should see when viewing the channel.
    #[serde(rename="defaultTab")]
    pub default_tab: Option<String>,
    /// Whether user-submitted comments left on the channel page need to be
    /// approved by the channel owner to be publicly visible.
    #[serde(rename="moderateComments")]
    pub moderate_comments: Option<bool>,
    /// Lists keywords associated with the channel, comma-separated.
    pub keywords: Option<String>,
    /// Whether related channels should be proposed.
    #[serde(rename="showRelatedChannels")]
    pub show_related_channels: Option<bool>,
    /// The ID for a Google Analytics account to track and measure traffic to the
    /// channels.
    #[serde(rename="trackingAnalyticsAccountId")]
    pub tracking_analytics_account_id: Option<String>,
}

impl Part for ChannelSettings {}


/// The <code>third-party link status</code> object contains information about
/// the status of the link.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ThirdPartyLinkStatus {
    /// no description provided
    #[serde(rename="linkStatus")]
    pub link_status: Option<String>,
}

impl Part for ThirdPartyLinkStatus {}


/// Brief description of the live stream cdn settings.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct CdnSettings {
    /// The resolution of the inbound video data.
    pub resolution: Option<String>,
    /// The format of the video stream that you are sending to Youtube. <br><br>
    pub format: Option<String>,
    /// The <code>ingestionInfo</code> object contains information that YouTube
    /// provides that you need to transmit your RTMP or HTTP stream to YouTube.
    #[serde(rename="ingestionInfo")]
    pub ingestion_info: Option<IngestionInfo>,
    /// The frame rate of the inbound video data.
    #[serde(rename="frameRate")]
    pub frame_rate: Option<String>,
    ///  The method or protocol used to transmit the video stream.
    #[serde(rename="ingestionType")]
    pub ingestion_type: Option<String>,
}

impl Part for CdnSettings {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatMessageDeletedDetails {
    /// no description provided
    #[serde(rename="deletedMessageId")]
    pub deleted_message_id: Option<String>,
}

impl Part for LiveChatMessageDeletedDetails {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list video abuse report reasons](struct.VideoAbuseReportReasonListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoAbuseReportReasonListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// A list of valid abuse reasons that are used with `video.ReportAbuse`.
    pub items: Option<Vec<VideoAbuseReportReason>>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// `"youtube#videoAbuseReportReasonListResponse"`.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The `visitorId` identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
}

impl ResponseResult for VideoAbuseReportReasonListResponse {}

impl ToParts for VideoAbuseReportReasonListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        r.pop();
        r
    }
}

/// Details about a resource which was added to a channel.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityContentDetailsChannelItem {
    /// The <code>resourceId</code> object contains information that
    /// identifies the resource that was added to the channel.
    #[serde(rename="resourceId")]
    pub resource_id: Option<ResourceId>,
}

impl Part for ActivityContentDetailsChannelItem {}


/// Basic details about an i18n language, such as language code and
/// human-readable name.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct I18nLanguageSnippet {
    /// The human-readable name of the language in the language itself.
    pub name: Option<String>,
    /// A short BCP-47 code that uniquely identifies a language.
    pub hl: Option<String>,
}

impl Part for I18nLanguageSnippet {}


/// Basic details about rating of a video.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoRating {
    /// Rating of a video.
    pub rating: Option<String>,
    /// The ID that YouTube uses to uniquely identify the video.
    #[serde(rename="videoId")]
    pub video_id: Option<String>,
}

impl Part for VideoRating {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list i18n regions](struct.I18nRegionListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct I18nRegionListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// A list of regions where YouTube is available. In this map, the i18n region
    /// ID is the map key, and its value is the corresponding
    /// <code>i18nRegion</code> resource.
    pub items: Option<Vec<I18nRegion>>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#i18nRegionListResponse"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
}

impl ResponseResult for I18nRegionListResponse {}

impl ToParts for I18nRegionListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list live streams](struct.LiveStreamListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveStreamListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#liveStreamListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of live streams that match the request criteria.
    pub items: Option<Vec<LiveStream>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the previous page in the result set.
    #[serde(rename="prevPageToken")]
    pub prev_page_token: Option<String>,
    /// no description provided
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for LiveStreamListResponse {}

impl ToParts for LiveStreamListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.prev_page_token.is_some() { r = r + "prevPageToken,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list super chat events](struct.SuperChatEventListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SuperChatEventListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#superChatEventListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of Super Chat purchases that match the request criteria.
    pub items: Option<Vec<SuperChatEvent>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// no description provided
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for SuperChatEventListResponse {}

impl ToParts for SuperChatEventListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatTextMessageDetails {
    /// The user's message.
    #[serde(rename="messageText")]
    pub message_text: Option<String>,
}

impl Part for LiveChatTextMessageDetails {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatSuperChatDetails {
    /// The tier in which the amount belongs. Lower amounts belong to lower
    /// tiers. The lowest tier is <code>1</code>.
    pub tier: Option<u32>,
    /// The currency in which the purchase was made.
    pub currency: Option<String>,
    /// A rendered string that displays the fund amount and currency to the user.
    #[serde(rename="amountDisplayString")]
    pub amount_display_string: Option<String>,
    /// The amount purchased by the user, in micros (1,750,000 micros = 1.75).
    #[serde(rename="amountMicros")]
    pub amount_micros: Option<String>,
    /// The comment added by the user to this Super Chat event.
    #[serde(rename="userComment")]
    pub user_comment: Option<String>,
}

impl Part for LiveChatSuperChatDetails {}


/// Pings that the app shall fire (authenticated by biscotti cookie). Each ping
/// has a context, in which the app must fire the ping, and a url identifying the
/// ping.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelConversionPing {
    /// Defines the context of the ping.
    pub context: Option<String>,
    /// The url (without the schema) that the player shall send the ping to.
    /// It's at caller's descretion to decide which schema to use (http vs https)
    /// Example of a returned url: //googleads.g.doubleclick.net/pagead/
    /// viewthroughconversion/962985656/?data=path%3DtHe_path%3Btype%3D
    /// cview%3Butuid%3DGISQtTNGYqaYl4sKxoVvKA&labe=default
    /// The caller must append biscotti authentication (ms param in case of
    /// mobile, for example) to this ping.
    #[serde(rename="conversionUrl")]
    pub conversion_url: Option<String>,
}

impl Part for ChannelConversionPing {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [v3 tests create youtube](struct.YoutubeV3TestCreateCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct TestItem {
    /// no description provided
    pub snippet: Option<TestItemTestItemSnippet>,
    /// no description provided
    pub id: Option<String>,
}

impl RequestValue for TestItem {}
impl ResponseResult for TestItem {}

impl ToParts for TestItem {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// A <code><strong>playlistItem</strong></code> resource identifies
/// another resource, such as a video, that is included in a playlist. In
/// addition, the <code>playlistItem </code> resource contains details
/// about the included resource that pertain specifically to how that
/// resource is used in that playlist.<br/><br/> YouTube uses playlists to
/// identify special collections of videos for a channel, such as:
/// 
/// <ul>
///     <li>uploaded videos</li>
///     <li>favorite videos</li>
///     <li>positively rated (liked) videos</li>
///     <li>watch history</li>
///     <li>watch later</li>
///   </ul>
///  To be more specific, these lists are associated with a channel, which
/// is a collection of a person, group, or company's videos, playlists,
/// and other YouTube information.
/// <br/><br/>
///  You can retrieve the playlist IDs for each of these lists from the
/// <code> <a href=\"/youtube/v3/docs/channels\">channel resource</a>
/// </code> for a given channel. You can then use the <code> <a
/// href=\"/youtube/v3/docs/playlistItems/list\">
/// playlistItems.list</a></code> method to retrieve any of those
/// lists. You can also add or remove items from those lists by calling
/// the <code> <a href=\"/youtube/v3/docs/playlistItems/insert\">
/// playlistItems.insert</a></code> and <code> <a
/// href=\"/youtube/v3/docs/playlistItems/delete\">
/// playlistItems.delete</a></code> methods. For example, if a user gives
/// a positive rating to a video, you would insert that video into the
/// liked videos playlist for that user's channel.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [insert playlist items](struct.PlaylistItemInsertCall.html) (request|response)
/// * [update playlist items](struct.PlaylistItemUpdateCall.html) (request|response)
/// * [list playlist items](struct.PlaylistItemListCall.html) (none)
/// * [delete playlist items](struct.PlaylistItemDeleteCall.html) (none)
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PlaylistItem {
    /// The <code>status</code> object contains information about the playlist
    /// item's privacy status.
    pub status: Option<PlaylistItemStatus>,
    /// The <code>snippet</code> object contains basic details about the
    /// playlist item, such as its title and position in the playlist.
    pub snippet: Option<PlaylistItemSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#playlistItem"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>contentDetails</code> object is included in the resource if
    /// the included item is a YouTube video. The object contains additional
    /// information about the video.
    #[serde(rename="contentDetails")]
    pub content_details: Option<PlaylistItemContentDetails>,
    /// The ID that YouTube uses to uniquely identify the playlist item.
    pub id: Option<String>,
}

impl RequestValue for PlaylistItem {}
impl Resource for PlaylistItem {}
impl ResponseResult for PlaylistItem {}

impl ToParts for PlaylistItem {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.status.is_some() { r = r + "status,"; }
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.content_details.is_some() { r = r + "contentDetails,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// Freebase topic information related to the channel.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelTopicDetails {
    /// A list of Freebase topic IDs associated with the channel. You can retrieve
    /// information about each topic using the <a
    /// href="http://wiki.freebase.com/wiki/Topic_API">Freebase Topic API</a>.
    #[serde(rename="topicIds")]
    pub topic_ids: Option<Vec<String>>,
    /// A list of Wikipedia URLs that describe the channel's content.
    #[serde(rename="topicCategories")]
    pub topic_categories: Option<Vec<String>>,
}

impl Part for ChannelTopicDetails {}


/// A <code><strong>i18nRegion</strong></code> resource identifies a region where
/// YouTube is available.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list i18n regions](struct.I18nRegionListCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct I18nRegion {
    /// The <code>snippet</code> object contains basic details about the i18n
    /// region, such as region code and human-readable name.
    pub snippet: Option<I18nRegionSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#i18nRegion"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube uses to uniquely identify the i18n region.
    pub id: Option<String>,
}

impl Resource for I18nRegion {}

impl ToParts for I18nRegion {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// Internal representation of thumbnails for a YouTube resource.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ThumbnailDetails {
    /// The default image for this resource.
    pub default: Option<Thumbnail>,
    /// The high quality image for this resource.
    pub high: Option<Thumbnail>,
    /// The medium quality image for this resource.
    pub medium: Option<Thumbnail>,
    /// The maximum resolution quality image for this resource.
    pub maxres: Option<Thumbnail>,
    /// The standard quality image for this resource.
    pub standard: Option<Thumbnail>,
}

impl Part for ThumbnailDetails {}


/// Details about monetization of a YouTube Video.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoMonetizationDetails {
    /// The value of <code>access</code> indicates whether the video can be
    /// monetized or not.
    pub access: Option<AccessPolicy>,
}

impl Part for VideoMonetizationDetails {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LinkCardUploadedImage {
    /// Image reference on the thumbnail service.
    #[serde(rename="imageFile")]
    pub image_file: Option<String>,
    /// The version in the thumbnail service.
    pub version: Option<String>,
}

impl Part for LinkCardUploadedImage {}


/// The <code>contentOwnerDetails</code> object encapsulates channel data that
/// is relevant for YouTube Partners linked with the channel.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelContentOwnerDetails {
    /// The ID of the content owner linked to the channel.
    #[serde(rename="contentOwner")]
    pub content_owner: Option<String>,
    /// The date and time of when the channel was linked to the content owner.
    /// The value is specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO
    /// 8601</a>
    /// format.
    #[serde(rename="timeLinked")]
    pub time_linked: Option<String>,
}

impl Part for ChannelContentOwnerDetails {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelContentDetailsRelatedPlaylists {
    /// The ID of the playlist that contains the channel"s uploaded videos. Use
    /// the <code> <a
    /// href="/youtube/v3/docs/videos/insert">videos.insert</a></code> method to
    /// upload new videos and the <code><a
    /// href="/youtube/v3/docs/videos/delete">videos.delete</a></code> method to
    /// delete previously uploaded videos.
    pub uploads: Option<String>,
    /// The ID of the playlist that contains the channel"s watch history. Use the
    /// <code> <a
    /// href="/youtube/v3/docs/playlistItems/insert">playlistItems.insert</a></code>
    /// and <code> <a
    /// href="/youtube/v3/docs/playlistItems/delete">playlistItems.delete</a></code>
    /// to add or remove items from that list.
    #[serde(rename="watchHistory")]
    pub watch_history: Option<String>,
    /// The ID of the playlist that contains the channel"s liked videos. Use the
    /// <code> <a href="/youtube/v3/docs/playlistItems/insert">
    /// playlistItems.insert</a></code> and <code> <a
    /// href="/youtube/v3/docs/playlistItems/delete">playlistItems.delete</a></code>
    /// to add or remove items from that list.
    pub likes: Option<String>,
    /// The ID of the playlist that contains the channel"s favorite videos. Use
    /// the <code> <a
    /// href="/youtube/v3/docs/playlistItems/insert">playlistItems.insert</a></code>
    /// and <code> <a
    /// href="/youtube/v3/docs/playlistItems/delete">playlistItems.delete</a></code>
    /// to add or remove items from that list.
    pub favorites: Option<String>,
    /// The ID of the playlist that contains the channel"s watch later playlist.
    /// Use the <code><a
    /// href="/youtube/v3/docs/playlistItems/insert">playlistItems.insert</a></code>
    /// and <code> <a
    /// href="/youtube/v3/docs/playlistItems/delete">playlistItems.delete</a></code>
    /// to add or remove items from that list.
    #[serde(rename="watchLater")]
    pub watch_later: Option<String>,
}

impl NestedType for ChannelContentDetailsRelatedPlaylists {}
impl Part for ChannelContentDetailsRelatedPlaylists {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list memberships levels](struct.MembershipsLevelListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct MembershipsLevelListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// A list of pricing levels offered by a creator to the fans.
    pub items: Option<Vec<MembershipsLevel>>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#membershipsLevelListResponse"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
}

impl ResponseResult for MembershipsLevelListResponse {}

impl ToParts for MembershipsLevelListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        r.pop();
        r
    }
}

/// Basic details about a video category, such as its localized title.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoAbuseReportReasonSnippet {
    /// The secondary reasons associated with this reason, if any are available.
    /// (There might be 0 or more.)
    #[serde(rename="secondaryReasons")]
    pub secondary_reasons: Option<Vec<VideoAbuseReportSecondaryReason>>,
    /// The localized label belonging to this abuse report reason.
    pub label: Option<String>,
}

impl Part for VideoAbuseReportReasonSnippet {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SuperChatEventSnippet {
    /// The text contents of the comment left by the user.
    #[serde(rename="commentText")]
    pub comment_text: Option<String>,
    /// If this event is a Super Sticker event, this field will contain metadata
    /// about the Super Sticker.
    #[serde(rename="superStickerMetadata")]
    pub super_sticker_metadata: Option<SuperStickerMetadata>,
    /// Channel id where the event occurred.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// True if this event is a Super Sticker event.
    #[serde(rename="isSuperStickerEvent")]
    pub is_super_sticker_event: Option<bool>,
    /// The tier for the paid message, which is based on the amount of money spent
    /// to purchase the message.
    #[serde(rename="messageType")]
    pub message_type: Option<u32>,
    /// The purchase amount, in micros of the purchase currency.  e.g., 1 is
    /// represented as 1000000.
    #[serde(rename="amountMicros")]
    pub amount_micros: Option<String>,
    /// The currency in which the purchase was made.  ISO 4217.
    pub currency: Option<String>,
    /// Details about the supporter.
    #[serde(rename="supporterDetails")]
    pub supporter_details: Option<ChannelProfileDetails>,
    /// A rendered string that displays the purchase amount and currency
    /// (e.g., "$1.00").  The string is rendered for the given language.
    #[serde(rename="displayString")]
    pub display_string: Option<String>,
    /// The date and time when the event occurred. The value is
    /// specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="createdAt")]
    pub created_at: Option<String>,
}

impl Part for SuperChatEventSnippet {}


/// The <code>conversionPings</code> object encapsulates information about
/// conversion pings that need to be respected by the channel.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelConversionPings {
    /// Pings that the app shall fire (authenticated by biscotti cookie). Each ping
    /// has a context, in which the app must fire the ping, and a url identifying
    /// the ping.
    pub pings: Option<Vec<ChannelConversionPing>>,
}

impl Part for ChannelConversionPings {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct AbuseType {
    /// no description provided
    pub id: Option<String>,
}

impl Part for AbuseType {}


/// The id of the author's YouTube channel, if any.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct CommentSnippetAuthorChannelId {
    /// no description provided
    pub value: Option<String>,
}

impl Part for CommentSnippetAuthorChannelId {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoAbuseReportSecondaryReason {
    /// The ID of this abuse report secondary reason.
    pub id: Option<String>,
    /// The localized label for this abuse report secondary reason.
    pub label: Option<String>,
}

impl Part for VideoAbuseReportSecondaryReason {}


/// Details about the content to witch a subscription refers.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SubscriptionContentDetails {
    /// The number of new items in the subscription since its content was last
    /// read.
    #[serde(rename="newItemCount")]
    pub new_item_count: Option<u32>,
    /// The type of activity this subscription is for
    /// (only uploads, everything).
    #[serde(rename="activityType")]
    pub activity_type: Option<String>,
    /// The approximate number of items that the subscription points to.
    #[serde(rename="totalItemCount")]
    pub total_item_count: Option<u32>,
}

impl Part for SubscriptionContentDetails {}


/// A <code><strong>liveChatMessage</strong></code> resource represents a chat
/// message in a YouTube Live Chat.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [delete live chat messages](struct.LiveChatMessageDeleteCall.html) (none)
/// * [list live chat messages](struct.LiveChatMessageListCall.html) (none)
/// * [insert live chat messages](struct.LiveChatMessageInsertCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatMessage {
    /// The <code>snippet</code> object contains basic details about the message.
    pub snippet: Option<LiveChatMessageSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#liveChatMessage"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>authorDetails</code> object contains basic details about the
    /// user that posted this message.
    #[serde(rename="authorDetails")]
    pub author_details: Option<LiveChatMessageAuthorDetails>,
    /// The ID that YouTube assigns to uniquely identify the message.
    pub id: Option<String>,
}

impl RequestValue for LiveChatMessage {}
impl Resource for LiveChatMessage {}
impl ResponseResult for LiveChatMessage {}

impl ToParts for LiveChatMessage {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.author_details.is_some() { r = r + "authorDetails,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list channel sections](struct.ChannelSectionListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelSectionListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// A list of ChannelSections that match the request criteria.
    pub items: Option<Vec<ChannelSection>>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#channelSectionListResponse"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
}

impl ResponseResult for ChannelSectionListResponse {}

impl ToParts for ChannelSectionListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        r.pop();
        r
    }
}

/// Comments written in (direct or indirect) reply to the top level comment.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct CommentThreadReplies {
    /// A limited number of replies. Unless the number of replies returned equals
    /// total_reply_count in the snippet the returned replies are only a subset
    /// of the total number of replies.
    pub comments: Option<Vec<Comment>>,
}

impl Part for CommentThreadReplies {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct InfoCard {
    /// The snippet object contains basic details about the infocard.
    pub snippet: Option<InfoCardSnippet>,
    /// Identifies what kind of resource this is.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// UUID for this infocard.
    pub id: Option<String>,
}

impl Part for InfoCard {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Entity {
    /// no description provided
    pub url: Option<String>,
    /// no description provided
    #[serde(rename="typeId")]
    pub type_id: Option<String>,
    /// no description provided
    pub id: Option<String>,
}

impl Part for Entity {}


/// DEPRECATED Region restriction of the video.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoContentDetailsRegionRestriction {
    /// A list of region codes that identify countries where the video is
    /// viewable. If this property is present and a country is not listed
    /// in its value, then the video is blocked from appearing in that
    /// country. If this property is present and contains an empty list,
    /// the video is blocked in all countries.
    pub allowed: Option<Vec<String>>,
    /// A list of region codes that identify countries where the video is
    /// blocked. If this property is present and a country is not listed in
    /// its value, then the video is viewable in that country. If this
    /// property is present and contains an empty list, the video is
    /// viewable in all countries.
    pub blocked: Option<Vec<String>>,
}

impl Part for VideoContentDetailsRegionRestriction {}


/// Basic details about a subscription, including title, description and
/// thumbnails of the subscribed item.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SubscriptionSnippet {
    /// The subscription's details.
    pub description: Option<String>,
    /// The subscription's title.
    pub title: Option<String>,
    /// The <code>id</code> object contains information about the channel that
    /// the user subscribed to.
    #[serde(rename="resourceId")]
    pub resource_id: Option<ResourceId>,
    /// A map of thumbnail images associated with the video. For each object
    /// in the map, the key is the name of the thumbnail image, and the value
    /// is an object that contains other information about the thumbnail.
    pub thumbnails: Option<ThumbnailDetails>,
    /// The ID that YouTube uses to uniquely identify the subscriber's channel.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The date and time that the subscription was created. The value is
    /// specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="publishedAt")]
    pub published_at: Option<String>,
    /// Channel title for the channel that the subscription belongs to.
    #[serde(rename="channelTitle")]
    pub channel_title: Option<String>,
}

impl Part for SubscriptionSnippet {}


/// Basic details about a caption track, such as its language and name.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct CaptionSnippet {
    /// The caption track's status.
    pub status: Option<String>,
    /// Indicates whether the track contains closed captions for the deaf
    /// and hard of hearing. The default value is <code>false</code>.
    #[serde(rename="isCC")]
    pub is_cc: Option<bool>,
    /// The type of audio track associated with the caption track.
    #[serde(rename="audioTrackType")]
    pub audio_track_type: Option<String>,
    /// The language of the caption track. The property value is a
    /// <a href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">BCP-47</a>
    ///  language tag.
    pub language: Option<String>,
    /// The ID that YouTube uses to uniquely identify the video associated
    /// with the caption track.
    /// @mutable youtube.captions.insert
    #[serde(rename="videoId")]
    pub video_id: Option<String>,
    /// Indicates whether the caption track is a draft. If the value is
    /// <code>true</code>, then the track is not publicly visible.
    /// The default value is <code>false</code>.
    /// @mutable youtube.captions.insert youtube.captions.update
    #[serde(rename="isDraft")]
    pub is_draft: Option<bool>,
    /// Indicates whether YouTube synchronized the caption track to the audio
    /// track in the video. The value will be <code>true</code> if a sync was
    /// explicitly requested when the caption track was uploaded. For example,
    /// when calling the <code>captions.insert</code> or
    /// <code>captions.update</code> methods, you can set the <code>sync</code>
    /// parameter to <code>true</code> to instruct YouTube to sync the uploaded
    /// track to the video. If the value is <code>false</code>, YouTube uses
    /// the time codes in the uploaded caption track to determine when to display
    /// captions.
    #[serde(rename="isAutoSynced")]
    pub is_auto_synced: Option<bool>,
    /// The date and time when the caption track was last updated. The value is
    /// specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="lastUpdated")]
    pub last_updated: Option<String>,
    /// The caption track's type.
    #[serde(rename="trackKind")]
    pub track_kind: Option<String>,
    /// Indicates whether caption track is formatted for "easy reader,"
    /// meaning it is at a third-grade level for language learners.
    /// The default value is <code>false</code>.
    #[serde(rename="isEasyReader")]
    pub is_easy_reader: Option<bool>,
    /// Indicates whether the caption track uses large text for the
    /// vision-impaired. The default value is <code>false</code>.
    #[serde(rename="isLarge")]
    pub is_large: Option<bool>,
    /// The reason that YouTube failed to process the caption track. This
    /// property is only present if the <code><a href="#state">state</a></code>
    /// property's value is <code>failed</code>.
    #[serde(rename="failureReason")]
    pub failure_reason: Option<String>,
    /// The name of the caption track. The name is intended to be visible
    /// to the user as an option during playback.
    pub name: Option<String>,
}

impl Part for CaptionSnippet {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatMessageRetractedDetails {
    /// no description provided
    #[serde(rename="retractedMessageId")]
    pub retracted_message_id: Option<String>,
}

impl Part for LiveChatMessageRetractedDetails {}


/// A `__liveChatBan__` resource represents a ban for a YouTube live chat.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [insert live chat bans](struct.LiveChatBanInsertCall.html) (request|response)
/// * [delete live chat bans](struct.LiveChatBanDeleteCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatBan {
    /// The `snippet` object contains basic details about the ban.
    pub snippet: Option<LiveChatBanSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// `"youtube#liveChatBan"`.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube assigns to uniquely identify the ban.
    pub id: Option<String>,
}

impl RequestValue for LiveChatBan {}
impl Resource for LiveChatBan {}
impl ResponseResult for LiveChatBan {}

impl ToParts for LiveChatBan {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list live chat messages](struct.LiveChatMessageListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatMessageListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// no description provided
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#liveChatMessageListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// no description provided
    pub items: Option<Vec<LiveChatMessage>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The amount of time the client should wait before polling again.
    #[serde(rename="pollingIntervalMillis")]
    pub polling_interval_millis: Option<u32>,
    /// General pagination information.
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
    /// The date and time when the underlying stream went offline. The value is
    /// specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="offlineAt")]
    pub offline_at: Option<String>,
}

impl ResponseResult for LiveChatMessageListResponse {}

impl ToParts for LiveChatMessageListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.polling_interval_millis.is_some() { r = r + "pollingIntervalMillis,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        if self.offline_at.is_some() { r = r + "offlineAt,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct InfoCardSnippet {
    /// no description provided
    #[serde(rename="channelInfocard")]
    pub channel_infocard: Option<ChannelCard>,
    /// no description provided
    #[serde(rename="linkInfocard")]
    pub link_infocard: Option<LinkCard>,
    /// no description provided
    #[serde(rename="playlistInfocard")]
    pub playlist_infocard: Option<PlaylistCard>,
    /// Each card can have a teaser.
    /// Required.
    pub teaser: Option<InfoCardSnippetTeaser>,
    /// no description provided
    #[serde(rename="videoInfocard")]
    pub video_infocard: Option<VideoCard>,
}

impl Part for InfoCardSnippet {}


/// Basic details about an i18n region, such as region code and human-readable
/// name.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct I18nRegionSnippet {
    /// The region code as a 2-letter ISO country code.
    pub gl: Option<String>,
    /// The human-readable name of the region.
    pub name: Option<String>,
}

impl Part for I18nRegionSnippet {}


/// Details about a social network post.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityContentDetailsSocial {
    /// The <code>resourceId</code> object encapsulates information that
    /// identifies the resource associated with a social network post.
    #[serde(rename="resourceId")]
    pub resource_id: Option<ResourceId>,
    /// An image of the post's author.
    #[serde(rename="imageUrl")]
    pub image_url: Option<String>,
    /// The name of the social network.
    #[serde(rename="type")]
    pub type_: Option<String>,
    /// The URL of the social network post.
    #[serde(rename="referenceUrl")]
    pub reference_url: Option<String>,
    /// The author of the social network post.
    pub author: Option<String>,
}

impl Part for ActivityContentDetailsSocial {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct RelatedEntity {
    /// no description provided
    pub entity: Option<Entity>,
}

impl Part for RelatedEntity {}


/// Information about a resource that received a comment.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityContentDetailsComment {
    /// The <code>resourceId</code> object contains information that
    /// identifies the resource associated with the comment.
    #[serde(rename="resourceId")]
    pub resource_id: Option<ResourceId>,
}

impl Part for ActivityContentDetailsComment {}


/// Basic details about a guide category.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GuideCategorySnippet {
    /// no description provided
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// Description of the guide category.
    pub title: Option<String>,
}

impl Part for GuideCategorySnippet {}


/// Basic details about a video, including title, description, uploader,
/// thumbnails and category.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoSnippet {
    /// The video's description.
    /// @mutable youtube.videos.insert youtube.videos.update
    pub description: Option<String>,
    /// A list of keyword tags associated with the video. Tags may contain spaces.
    pub tags: Option<Vec<String>>,
    /// The <code>default_audio_language</code> property specifies the language
    /// spoken in the video's default audio track.
    #[serde(rename="defaultAudioLanguage")]
    pub default_audio_language: Option<String>,
    /// The ID that YouTube uses to uniquely identify the channel that the
    /// video was uploaded to.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The date and time that the video was uploaded. The value is specified
    /// in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="publishedAt")]
    pub published_at: Option<String>,
    /// Indicates if the video is an upcoming/active live broadcast.
    /// Or it's "none" if the video is not an upcoming/active live broadcast.
    #[serde(rename="liveBroadcastContent")]
    pub live_broadcast_content: Option<String>,
    /// The language of the videos's default snippet.
    #[serde(rename="defaultLanguage")]
    pub default_language: Option<String>,
    /// A map of thumbnail images associated with the video. For each object in the
    /// map, the key is the name of the thumbnail image, and the value is an object
    /// that contains other information about the thumbnail.
    pub thumbnails: Option<ThumbnailDetails>,
    /// The video's title.
    /// @mutable youtube.videos.insert youtube.videos.update
    pub title: Option<String>,
    /// The YouTube <a href="/youtube/v3/docs/videoCategories/list">video
    /// category</a> associated with the video.
    #[serde(rename="categoryId")]
    pub category_id: Option<String>,
    /// Localized snippet selected with the hl parameter. If no such localization
    /// exists, this field is populated with the default snippet. (Read-only)
    pub localized: Option<VideoLocalization>,
    /// Channel title for the channel that the video belongs to.
    #[serde(rename="channelTitle")]
    pub channel_title: Option<String>,
}

impl Part for VideoSnippet {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatMessageSnippet {
    /// Contains a string that can be displayed to the user.
    /// If this field is not present the message is silent, at the moment only
    /// messages of type TOMBSTONE and CHAT_ENDED_EVENT are silent.
    #[serde(rename="displayMessage")]
    pub display_message: Option<String>,
    /// no description provided
    #[serde(rename="messageRetractedDetails")]
    pub message_retracted_details: Option<LiveChatMessageRetractedDetails>,
    /// Details about the Super Chat event, this is only set if the type is
    /// 'superChatEvent'.
    #[serde(rename="superChatDetails")]
    pub super_chat_details: Option<LiveChatSuperChatDetails>,
    /// Details about the funding event, this is only set if the type is
    /// 'fanFundingEvent'.
    #[serde(rename="fanFundingEventDetails")]
    pub fan_funding_event_details: Option<LiveChatFanFundingEventDetails>,
    /// no description provided
    #[serde(rename="messageDeletedDetails")]
    pub message_deleted_details: Option<LiveChatMessageDeletedDetails>,
    /// Whether the message has display content that should be displayed to users.
    #[serde(rename="hasDisplayContent")]
    pub has_display_content: Option<bool>,
    /// The date and time when the message was orignally published. The value is
    /// specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="publishedAt")]
    pub published_at: Option<String>,
    /// no description provided
    #[serde(rename="userBannedDetails")]
    pub user_banned_details: Option<LiveChatUserBannedMessageDetails>,
    /// no description provided
    #[serde(rename="liveChatId")]
    pub live_chat_id: Option<String>,
    /// The ID of the user that authored this message, this field is not always
    /// filled.
    /// textMessageEvent - the user that wrote the message
    /// fanFundingEvent - the user that funded the broadcast
    /// newSponsorEvent - the user that just became a sponsor
    /// messageDeletedEvent - the moderator that took the action
    /// messageRetractedEvent - the author that retracted their message
    /// userBannedEvent - the moderator that took the action
    /// superChatEvent - the user that made the purchase
    #[serde(rename="authorChannelId")]
    pub author_channel_id: Option<String>,
    /// Details about the text message, this is only set if the type is
    /// 'textMessageEvent'.
    #[serde(rename="textMessageDetails")]
    pub text_message_details: Option<LiveChatTextMessageDetails>,
    /// Details about the Super Sticker event, this is only set if the type is
    /// 'superStickerEvent'.
    #[serde(rename="superStickerDetails")]
    pub super_sticker_details: Option<LiveChatSuperStickerDetails>,
    /// The type of message, this will always be present, it determines the
    /// contents of the message as well as which fields will be present.
    #[serde(rename="type")]
    pub type_: Option<String>,
}

impl Part for LiveChatMessageSnippet {}


/// Detailed settings of a stream.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveStreamContentDetails {
    /// Indicates whether the stream is reusable, which means that it
    /// can be bound to multiple broadcasts. It is common for
    /// broadcasters to reuse the same stream for many different
    /// broadcasts if those broadcasts occur at different times.<br><br>
    /// If you set this value to <code>false</code>, then the stream
    /// will not be reusable, which means that it can only be bound to
    /// one broadcast. Non-reusable streams differ from reusable streams in the
    /// following ways:
    /// 
    /// <ul>
    ///   <li>A non-reusable stream can only be bound to one broadcast.</li>
    ///   <li>A non-reusable stream might be deleted by an automated process
    ///     after the broadcast ends.</li>
    ///   <li>The <code><a href="/youtube/v3/live/docs/liveStreams/list">
    ///     liveStreams.list</a></code> method does not list non-reusable streams
    ///     if you call the method and set the <code>mine</code> parameter to
    ///     <code>true</code>. The only way to use that method to retrieve the
    ///     resource for a non-reusable stream is to use the <code>id</code>
    ///     parameter to identify the stream.</li>
    /// </ul>
    #[serde(rename="isReusable")]
    pub is_reusable: Option<bool>,
    /// The ingestion URL where the closed captions of this stream are sent.
    #[serde(rename="closedCaptionsIngestionUrl")]
    pub closed_captions_ingestion_url: Option<String>,
}

impl Part for LiveStreamContentDetails {}


/// A <code><strong>guideCategory</strong></code> resource identifies a category
/// that YouTube algorithmically assigns based on a
/// channel's content or other indicators, such as the channel's popularity. The
/// list is similar to <a
/// href=\"/youtube/v3/docs/videocategory.html\">video categories</a>, with the
/// difference being that a video's uploader can assign a video category but only
/// YouTube can assign a channel category.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GuideCategory {
    /// The <code>snippet</code> object contains basic details about the category,
    /// such as its title.
    pub snippet: Option<GuideCategorySnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#guideCategory"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube uses to uniquely identify the guide category.
    pub id: Option<String>,
}

impl Part for GuideCategory {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelProfileDetails {
    /// The YouTube channel ID.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The channel's display name.
    #[serde(rename="displayName")]
    pub display_name: Option<String>,
    /// The channel's URL.
    #[serde(rename="channelUrl")]
    pub channel_url: Option<String>,
    /// The channels's avatar URL.
    #[serde(rename="profileImageUrl")]
    pub profile_image_url: Option<String>,
}

impl Part for ChannelProfileDetails {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list i18n languages](struct.I18nLanguageListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct I18nLanguageListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// A list of supported i18n languages. In this map, the i18n language ID is
    /// the map key, and its value is the corresponding <code>i18nLanguage</code>
    /// resource.
    pub items: Option<Vec<I18nLanguage>>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#i18nLanguageListResponse"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
}

impl ResponseResult for I18nLanguageListResponse {}

impl ToParts for I18nLanguageListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PlaylistCard {
    /// Starting video, if not the first.
    /// Optional.
    #[serde(rename="startVideoId")]
    pub start_video_id: Option<String>,
    /// Each card can have a custom message.
    /// Optional.
    #[serde(rename="customMessage")]
    pub custom_message: Option<String>,
    /// External playlist ID.
    /// Required.
    #[serde(rename="playlistId")]
    pub playlist_id: Option<String>,
}

impl Part for PlaylistCard {}


/// Information about a channel that a user subscribed to.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityContentDetailsSubscription {
    /// The <code>resourceId</code> object contains information that
    /// identifies the resource that the user subscribed to.
    #[serde(rename="resourceId")]
    pub resource_id: Option<ResourceId>,
}

impl Part for ActivityContentDetailsSubscription {}


/// Information about a video stream.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoFileDetailsVideoStream {
    /// The video stream's bitrate, in bits per second.
    #[serde(rename="bitrateBps")]
    pub bitrate_bps: Option<String>,
    /// A value that uniquely identifies a video vendor. Typically, the value is
    /// a four-letter vendor code.
    pub vendor: Option<String>,
    /// The video codec that the stream uses.
    pub codec: Option<String>,
    /// The encoded video content's width in pixels. You can calculate the
    /// video's encoding aspect ratio as
    /// <code>width_pixels</code>&nbsp;/&nbsp;<code>height_pixels</code>.
    #[serde(rename="widthPixels")]
    pub width_pixels: Option<u32>,
    /// The encoded video content's height in pixels.
    #[serde(rename="heightPixels")]
    pub height_pixels: Option<u32>,
    /// The video content's display aspect ratio, which specifies the aspect
    /// ratio in which the video should be displayed.
    #[serde(rename="aspectRatio")]
    pub aspect_ratio: Option<f64>,
    /// The amount that YouTube needs to rotate the original source content
    /// to properly display the video.
    pub rotation: Option<String>,
    /// The video stream's frame rate, in frames per second.
    #[serde(rename="frameRateFps")]
    pub frame_rate_fps: Option<f64>,
}

impl Part for VideoFileDetailsVideoStream {}


/// A thumbnail is an image representing a YouTube resource.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [set thumbnails](struct.ThumbnailSetCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Thumbnail {
    /// The thumbnail image's URL.
    pub url: Option<String>,
    /// (Optional) Width of the thumbnail image.
    pub width: Option<u32>,
    /// (Optional) Height of the thumbnail image.
    pub height: Option<u32>,
}

impl Resource for Thumbnail {}


/// A <code><strong>channel</strong></code> resource contains
/// information about a YouTube channel.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list channels](struct.ChannelListCall.html) (none)
/// * [update channels](struct.ChannelUpdateCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Channel {
    /// The <code>status</code> object encapsulates information about the privacy
    /// status of the channel.
    pub status: Option<ChannelStatus>,
    /// The <code>invideoPromotion</code> object encapsulates information about
    /// promotion campaign associated with the channel.
    #[serde(rename="invideoPromotion")]
    pub invideo_promotion: Option<InvideoPromotion>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#channel"</code>.
    pub kind: Option<String>,
    /// The <code>statistics</code> object encapsulates statistics for the channel.
    pub statistics: Option<ChannelStatistics>,
    /// The <code>contentOwnerDetails</code> object encapsulates channel data
    /// that is relevant for YouTube Partners linked with the channel.
    #[serde(rename="contentOwnerDetails")]
    pub content_owner_details: Option<ChannelContentOwnerDetails>,
    /// The <code>topicDetails</code> object encapsulates information about
    /// <a href="http://www.freebase.com">Freebase</a> topics associated with the
    /// channel.
    #[serde(rename="topicDetails")]
    pub topic_details: Option<ChannelTopicDetails>,
    /// The <code>contentDetails</code> object encapsulates information about the
    /// channel's content.
    #[serde(rename="contentDetails")]
    pub content_details: Option<ChannelContentDetails>,
    /// The <code>brandingSettings</code> object encapsulates information about
    /// the branding of the channel.
    #[serde(rename="brandingSettings")]
    pub branding_settings: Option<ChannelBrandingSettings>,
    /// The <code>conversionPings</code> object encapsulates information about
    /// conversion pings that need to be respected by the channel.
    #[serde(rename="conversionPings")]
    pub conversion_pings: Option<ChannelConversionPings>,
    /// The <code>snippet</code> object contains basic details about the channel,
    /// such as its title, description, and thumbnail images.
    pub snippet: Option<ChannelSnippet>,
    /// The <code>auditionDetails</code> object encapsulates channel data
    /// that is relevant for YouTube Partners during the audition process.
    #[serde(rename="auditDetails")]
    pub audit_details: Option<ChannelAuditDetails>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube uses to uniquely identify the channel.
    pub id: Option<String>,
    /// Localizations for different languages
    pub localizations: Option<HashMap<String, ChannelLocalization>>,
}

impl RequestValue for Channel {}
impl Resource for Channel {}
impl ResponseResult for Channel {}

impl ToParts for Channel {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.status.is_some() { r = r + "status,"; }
        if self.invideo_promotion.is_some() { r = r + "invideoPromotion,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.statistics.is_some() { r = r + "statistics,"; }
        if self.content_owner_details.is_some() { r = r + "contentOwnerDetails,"; }
        if self.topic_details.is_some() { r = r + "topicDetails,"; }
        if self.content_details.is_some() { r = r + "contentDetails,"; }
        if self.branding_settings.is_some() { r = r + "brandingSettings,"; }
        if self.conversion_pings.is_some() { r = r + "conversionPings,"; }
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.audit_details.is_some() { r = r + "auditDetails,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.id.is_some() { r = r + "id,"; }
        if self.localizations.is_some() { r = r + "localizations,"; }
        r.pop();
        r
    }
}

/// Channel localization setting
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelLocalization {
    /// The localized strings for channel's description.
    pub description: Option<String>,
    /// The localized strings for channel's title.
    pub title: Option<String>,
}

impl Part for ChannelLocalization {}


/// Statistics about the live broadcast. These represent a snapshot of the values
/// at the time of the request. Statistics are only returned for live broadcasts.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveBroadcastStatistics {
    /// The total number of live chat messages currently on the broadcast. The
    /// property and its value will be present if the broadcast is public, has
    /// the live chat feature enabled, and has at least one message. Note that
    /// this field will not be filled after the broadcast ends. So this property
    /// would not identify the number of chat messages for an archived video of a
    /// completed live broadcast.
    #[serde(rename="totalChatCount")]
    pub total_chat_count: Option<String>,
}

impl Part for LiveBroadcastStatistics {}


/// A search result contains information about a YouTube video, channel, or
/// playlist that matches the search parameters specified in an API request.
/// While a search result points to a uniquely identifiable resource, like a
/// video, it does not have its own persistent data.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SearchResult {
    /// The <code>snippet</code> object contains basic details about a search
    /// result, such as its title or description. For example, if the search result
    /// is a video, then the title will be the
    /// video's title and the description will be the video's description.
    pub snippet: Option<SearchResultSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#searchResult"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>id</code> object contains information that can be used to
    /// uniquely identify the resource that matches the search request.
    pub id: Option<ResourceId>,
}

impl Part for SearchResult {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list video categories](struct.VideoCategoryListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoCategoryListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#videoCategoryListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of video categories that can be associated with YouTube videos. In
    /// this map, the video category ID is the map key, and its value is the
    /// corresponding <code>videoCategory</code> resource.
    pub items: Option<Vec<VideoCategory>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the previous page in the result set.
    #[serde(rename="prevPageToken")]
    pub prev_page_token: Option<String>,
    /// General pagination information.
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for VideoCategoryListResponse {}

impl ToParts for VideoCategoryListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.prev_page_token.is_some() { r = r + "prevPageToken,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// Information specific to a store on a merchandising platform linked to a
/// YouTube channel.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelToStoreLinkDetails {
    /// Landing page of the store.
    #[serde(rename="storeUrl")]
    pub store_url: Option<String>,
    /// Name of the store.
    #[serde(rename="storeName")]
    pub store_name: Option<String>,
}

impl Part for ChannelToStoreLinkDetails {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [v3 infocards youtube](struct.YoutubeV3InfocardCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct InfoCards {
    /// A list of infocards.
    pub items: Option<Vec<InfoCard>>,
}

impl RequestValue for InfoCards {}
impl ResponseResult for InfoCards {}

impl ToParts for InfoCards {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.items.is_some() { r = r + "items,"; }
        r.pop();
        r
    }
}

/// Video processing progress and completion time estimate.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoProcessingDetailsProcessingProgress {
    /// An estimate of the amount of time, in millseconds, that YouTube needs
    /// to finish processing the video.
    #[serde(rename="timeLeftMs")]
    pub time_left_ms: Option<String>,
    /// The number of parts of the video that YouTube has already processed.
    /// You can estimate the percentage of the video that YouTube has already
    /// processed by calculating:<br>
    /// <code>100 * parts_processed / parts_total</code><br><br>
    /// Note that since the estimated number of parts could increase without
    /// a corresponding increase in the number of parts that have already been
    /// processed, it is possible that the calculated progress could
    /// periodically decrease while YouTube processes a video.
    #[serde(rename="partsProcessed")]
    pub parts_processed: Option<String>,
    /// An estimate of the total number of parts that need to be processed
    /// for the video. The number may be updated with more precise estimates
    /// while YouTube processes the video.
    #[serde(rename="partsTotal")]
    pub parts_total: Option<String>,
}

impl Part for VideoProcessingDetailsProcessingProgress {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list videos](struct.VideoListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#videoListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// no description provided
    pub items: Option<Vec<Video>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the previous page in the result set.
    #[serde(rename="prevPageToken")]
    pub prev_page_token: Option<String>,
    /// General pagination information.
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for VideoListResponse {}

impl ToParts for VideoListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.prev_page_token.is_some() { r = r + "prevPageToken,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LanguageTag {
    /// no description provided
    pub value: Option<String>,
}

impl Part for LanguageTag {}


/// A <code><strong>subscription</strong></code> resource contains information
/// about a YouTube user subscription.  A subscription notifies a user when new
/// videos are added to a channel or when another user takes one of several
/// actions on YouTube, such as uploading a video, rating a video, or commenting
/// on a video.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [insert subscriptions](struct.SubscriptionInsertCall.html) (request|response)
/// * [list subscriptions](struct.SubscriptionListCall.html) (none)
/// * [delete subscriptions](struct.SubscriptionDeleteCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Subscription {
    /// The <code>snippet</code> object contains basic details about the
    /// subscription, including its title and the channel that the user subscribed
    /// to.
    pub snippet: Option<SubscriptionSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#subscription"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>contentDetails</code> object contains basic statistics about the
    /// subscription.
    #[serde(rename="contentDetails")]
    pub content_details: Option<SubscriptionContentDetails>,
    /// The <code>subscriberSnippet</code> object contains basic details about the
    /// subscriber.
    #[serde(rename="subscriberSnippet")]
    pub subscriber_snippet: Option<SubscriptionSubscriberSnippet>,
    /// The ID that YouTube uses to uniquely identify the subscription.
    pub id: Option<String>,
}

impl RequestValue for Subscription {}
impl Resource for Subscription {}
impl ResponseResult for Subscription {}

impl ToParts for Subscription {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.content_details.is_some() { r = r + "contentDetails,"; }
        if self.subscriber_snippet.is_some() { r = r + "subscriberSnippet,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveStreamSnippet {
    /// no description provided
    #[serde(rename="isDefaultStream")]
    pub is_default_stream: Option<bool>,
    /// The ID that YouTube uses to uniquely identify the channel that
    /// is transmitting the stream.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The stream's description. The value cannot be longer than 10000
    /// characters.
    pub description: Option<String>,
    /// The date and time that the stream was created. The value is specified in
    /// <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="publishedAt")]
    pub published_at: Option<String>,
    /// The stream's title. The value must be between 1 and 128 characters long.
    pub title: Option<String>,
}

impl Part for LiveStreamSnippet {}


/// JSON template for the status part of a channel.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelStatus {
    /// no description provided
    #[serde(rename="selfDeclaredMadeForKids")]
    pub self_declared_made_for_kids: Option<bool>,
    /// Privacy status of the channel.
    #[serde(rename="privacyStatus")]
    pub privacy_status: Option<String>,
    /// no description provided
    #[serde(rename="madeForKids")]
    pub made_for_kids: Option<bool>,
    /// If true, then the user is linked to either a YouTube username or G+
    /// account. Otherwise, the user doesn't have a public YouTube identity.
    #[serde(rename="isLinked")]
    pub is_linked: Option<bool>,
    /// The long uploads status of this channel. See
    /// https://support.google.com/youtube/answer/71673 for more information.
    #[serde(rename="longUploadsStatus")]
    pub long_uploads_status: Option<String>,
}

impl Part for ChannelStatus {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list channels](struct.ChannelListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#channelListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// no description provided
    pub items: Option<Vec<Channel>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the previous page in the result set.
    #[serde(rename="prevPageToken")]
    pub prev_page_token: Option<String>,
    /// General pagination information.
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for ChannelListResponse {}

impl ToParts for ChannelListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.prev_page_token.is_some() { r = r + "prevPageToken,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [delete channel sections](struct.ChannelSectionDeleteCall.html) (none)
/// * [update channel sections](struct.ChannelSectionUpdateCall.html) (request|response)
/// * [list channel sections](struct.ChannelSectionListCall.html) (none)
/// * [insert channel sections](struct.ChannelSectionInsertCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelSection {
    /// The <code>snippet</code> object contains basic details about the channel
    /// section, such as its type, style and title.
    pub snippet: Option<ChannelSectionSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#channelSection"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>targeting</code> object contains basic targeting settings about
    /// the channel section.
    pub targeting: Option<ChannelSectionTargeting>,
    /// The <code>contentDetails</code> object contains details about the channel
    /// section content, such as a list of playlists or channels featured in the
    /// section.
    #[serde(rename="contentDetails")]
    pub content_details: Option<ChannelSectionContentDetails>,
    /// The ID that YouTube uses to uniquely identify the channel section.
    pub id: Option<String>,
    /// Localizations for different languages
    pub localizations: Option<HashMap<String, ChannelSectionLocalization>>,
}

impl RequestValue for ChannelSection {}
impl Resource for ChannelSection {}
impl ResponseResult for ChannelSection {}

impl ToParts for ChannelSection {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.targeting.is_some() { r = r + "targeting,"; }
        if self.content_details.is_some() { r = r + "contentDetails,"; }
        if self.id.is_some() { r = r + "id,"; }
        if self.localizations.is_some() { r = r + "localizations,"; }
        r.pop();
        r
    }
}

/// A <code><strong>comment thread</strong></code> represents information that
/// applies to a top level comment and all its replies. It can also include the
/// top level comment itself and some of the replies.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [update comment threads](struct.CommentThreadUpdateCall.html) (request|response)
/// * [list comment threads](struct.CommentThreadListCall.html) (none)
/// * [insert comment threads](struct.CommentThreadInsertCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct CommentThread {
    /// The <code>snippet</code> object contains basic details about the comment
    /// thread and also the top level comment.
    pub snippet: Option<CommentThreadSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#commentThread"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube uses to uniquely identify the comment thread.
    pub id: Option<String>,
    /// The <code>replies</code> object contains a limited number of replies (if
    /// any) to the top level comment found in the snippet.
    pub replies: Option<CommentThreadReplies>,
}

impl RequestValue for CommentThread {}
impl Resource for CommentThread {}
impl ResponseResult for CommentThread {}

impl ToParts for CommentThread {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.id.is_some() { r = r + "id,"; }
        if self.replies.is_some() { r = r + "replies,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list live broadcasts](struct.LiveBroadcastListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveBroadcastListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#liveBroadcastListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of broadcasts that match the request criteria.
    pub items: Option<Vec<LiveBroadcast>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the previous page in the result set.
    #[serde(rename="prevPageToken")]
    pub prev_page_token: Option<String>,
    /// General pagination information.
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for LiveBroadcastListResponse {}

impl ToParts for LiveBroadcastListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.prev_page_token.is_some() { r = r + "prevPageToken,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list captions](struct.CaptionListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct CaptionListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// A list of captions that match the request criteria.
    pub items: Option<Vec<Caption>>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#captionListResponse"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
}

impl ResponseResult for CaptionListResponse {}

impl ToParts for CaptionListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        r.pop();
        r
    }
}

/// Brief description of the live stream status.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveStreamStatus {
    /// no description provided
    #[serde(rename="streamStatus")]
    pub stream_status: Option<String>,
    /// The health status of the stream.
    #[serde(rename="healthStatus")]
    pub health_status: Option<LiveStreamHealthStatus>,
}

impl Part for LiveStreamStatus {}


/// Ratings schemes. The country-specific ratings are mostly for
/// movies and shows.
/// LINT.IfChange
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ContentRating {
    /// A rating that YouTube uses to identify age-restricted content.
    #[serde(rename="ytRating")]
    pub yt_rating: Option<String>,
    /// The video's rating from the Canadian Radio-Television and
    /// Telecommunications Commission (CRTC) for Canadian French-language
    /// broadcasts. For more information, see the
    /// <a href="http://www.cbsc.ca/english/agvot/frenchsystem.php">Canadian
    /// Broadcast Standards Council</a> website.
    #[serde(rename="catvfrRating")]
    pub catvfr_rating: Option<String>,
    /// The video's Central Board of Film Certification (CBFC - India) rating.
    #[serde(rename="cbfcRating")]
    pub cbfc_rating: Option<String>,
    /// The video's rating from Thailand's Board of Film and Video Censors.
    #[serde(rename="bfvcRating")]
    pub bfvc_rating: Option<String>,
    /// The video's rating from the Austrian Board of Media Classification
    /// (Bundesministerium f&uuml;r Unterricht, Kunst und Kultur).
    #[serde(rename="bmukkRating")]
    pub bmukk_rating: Option<String>,
    /// The video's rating in Switzerland.
    #[serde(rename="chfilmRating")]
    pub chfilm_rating: Option<String>,
    /// The video's rating from Taiwan's Ministry of Culture
    /// (&#25991;&#21270;&#37096;).
    #[serde(rename="moctwRating")]
    pub moctw_rating: Option<String>,
    /// Rating system for Canadian TV - Canadian TV Classification System
    /// The video's rating from the Canadian Radio-Television and
    /// Telecommunications Commission (CRTC) for Canadian English-language
    /// broadcasts. For more information, see the
    /// <a href="http://www.cbsc.ca/english/agvot/englishsystem.php">Canadian
    /// Broadcast Standards Council</a> website.
    #[serde(rename="catvRating")]
    pub catv_rating: Option<String>,
    /// The video's rating in Peru.
    #[serde(rename="pefilmRating")]
    pub pefilm_rating: Option<String>,
    /// Reasons that explain why the video received its DJCQT (Brazil) rating.
    #[serde(rename="djctqRatingReasons")]
    pub djctq_rating_reasons: Option<Vec<String>>,
    /// The video's INCAA (Instituto Nacional de Cine y Artes Audiovisuales -
    /// Argentina) rating.
    #[serde(rename="incaaRating")]
    pub incaa_rating: Option<String>,
    /// The video's rating in Israel.
    #[serde(rename="ilfilmRating")]
    pub ilfilm_rating: Option<String>,
    /// The video's rating from Luxembourg's Commission de surveillance
    /// de la classification des films (CSCF).
    #[serde(rename="cscfRating")]
    pub cscf_rating: Option<String>,
    /// The video's Freiwillige Selbstkontrolle der Filmwirtschaft
    /// (FSK - Germany) rating.
    #[serde(rename="fskRating")]
    pub fsk_rating: Option<String>,
    /// The video's Korea Media Rating Board
    /// (&#50689;&#49345;&#47932;&#46321;&#44553;&#50948;&#50896;&#54924;) rating.
    /// The KMRB rates videos in South Korea.
    #[serde(rename="kmrbRating")]
    pub kmrb_rating: Option<String>,
    /// The video's Departamento de Justi&ccedil;a, Classifica&ccedil;&atilde;o,
    /// Qualifica&ccedil;&atilde;o e T&iacute;tulos (DJCQT - Brazil) rating.
    #[serde(rename="djctqRating")]
    pub djctq_rating: Option<String>,
    /// The video's rating from Hong Kong's Office for Film, Newspaper
    /// and Article Administration.
    #[serde(rename="fcoRating")]
    pub fco_rating: Option<String>,
    /// The video's rating from Medietilsynet, the Norwegian Media Authority.
    #[serde(rename="medietilsynetRating")]
    pub medietilsynet_rating: Option<String>,
    /// The video's rating in Greece.
    #[serde(rename="grfilmRating")]
    pub grfilm_rating: Option<String>,
    /// The video's Consejo de Calificaci&oacute;n Cinematogr&aacute;fica (Chile)
    /// rating.
    #[serde(rename="cccRating")]
    pub ccc_rating: Option<String>,
    /// The video's rating from Ireland's Raidi&oacute; Teilif&iacute;s
    /// &Eacute;ireann.
    #[serde(rename="rteRating")]
    pub rte_rating: Option<String>,
    /// The rating system for MENA countries, a clone of MPAA. It is needed to
    /// prevent titles go live w/o additional QC check, since some of them can be
    /// inappropriate for the countries at all. See b/33408548 for more details.
    #[serde(rename="menaMpaaRating")]
    pub mena_mpaa_rating: Option<String>,
    /// <span class="deprecated">This property has been deprecated. Use the
    /// <code><a
    /// href="#contentDetails.contentRating.cncRating">contentDetails.contentRating.cncRating</a></code>
    /// instead.</span>
    #[serde(rename="fmocRating")]
    pub fmoc_rating: Option<String>,
    /// The video's Eirin (&#26144;&#20523;) rating.
    /// Eirin is the Japanese rating system.
    #[serde(rename="eirinRating")]
    pub eirin_rating: Option<String>,
    /// The video's rating from Portugal's Comiss&atilde;o de
    /// Classifica&ccedil;&atilde;o de Espect&acute;culos.
    #[serde(rename="cceRating")]
    pub cce_rating: Option<String>,
    /// The video's rating from the Nacion&atilde;lais Kino centrs (National Film
    /// Centre of Latvia).
    #[serde(rename="nkclvRating")]
    pub nkclv_rating: Option<String>,
    /// Rating system in Turkey - Evaluation and Classification Board of the
    /// Ministry of Culture and Tourism
    #[serde(rename="ecbmctRating")]
    pub ecbmct_rating: Option<String>,
    /// The video's rating from South Africa's Film and Publication Board.
    #[serde(rename="fpbRating")]
    pub fpb_rating: Option<String>,
    /// The video's rating system for Vietnam - MCST
    #[serde(rename="mcstRating")]
    pub mcst_rating: Option<String>,
    /// The video's rating in Iceland.
    #[serde(rename="smaisRating")]
    pub smais_rating: Option<String>,
    /// The National Media Council ratings system for United Arab Emirates.
    #[serde(rename="nmcRating")]
    pub nmc_rating: Option<String>,
    /// The video's Canadian Home Video Rating System (CHVRS) rating.
    #[serde(rename="chvrsRating")]
    pub chvrs_rating: Option<String>,
    /// The video's rating from Italy's Autorit&agrave; per le Garanzie nelle
    /// Comunicazioni (AGCOM).
    #[serde(rename="agcomRating")]
    pub agcom_rating: Option<String>,
    /// The video's Ministerio de Cultura (Colombia) rating.
    #[serde(rename="mocRating")]
    pub moc_rating: Option<String>,
    /// The video's rating from the Hungarian Nemzeti Filmiroda, the Rating
    /// Committee of the National Office of Film.
    #[serde(rename="rcnofRating")]
    pub rcnof_rating: Option<String>,
    /// The video's rating from Malaysia's Film Censorship Board.
    #[serde(rename="fcbmRating")]
    pub fcbm_rating: Option<String>,
    /// The video's NICAM/Kijkwijzer rating from the Nederlands Instituut
    /// voor de Classificatie van Audiovisuele Media (Netherlands).
    #[serde(rename="kijkwijzerRating")]
    pub kijkwijzer_rating: Option<String>,
    /// Rating system in France - Commission de classification cinematographique
    #[serde(rename="cncRating")]
    pub cnc_rating: Option<String>,
    /// The video's rating from Singapore's Media Development Authority (MDA) and,
    /// specifically, it's Board of Film Censors (BFC).
    #[serde(rename="mdaRating")]
    pub mda_rating: Option<String>,
    /// The video's rating from Nigeria's National Film and Video Censors Board.
    #[serde(rename="nfvcbRating")]
    pub nfvcb_rating: Option<String>,
    /// The video's rating in Venezuela.
    #[serde(rename="resorteviolenciaRating")]
    pub resorteviolencia_rating: Option<String>,
    /// The video's rating from France's Conseil sup&eacute;rieur de
    /// laudiovisuel, which rates broadcast content.
    #[serde(rename="csaRating")]
    pub csa_rating: Option<String>,
    /// The video's Office of Film and Literature Classification
    /// (OFLC - New Zealand) rating.
    #[serde(rename="oflcRating")]
    pub oflc_rating: Option<String>,
    /// The video's TV Parental Guidelines (TVPG) rating.
    #[serde(rename="tvpgRating")]
    pub tvpg_rating: Option<String>,
    /// The video's rating from the <a href="http://www.nfc.bg/">Bulgarian
    /// National Film Center</a>.
    #[serde(rename="nfrcRating")]
    pub nfrc_rating: Option<String>,
    /// The video's rating from Malta's Film Age-Classification Board.
    #[serde(rename="mccaaRating")]
    pub mccaa_rating: Option<String>,
    /// The video's General Directorate of Radio, Television and Cinematography
    /// (Mexico) rating.
    #[serde(rename="rtcRating")]
    pub rtc_rating: Option<String>,
    /// The video's rating from the Ministero dei Beni e delle Attivit&agrave;
    /// Culturali e del Turismo (Italy).
    #[serde(rename="mibacRating")]
    pub mibac_rating: Option<String>,
    /// The video's British Board of Film Classification (BBFC) rating.
    #[serde(rename="bbfcRating")]
    pub bbfc_rating: Option<String>,
    /// The video's rating in Egypt.
    #[serde(rename="egfilmRating")]
    pub egfilm_rating: Option<String>,
    /// The video's rating from the Commission de Contr&ocirc;le des Films
    /// (Belgium).
    #[serde(rename="cicfRating")]
    pub cicf_rating: Option<String>,
    /// The video's rating in Poland.
    #[serde(rename="nbcplRating")]
    pub nbcpl_rating: Option<String>,
    /// The video's rating from the Maldives National Bureau of Classification.
    #[serde(rename="nbcRating")]
    pub nbc_rating: Option<String>,
    /// The video's Motion Picture Association of America (MPAA) rating.
    #[serde(rename="mpaaRating")]
    pub mpaa_rating: Option<String>,
    /// The video's Irish Film Classification Office (IFCO - Ireland) rating.
    /// See the <a
    /// href="http://www.ifco.ie/website/ifco/ifcoweb.nsf/web/classcatintro">IFCO</a>
    /// website for more information.
    #[serde(rename="ifcoRating")]
    pub ifco_rating: Option<String>,
    /// The rating system for trailer, DVD, and Ad in the US.  See
    /// http://movielabs.com/md/ratings/v2.3/html/US_MPAAT_Ratings.html.
    #[serde(rename="mpaatRating")]
    pub mpaat_rating: Option<String>,
    /// The video's Australian Classification Board (ACB) or Australian
    /// Communications and Media Authority (ACMA) rating. ACMA ratings are used
    /// to classify children's television programming.
    #[serde(rename="acbRating")]
    pub acb_rating: Option<String>,
    /// The video's rating in Estonia.
    #[serde(rename="eefilmRating")]
    pub eefilm_rating: Option<String>,
    /// The video's rating in the Czech Republic.
    #[serde(rename="czfilmRating")]
    pub czfilm_rating: Option<String>,
    /// The video's rating from Indonesia's Lembaga Sensor Film.
    #[serde(rename="lsfRating")]
    pub lsf_rating: Option<String>,
    /// The video's National Film Registry of the Russian Federation
    /// (MKRF - Russia) rating.
    #[serde(rename="russiaRating")]
    pub russia_rating: Option<String>,
    /// The video's rating from the Kenya Film Classification Board.
    #[serde(rename="kfcbRating")]
    pub kfcb_rating: Option<String>,
    /// The video's rating from the Movie and Television Review and
    /// Classification Board (Philippines).
    #[serde(rename="mtrcbRating")]
    pub mtrcb_rating: Option<String>,
    /// The video's Anatel (Asociaci&oacute;n Nacional de Televisi&oacute;n)
    /// rating for Chilean television.
    #[serde(rename="anatelRating")]
    pub anatel_rating: Option<String>,
    /// Reasons that explain why the video received its FPB (South Africa) rating.
    #[serde(rename="fpbRatingReasons")]
    pub fpb_rating_reasons: Option<Vec<String>>,
    /// The video's rating from Statens medier&aring;d (Sweden's National Media
    /// Council).
    #[serde(rename="smsaRating")]
    pub smsa_rating: Option<String>,
    /// The video's rating from Romania's CONSILIUL NATIONAL AL AUDIOVIZUALULUI
    /// (CNA).
    #[serde(rename="cnaRating")]
    pub cna_rating: Option<String>,
    /// The video's Instituto de la Cinematograf&iacute;a y de las Artes
    /// Audiovisuales (ICAA - Spain) rating.
    #[serde(rename="icaaRating")]
    pub icaa_rating: Option<String>,
    /// The video's rating from the Danish Film Institute's (Det Danske
    /// Filminstitut) Media Council for Children and Young People.
    #[serde(rename="mccypRating")]
    pub mccyp_rating: Option<String>,
    /// The video's rating in Slovakia.
    #[serde(rename="skfilmRating")]
    pub skfilm_rating: Option<String>,
    /// The video's rating from Finland's Kansallinen Audiovisuaalinen Instituutti
    /// (National Audiovisual Institute).
    #[serde(rename="mekuRating")]
    pub meku_rating: Option<String>,
}

impl Part for ContentRating {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [insert abuse reports](struct.AbuseReportInsertCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct AbuseReport {
    /// no description provided
    #[serde(rename="relatedEntities")]
    pub related_entities: Option<Vec<RelatedEntity>>,
    /// no description provided
    #[serde(rename="abuseTypes")]
    pub abuse_types: Option<Vec<AbuseType>>,
    /// no description provided
    pub description: Option<String>,
    /// no description provided
    pub subject: Option<Entity>,
}

impl RequestValue for AbuseReport {}
impl Resource for AbuseReport {}
impl ResponseResult for AbuseReport {}

impl ToParts for AbuseReport {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.related_entities.is_some() { r = r + "relatedEntities,"; }
        if self.abuse_types.is_some() { r = r + "abuseTypes,"; }
        if self.description.is_some() { r = r + "description,"; }
        if self.subject.is_some() { r = r + "subject,"; }
        r.pop();
        r
    }
}

/// ChannelSection targeting setting.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelSectionTargeting {
    /// The language the channel section is targeting.
    pub languages: Option<Vec<String>>,
    /// The region the channel section is targeting.
    pub regions: Option<Vec<String>>,
    /// The country the channel section is targeting.
    pub countries: Option<Vec<String>>,
}

impl Part for ChannelSectionTargeting {}


/// Details about the content of a channel.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelContentDetails {
    /// no description provided
    #[serde(rename="relatedPlaylists")]
    pub related_playlists: Option<ChannelContentDetailsRelatedPlaylists>,
}

impl Part for ChannelContentDetails {}


/// Branding properties for images associated with the channel.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ImageSettings {
    /// Banner image. TV size medium resolution (1280x720).
    #[serde(rename="bannerTvMediumImageUrl")]
    pub banner_tv_medium_image_url: Option<String>,
    /// The image map script for the large banner image.
    #[serde(rename="largeBrandedBannerImageImapScript")]
    pub large_branded_banner_image_imap_script: Option<LocalizedProperty>,
    /// Banner image. Mobile size (640x175).
    #[serde(rename="bannerMobileImageUrl")]
    pub banner_mobile_image_url: Option<String>,
    /// The URL for the 640px by 70px banner image that appears below the video
    /// player in the default view of the video watch page.
    /// The URL for the image that appears above the top-left corner of the video
    /// player. This is a 25-pixel-high image with a flexible width that cannot
    /// exceed 170 pixels.
    #[serde(rename="smallBrandedBannerImageUrl")]
    pub small_branded_banner_image_url: Option<LocalizedProperty>,
    /// Banner image. Tablet size high resolution (2276x377).
    #[serde(rename="bannerTabletHdImageUrl")]
    pub banner_tablet_hd_image_url: Option<String>,
    /// Banner image. Tablet size low resolution (1138x188).
    #[serde(rename="bannerTabletLowImageUrl")]
    pub banner_tablet_low_image_url: Option<String>,
    /// Banner image. Mobile size medium/high resolution (960x263).
    #[serde(rename="bannerMobileMediumHdImageUrl")]
    pub banner_mobile_medium_hd_image_url: Option<String>,
    /// The URL for a 1px by 1px tracking pixel that can be used to collect
    /// statistics for views of the channel or video pages.
    #[serde(rename="trackingImageUrl")]
    pub tracking_image_url: Option<String>,
    /// Banner image. Mobile size high resolution (1440x395).
    #[serde(rename="bannerMobileExtraHdImageUrl")]
    pub banner_mobile_extra_hd_image_url: Option<String>,
    /// Banner image. Tablet size (1707x283).
    #[serde(rename="bannerTabletImageUrl")]
    pub banner_tablet_image_url: Option<String>,
    /// Banner image. Mobile size low resolution (320x88).
    #[serde(rename="bannerMobileLowImageUrl")]
    pub banner_mobile_low_image_url: Option<String>,
    /// Banner image. TV size extra high resolution (2120x1192).
    #[serde(rename="bannerTvImageUrl")]
    pub banner_tv_image_url: Option<String>,
    /// Banner image. TV size low resolution (854x480).
    #[serde(rename="bannerTvLowImageUrl")]
    pub banner_tv_low_image_url: Option<String>,
    /// Banner image. Tablet size extra high resolution (2560x424).
    #[serde(rename="bannerTabletExtraHdImageUrl")]
    pub banner_tablet_extra_hd_image_url: Option<String>,
    /// The URL for the 854px by 70px image that appears below the video player in
    /// the expanded video view of the video watch page.
    #[serde(rename="largeBrandedBannerImageUrl")]
    pub large_branded_banner_image_url: Option<LocalizedProperty>,
    /// Banner image. TV size high resolution (1920x1080).
    #[serde(rename="bannerTvHighImageUrl")]
    pub banner_tv_high_image_url: Option<String>,
    /// The URL for the background image shown on the video watch page. The image
    /// should be 1200px by 615px, with a maximum file size of 128k.
    #[serde(rename="backgroundImageUrl")]
    pub background_image_url: Option<LocalizedProperty>,
    /// The image map script for the small banner image.
    #[serde(rename="smallBrandedBannerImageImapScript")]
    pub small_branded_banner_image_imap_script: Option<LocalizedProperty>,
    /// Banner image. Desktop size (1060x175).
    #[serde(rename="bannerImageUrl")]
    pub banner_image_url: Option<String>,
    /// Banner image. Mobile size high resolution (1280x360).
    #[serde(rename="bannerMobileHdImageUrl")]
    pub banner_mobile_hd_image_url: Option<String>,
    /// This is used only in update requests; if it's set, we use this URL to
    /// generate all of the above banner URLs.
    #[serde(rename="bannerExternalUrl")]
    pub banner_external_url: Option<String>,
    /// no description provided
    #[serde(rename="watchIconImageUrl")]
    pub watch_icon_image_url: Option<String>,
}

impl Part for ImageSettings {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [v3 infocards list youtube](struct.YoutubeV3InfocardListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct InfocardListResponse {
    /// A list of infocards.
    pub items: Option<Vec<InfoCard>>,
    /// Identifies what kind of resource this is.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
}

impl ResponseResult for InfocardListResponse {}

impl ToParts for InfocardListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.items.is_some() { r = r + "items,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        r.pop();
        r
    }
}

/// A <code><strong>comment</strong></code> represents a single YouTube comment.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [insert comments](struct.CommentInsertCall.html) (request|response)
/// * [set moderation status comments](struct.CommentSetModerationStatuCall.html) (none)
/// * [update comments](struct.CommentUpdateCall.html) (request|response)
/// * [delete comments](struct.CommentDeleteCall.html) (none)
/// * [mark as spam comments](struct.CommentMarkAsSpamCall.html) (none)
/// * [list comments](struct.CommentListCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Comment {
    /// The <code>snippet</code> object contains basic details about the comment.
    pub snippet: Option<CommentSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#comment"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube uses to uniquely identify the comment.
    pub id: Option<String>,
}

impl RequestValue for Comment {}
impl Resource for Comment {}
impl ResponseResult for Comment {}

impl ToParts for Comment {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// A <code><strong>caption</strong></code> resource represents a YouTube
/// caption track. A caption track is associated with exactly one YouTube
/// video.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [update captions](struct.CaptionUpdateCall.html) (request|response)
/// * [list captions](struct.CaptionListCall.html) (none)
/// * [delete captions](struct.CaptionDeleteCall.html) (none)
/// * [insert captions](struct.CaptionInsertCall.html) (request|response)
/// * [download captions](struct.CaptionDownloadCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Caption {
    /// The <code>snippet</code> object contains basic details about the caption.
    pub snippet: Option<CaptionSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#caption"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube uses to uniquely identify the caption track.
    pub id: Option<String>,
}

impl RequestValue for Caption {}
impl Resource for Caption {}
impl ResponseResult for Caption {}

impl ToParts for Caption {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// Details about a channel bulletin post.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityContentDetailsBulletin {
    /// The <code>resourceId</code> object contains information that
    /// identifies the resource associated with a bulletin post.
    /// @mutable youtube.activities.insert
    #[serde(rename="resourceId")]
    pub resource_id: Option<ResourceId>,
}

impl Part for ActivityContentDetailsBulletin {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelCard {
    /// External channel ID.
    /// Required.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// Each card can have a custom message.
    /// Required.
    #[serde(rename="customMessage")]
    pub custom_message: Option<String>,
}

impl Part for ChannelCard {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LocalizedString {
    /// no description provided
    pub language: Option<String>,
    /// no description provided
    pub value: Option<String>,
}

impl Part for LocalizedString {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct MembershipsDuration {
    /// The cumulative time the user has been a member across all levels in
    /// complete months (the time is rounded down to the nearest integer).
    #[serde(rename="memberTotalDurationMonths")]
    pub member_total_duration_months: Option<i32>,
    /// The date and time when the user became a continuous member across all
    /// levels.
    #[serde(rename="memberSince")]
    pub member_since: Option<String>,
}

impl Part for MembershipsDuration {}


/// Describes information necessary for ingesting an RTMP or an HTTP stream.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct IngestionInfo {
    /// The backup ingestion URL that you should use to stream video to
    /// YouTube. You have the option of simultaneously streaming the content
    /// that you are sending to the <code>ingestionAddress</code> to this URL.
    #[serde(rename="backupIngestionAddress")]
    pub backup_ingestion_address: Option<String>,
    /// The HTTP or RTMP stream name that YouTube assigns to the video stream.
    #[serde(rename="streamName")]
    pub stream_name: Option<String>,
    /// The primary ingestion URL that you should use to stream video to
    /// YouTube. You must stream video to this URL.<br><br>
    /// Depending on which application or tool you use to encode
    /// your video stream, you may need to enter the stream URL and stream
    /// name separately or you may need to concatenate them in the following
    /// format:<br><pre><strong>STREAM_URL/STREAM_NAME</strong></pre>
    #[serde(rename="ingestionAddress")]
    pub ingestion_address: Option<String>,
    /// This ingestion url may be used instead of
    /// <code>backupIngestionAddress</code> in order to stream via RTMPS. Not
    /// applicable to non-RTMP streams.
    #[serde(rename="rtmpsBackupIngestionAddress")]
    pub rtmps_backup_ingestion_address: Option<String>,
    /// This ingestion url may be used instead of
    /// <code>ingestionAddress</code> in order to stream via RTMPS. Not applicable
    /// to non-RTMP streams.
    #[serde(rename="rtmpsIngestionAddress")]
    pub rtmps_ingestion_address: Option<String>,
}

impl Part for IngestionInfo {}


/// A <code><strong>videoCategory</strong></code> resource identifies a
/// category that has been or could be associated with uploaded videos.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoCategory {
    /// The <code>snippet</code> object contains basic details about the video
    /// category, including its title.
    pub snippet: Option<VideoCategorySnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#videoCategory"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube uses to uniquely identify the video category.
    pub id: Option<String>,
}

impl Part for VideoCategory {}


/// Basic details about a playlist, including title, description and thumbnails.
/// Basic details of a YouTube Playlist item provided by the author.
/// Next ID: 13
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PlaylistItemSnippet {
    /// The ID that YouTube uses to uniquely identify the user that added
    /// the item to the playlist.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The item's description.
    pub description: Option<String>,
    /// The item's title.
    pub title: Option<String>,
    /// The <code>id</code> object contains information that can be used to
    /// uniquely identify the resource that is included in the playlist as
    /// the playlist item.
    #[serde(rename="resourceId")]
    pub resource_id: Option<ResourceId>,
    /// The ID that YouTube uses to uniquely identify thGe playlist that the
    /// playlist item is in.
    #[serde(rename="playlistId")]
    pub playlist_id: Option<String>,
    /// The date and time that the item was added to the playlist. The value is
    /// specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="publishedAt")]
    pub published_at: Option<String>,
    /// Channel title for the channel that the playlist item belongs to.
    #[serde(rename="channelTitle")]
    pub channel_title: Option<String>,
    /// The order in which the item appears in the playlist. The value uses a
    /// zero-based index, so the first item has a position of <code>0</code>,
    /// the second item has a position of <code>1</code>, and so forth.
    pub position: Option<u32>,
    /// A map of thumbnail images associated with the playlist item. For each
    /// object in the map, the key is the name of the thumbnail image, and the
    /// value is an object that contains other information about the thumbnail.
    pub thumbnails: Option<ThumbnailDetails>,
}

impl Part for PlaylistItemSnippet {}


/// Information about a video that was marked as a favorite video.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityContentDetailsFavorite {
    /// The <code>resourceId</code> object contains information that
    /// identifies the resource that was marked as a favorite.
    #[serde(rename="resourceId")]
    pub resource_id: Option<ResourceId>,
}

impl Part for ActivityContentDetailsFavorite {}


/// A single tag suggestion with it's relevance information.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoSuggestionsTagSuggestion {
    /// A set of video categories for which the tag is relevant. You can use this
    /// information to display appropriate tag suggestions based on the video
    /// category that the video uploader associates with the video. By default,
    /// tag suggestions are relevant for all categories if there are no restricts
    /// defined for the keyword.
    #[serde(rename="categoryRestricts")]
    pub category_restricts: Option<Vec<String>>,
    /// The keyword tag suggested for the video.
    pub tag: Option<String>,
}

impl Part for VideoSuggestionsTagSuggestion {}


/// A channel banner returned as the response to a channel_banner.insert call.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [insert channel banners](struct.ChannelBannerInsertCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelBannerResource {
    /// The URL of this banner image.
    pub url: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#channelBannerResource"</code>.
    pub kind: Option<String>,
    /// no description provided
    pub etag: Option<String>,
}

impl RequestValue for ChannelBannerResource {}
impl ResponseResult for ChannelBannerResource {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PlaylistContentDetails {
    /// The number of videos in the playlist.
    #[serde(rename="itemCount")]
    pub item_count: Option<u32>,
}

impl Part for PlaylistContentDetails {}


/// Paging details for lists of resources, including total number of items
/// available and number of resources returned in a single page.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PageInfo {
    /// The number of results included in the API response.
    #[serde(rename="resultsPerPage")]
    pub results_per_page: Option<i32>,
    /// The total number of results in the result set.
    #[serde(rename="totalResults")]
    pub total_results: Option<i32>,
}

impl Part for PageInfo {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct InfoCardSnippetTeaser {
    /// The offset from the video start at which the teaser should be displayed
    /// (activated), in milliseconds.
    /// Required.
    #[serde(rename="teaserStartOffset")]
    pub teaser_start_offset: Option<String>,
    /// The teaser text to show at the top of the player for the info-card.
    /// Required for channel and link type cards.
    /// Optional for video and playlist type cards.
    #[serde(rename="teaserText")]
    pub teaser_text: Option<String>,
}

impl Part for InfoCardSnippetTeaser {}


/// The <code>auditDetails</code> object encapsulates channel data that is
/// relevant for YouTube Partners during the audit process.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelAuditDetails {
    /// Whether or not the channel respects the community guidelines.
    #[serde(rename="communityGuidelinesGoodStanding")]
    pub community_guidelines_good_standing: Option<bool>,
    /// Whether or not the channel has any unresolved claims.
    #[serde(rename="contentIdClaimsGoodStanding")]
    pub content_id_claims_good_standing: Option<bool>,
    /// Whether or not the channel has any copyright strikes.
    #[serde(rename="copyrightStrikesGoodStanding")]
    pub copyright_strikes_good_standing: Option<bool>,
}

impl Part for ChannelAuditDetails {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LocalizedProperty {
    /// no description provided
    pub default: Option<String>,
    /// The language of the default property.
    #[serde(rename="defaultLanguage")]
    pub default_language: Option<LanguageTag>,
    /// no description provided
    pub localized: Option<Vec<LocalizedString>>,
}

impl Part for LocalizedProperty {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list members](struct.MemberListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct MemberListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#memberListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of members that match the request criteria.
    pub items: Option<Vec<Member>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// no description provided
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for MemberListResponse {}

impl ToParts for MemberListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatUserBannedMessageDetails {
    /// The duration of the ban. This property is only present if the
    /// <code>banType</code> is <code>temporary</code>.
    #[serde(rename="banDurationSeconds")]
    pub ban_duration_seconds: Option<String>,
    /// The type of ban.
    #[serde(rename="banType")]
    pub ban_type: Option<String>,
    /// The details of the user that was banned.
    #[serde(rename="bannedUserDetails")]
    pub banned_user_details: Option<ChannelProfileDetails>,
}

impl Part for LiveChatUserBannedMessageDetails {}


/// A <code><strong>playlist</strong></code> resource represents a YouTube
/// playlist. A playlist is a collection of videos that can be viewed
/// sequentially and shared with other users. A playlist can contain up to
/// 200 videos, and YouTube does not limit the number of playlists that
/// each user creates. By default, playlists are publicly visible to other
/// users, but playlists can be public or private.  <br/><br/> YouTube
/// also uses playlists to identify special collections of videos for a
/// channel, such as:
/// 
/// <ul>
///     <li>uploaded videos</li>
///     <li>favorite videos</li>
///     <li>positively rated (liked) videos</li>
///     <li>watch history</li>
///     <li>watch later</li>
///   </ul>
/// To be more specific, these lists are associated with a channel, which
/// is a collection of a person, group, or company's videos, playlists,
/// and other YouTube information.  You can retrieve the playlist IDs for
/// each of these lists from the <code><a
/// href=\"/youtube/v3/docs/channels\"> channel resource</a></code> for a
/// given channel.<br/><br/> You can then use the <code> <a
/// href=\"/youtube/v3/docs/playlistItems/list\">
/// playlistItems.list</a></code> method to retrieve any of those
/// lists. You can also add or remove items from those lists by calling
/// the <code> <a href=\"/youtube/v3/docs/playlistItems/insert\">
/// playlistItems.insert</a></code> and <code> <a
/// href=\"/youtube/v3/docs/playlistItems/delete\">
/// playlistItems.delete</a></code> methods.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [insert playlists](struct.PlaylistInsertCall.html) (request|response)
/// * [delete playlists](struct.PlaylistDeleteCall.html) (none)
/// * [list playlists](struct.PlaylistListCall.html) (none)
/// * [update playlists](struct.PlaylistUpdateCall.html) (request|response)
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Playlist {
    /// The <code>status</code> object contains status information for the
    /// playlist.
    pub status: Option<PlaylistStatus>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#playlist"</code>.
    pub kind: Option<String>,
    /// The <code>contentDetails</code> object contains information like
    /// video count.
    #[serde(rename="contentDetails")]
    pub content_details: Option<PlaylistContentDetails>,
    /// The <code>snippet</code> object contains basic details about the
    /// playlist, such as its title and description.
    pub snippet: Option<PlaylistSnippet>,
    /// The <code>player</code> object contains information that you would use
    /// to play the playlist in an embedded player.
    pub player: Option<PlaylistPlayer>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube uses to uniquely identify the playlist.
    pub id: Option<String>,
    /// Localizations for different languages
    pub localizations: Option<HashMap<String, PlaylistLocalization>>,
}

impl RequestValue for Playlist {}
impl Resource for Playlist {}
impl ResponseResult for Playlist {}

impl ToParts for Playlist {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.status.is_some() { r = r + "status,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.content_details.is_some() { r = r + "contentDetails,"; }
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.player.is_some() { r = r + "player,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.id.is_some() { r = r + "id,"; }
        if self.localizations.is_some() { r = r + "localizations,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list playlist items](struct.PlaylistItemListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PlaylistItemListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#playlistItemListResponse"</code>.
    /// Etag of this resource.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of playlist items that match the request criteria.
    pub items: Option<Vec<PlaylistItem>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// no description provided
    pub etag: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the previous page in the result set.
    #[serde(rename="prevPageToken")]
    pub prev_page_token: Option<String>,
    /// General pagination information.
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for PlaylistItemListResponse {}

impl ToParts for PlaylistItemListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.prev_page_token.is_some() { r = r + "prevPageToken,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// A pair Property / Value.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PropertyValue {
    /// A property.
    pub property: Option<String>,
    /// The property's value.
    pub value: Option<String>,
}

impl Part for PropertyValue {}


/// A <code><strong>member</strong></code> resource represents a member for a
/// YouTube channel. A member provides recurring monetary support to a creator
/// and receives special benefits.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list members](struct.MemberListCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Member {
    /// The <code>snippet</code> object contains basic details about the member.
    pub snippet: Option<MemberSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#member"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
}

impl Resource for Member {}

impl ToParts for Member {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        r.pop();
        r
    }
}

/// Describes a temporal position of a visual widget inside a video.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct InvideoTiming {
    /// Defines the time at which the promotion will appear. Depending on the value
    /// of <code>type</code> the value of the <code>offsetMs</code> field will
    /// represent a time offset from the start or from the end of the video,
    /// expressed in milliseconds.
    #[serde(rename="offsetMs")]
    pub offset_ms: Option<String>,
    /// Describes a timing type. If the value is <code>offsetFromStart</code>, then
    /// the <code>offsetMs</code> field represents an offset from the start of the
    /// video. If the value is <code>offsetFromEnd</code>, then the
    /// <code>offsetMs</code> field represents an offset from the end of the video.
    #[serde(rename="type")]
    pub type_: Option<String>,
    /// Defines the duration in milliseconds for which the promotion should be
    /// displayed. If missing, the client should use the default.
    #[serde(rename="durationMs")]
    pub duration_ms: Option<String>,
}

impl Part for InvideoTiming {}


/// ChannelSection localization setting
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelSectionLocalization {
    /// The localized strings for channel section's title.
    pub title: Option<String>,
}

impl Part for ChannelSectionLocalization {}


/// A live stream describes a live ingestion point.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [delete live streams](struct.LiveStreamDeleteCall.html) (none)
/// * [update live streams](struct.LiveStreamUpdateCall.html) (request|response)
/// * [list live streams](struct.LiveStreamListCall.html) (none)
/// * [insert live streams](struct.LiveStreamInsertCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveStream {
    /// The <code>status</code> object contains information about
    /// live stream's status.
    pub status: Option<LiveStreamStatus>,
    /// The <code>snippet</code> object contains basic details about the
    /// stream, including its channel, title, and description.
    pub snippet: Option<LiveStreamSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#liveStream"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>content_details</code> object contains information about the
    /// stream, including the closed captions ingestion URL.
    #[serde(rename="contentDetails")]
    pub content_details: Option<LiveStreamContentDetails>,
    /// The <code>cdn</code> object defines the live stream's content delivery
    /// network (CDN) settings. These settings provide details about the manner
    /// in which you stream your content to YouTube.
    pub cdn: Option<CdnSettings>,
    /// The ID that YouTube assigns to uniquely identify the stream.
    pub id: Option<String>,
}

impl RequestValue for LiveStream {}
impl Resource for LiveStream {}
impl ResponseResult for LiveStream {}

impl ToParts for LiveStream {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.status.is_some() { r = r + "status,"; }
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.content_details.is_some() { r = r + "contentDetails,"; }
        if self.cdn.is_some() { r = r + "cdn,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// Information about a new playlist item.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityContentDetailsPlaylistItem {
    /// The <code>resourceId</code> object contains information about the
    /// resource that was added to the playlist.
    #[serde(rename="resourceId")]
    pub resource_id: Option<ResourceId>,
    /// The value that YouTube uses to uniquely identify the playlist.
    #[serde(rename="playlistId")]
    pub playlist_id: Option<String>,
    /// ID of the item within the playlist.
    #[serde(rename="playlistItemId")]
    pub playlist_item_id: Option<String>,
}

impl Part for ActivityContentDetailsPlaylistItem {}


/// Basic details about an activity, including title, description, thumbnails,
/// activity type and group.
/// Next ID: 12
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivitySnippet {
    /// A map of thumbnail images associated with the resource that is primarily
    /// associated with the activity. For each object in the map, the key is the
    /// name of the thumbnail image, and the value is an object that contains
    /// other information about the thumbnail.
    pub thumbnails: Option<ThumbnailDetails>,
    /// The title of the resource primarily associated with the activity.
    pub title: Option<String>,
    /// The ID that YouTube uses to uniquely identify the channel associated
    /// with the activity.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The date and time that the video was uploaded. The value is specified
    /// in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="publishedAt")]
    pub published_at: Option<String>,
    /// Channel title for the channel responsible for this activity
    #[serde(rename="channelTitle")]
    pub channel_title: Option<String>,
    /// The type of activity that the resource describes.
    #[serde(rename="type")]
    pub type_: Option<String>,
    /// The group ID associated with the activity. A group ID identifies user
    /// events that are associated with the same user and resource. For example,
    /// if a user rates a video and marks the same video as a favorite, the
    /// entries for those events would have the same group ID in the user's
    /// activity feed. In your user interface, you can avoid repetition by
    /// grouping events with the same <code>groupId</code> value.
    #[serde(rename="groupId")]
    pub group_id: Option<String>,
    /// The description of the resource primarily associated with the activity.
    /// @mutable youtube.activities.insert
    pub description: Option<String>,
}

impl Part for ActivitySnippet {}


/// Describes processing status and progress and availability of some other Video
/// resource parts.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoProcessingDetails {
    /// This value indicates whether file details are available for the uploaded
    /// video. You can retrieve a video's file details by requesting the
    /// <code>fileDetails</code> part in your <code>videos.list()</code> request.
    #[serde(rename="fileDetailsAvailability")]
    pub file_details_availability: Option<String>,
    /// This value indicates whether video editing suggestions, which might
    /// improve video quality or the playback experience, are available for
    /// the video. You can retrieve these suggestions by requesting the
    /// <code>suggestions</code> part in your <code>videos.list()</code> request.
    #[serde(rename="editorSuggestionsAvailability")]
    pub editor_suggestions_availability: Option<String>,
    /// The video's processing status. This value indicates whether YouTube was
    /// able to process the video or if the video is still being processed.
    #[serde(rename="processingStatus")]
    pub processing_status: Option<String>,
    /// This value indicates whether the video processing engine has generated
    /// suggestions that might improve YouTube's ability to process the
    /// the video, warnings that explain video processing problems, or
    /// errors that cause video processing problems. You can retrieve these
    /// suggestions by requesting the <code>suggestions</code> part in your
    /// <code>videos.list()</code> request.
    #[serde(rename="processingIssuesAvailability")]
    pub processing_issues_availability: Option<String>,
    /// The reason that YouTube failed to process the video. This property will
    /// only have a value if the <code>processingStatus</code>
    /// property's value is <code>failed</code>.
    #[serde(rename="processingFailureReason")]
    pub processing_failure_reason: Option<String>,
    /// This value indicates whether thumbnail images have been generated for
    /// the video.
    #[serde(rename="thumbnailsAvailability")]
    pub thumbnails_availability: Option<String>,
    /// The <code>processingProgress</code> object contains information about the
    /// progress YouTube has made in processing the video. The values are really
    /// only relevant if the video's processing status is <code>processing</code>.
    #[serde(rename="processingProgress")]
    pub processing_progress: Option<VideoProcessingDetailsProcessingProgress>,
    /// This value indicates whether keyword (tag) suggestions are available for
    /// the video. Tags can be added to a video's metadata to make it easier for
    /// other users to find the video. You can retrieve these suggestions by
    /// requesting the <code>suggestions</code> part in your
    /// <code>videos.list()</code> request.
    #[serde(rename="tagSuggestionsAvailability")]
    pub tag_suggestions_availability: Option<String>,
}

impl Part for VideoProcessingDetails {}


/// Basic details about a comment, such as its author and text.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct CommentSnippet {
    /// Link to the author's YouTube channel, if any.
    #[serde(rename="authorChannelUrl")]
    pub author_channel_url: Option<String>,
    /// The URL for the avatar of the user who posted the comment.
    #[serde(rename="authorProfileImageUrl")]
    pub author_profile_image_url: Option<String>,
    /// The name of the user who posted the comment.
    #[serde(rename="authorDisplayName")]
    pub author_display_name: Option<String>,
    /// The id of the corresponding YouTube channel. In case of a channel comment
    /// this is the channel the comment refers to. In case of a video comment
    /// it's the video's channel.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The rating the viewer has given to this comment. For the time being this
    /// will never return RATE_TYPE_DISLIKE and instead return RATE_TYPE_NONE.
    /// This may change in the future.
    #[serde(rename="viewerRating")]
    pub viewer_rating: Option<String>,
    /// The comment's moderation status. Will not be set if the comments were
    /// requested through the id filter.
    #[serde(rename="moderationStatus")]
    pub moderation_status: Option<String>,
    /// The ID of the video the comment refers to, if any.
    #[serde(rename="videoId")]
    pub video_id: Option<String>,
    /// no description provided
    #[serde(rename="authorChannelId")]
    pub author_channel_id: Option<CommentSnippetAuthorChannelId>,
    /// The unique id of the parent comment, only set for replies.
    #[serde(rename="parentId")]
    pub parent_id: Option<String>,
    /// The date and time when the comment was orignally published. The value is
    /// specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="publishedAt")]
    pub published_at: Option<String>,
    /// Whether the current viewer can rate this comment.
    #[serde(rename="canRate")]
    pub can_rate: Option<bool>,
    /// The comment's original raw text as initially posted or last updated. The
    /// original text will only be returned if it is accessible to the viewer,
    /// which is only guaranteed if the viewer is the comment's author.
    #[serde(rename="textOriginal")]
    pub text_original: Option<String>,
    /// The date and time when was last updated . The value is
    /// specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="updatedAt")]
    pub updated_at: Option<String>,
    /// The total number of likes this comment has received.
    #[serde(rename="likeCount")]
    pub like_count: Option<u32>,
    /// The comment's text. The format is either plain text or HTML dependent on
    /// what has been requested. Even the plain text representation may differ
    /// from the text originally posted in that it may replace video links with
    /// video titles etc.
    #[serde(rename="textDisplay")]
    pub text_display: Option<String>,
}

impl Part for CommentSnippet {}


/// Statistics about the video, such as the number of times the video was viewed
/// or liked.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoStatistics {
    /// The number of comments for the video.
    #[serde(rename="commentCount")]
    pub comment_count: Option<String>,
    /// The number of times the video has been viewed.
    #[serde(rename="viewCount")]
    pub view_count: Option<String>,
    /// The number of users who currently have the video marked as a favorite
    /// video.
    #[serde(rename="favoriteCount")]
    pub favorite_count: Option<String>,
    /// The number of users who have indicated that they disliked the video by
    /// giving it a negative rating.
    #[serde(rename="dislikeCount")]
    pub dislike_count: Option<String>,
    /// The number of users who have indicated that they liked the video by
    /// giving it a positive rating.
    #[serde(rename="likeCount")]
    pub like_count: Option<String>,
}

impl Part for VideoStatistics {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatMessageAuthorDetails {
    /// The channel's display name.
    #[serde(rename="displayName")]
    pub display_name: Option<String>,
    /// Whether the author is a moderator of the live chat.
    #[serde(rename="isChatModerator")]
    pub is_chat_moderator: Option<bool>,
    /// The YouTube channel ID.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// Whether the author is a sponsor of the live chat.
    #[serde(rename="isChatSponsor")]
    pub is_chat_sponsor: Option<bool>,
    /// The channels's avatar URL.
    #[serde(rename="profileImageUrl")]
    pub profile_image_url: Option<String>,
    /// Whether the author is the owner of the live chat.
    #[serde(rename="isChatOwner")]
    pub is_chat_owner: Option<bool>,
    /// The channel's URL.
    #[serde(rename="channelUrl")]
    pub channel_url: Option<String>,
    /// Whether the author's identity has been verified by YouTube.
    #[serde(rename="isVerified")]
    pub is_verified: Option<bool>,
}

impl Part for LiveChatMessageAuthorDetails {}


/// Details about a channelsection, including playlists and channels.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelSectionContentDetails {
    /// The channel ids for type multiple_channels.
    pub channels: Option<Vec<String>>,
    /// The playlist ids for type single_playlist and multiple_playlists. For
    /// singlePlaylist, only one playlistId is allowed.
    pub playlists: Option<Vec<String>>,
}

impl Part for ChannelSectionContentDetails {}


/// A <code><strong>membershipsLevel</strong></code> resource represents an offer
/// made by YouTube creators for their fans. Users can become members of the
/// channel by joining one of the available levels. They will provide recurring
/// monetary support and receives special benefits.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list memberships levels](struct.MembershipsLevelListCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct MembershipsLevel {
    /// The <code>snippet</code> object contains basic details about the level.
    pub snippet: Option<MembershipsLevelSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#membershipsLevelListResponse"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube assigns to uniquely identify the memberships level.
    pub id: Option<String>,
}

impl Resource for MembershipsLevel {}

impl ToParts for MembershipsLevel {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// Describes a single promoted item.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PromotedItem {
    /// The temporal position within the video where the promoted item will be
    /// displayed. If present, it overrides the default timing.
    pub timing: Option<InvideoTiming>,
    /// If true, the content owner's name will be used when displaying the
    /// promotion. This field can only be set when the update is made on behalf of
    /// the content owner.
    #[serde(rename="promotedByContentOwner")]
    pub promoted_by_content_owner: Option<bool>,
    /// A custom message to display for this promotion. This field is currently
    /// ignored unless the promoted item is a website.
    #[serde(rename="customMessage")]
    pub custom_message: Option<String>,
    /// Identifies the promoted item.
    pub id: Option<PromotedItemId>,
}

impl Part for PromotedItem {}


/// Branding properties of a YouTube channel.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelBrandingSettings {
    /// Branding properties for branding images.
    pub image: Option<ImageSettings>,
    /// Branding properties for the watch page.
    pub watch: Option<WatchSettings>,
    /// Branding properties for the channel view.
    pub channel: Option<ChannelSettings>,
    /// Additional experimental branding properties.
    pub hints: Option<Vec<PropertyValue>>,
}

impl Part for ChannelBrandingSettings {}


/// Details about a resource which is being promoted.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityContentDetailsPromotedItem {
    /// The type of call-to-action, a message to the user indicating action that
    /// can be taken.
    #[serde(rename="ctaType")]
    pub cta_type: Option<String>,
    /// The URL the client should fetch to request a promoted item.
    #[serde(rename="adTag")]
    pub ad_tag: Option<String>,
    /// The URL the client should direct the user to, if the user chooses to
    /// visit the advertiser's website.
    #[serde(rename="destinationUrl")]
    pub destination_url: Option<String>,
    /// The list of forecasting URLs. The client should ping all of these URLs
    /// when a promoted item is not available, to indicate that a promoted item
    /// could have been shown.
    #[serde(rename="forecastingUrl")]
    pub forecasting_url: Option<Vec<String>>,
    /// The list of impression URLs. The client should ping all of these URLs to
    /// indicate that the user was shown this promoted item.
    #[serde(rename="impressionUrl")]
    pub impression_url: Option<Vec<String>>,
    /// The URL the client should ping to indicate that the user was shown this
    /// promoted item.
    #[serde(rename="creativeViewUrl")]
    pub creative_view_url: Option<String>,
    /// The ID that YouTube uses to uniquely identify the promoted video.
    #[serde(rename="videoId")]
    pub video_id: Option<String>,
    /// The text description to accompany the promoted item.
    #[serde(rename="descriptionText")]
    pub description_text: Option<String>,
    /// The custom call-to-action button text. If specified, it will override
    /// the default button text for the cta_type.
    #[serde(rename="customCtaButtonText")]
    pub custom_cta_button_text: Option<String>,
    /// The URL the client should ping to indicate that the user clicked through
    /// on this promoted item.
    #[serde(rename="clickTrackingUrl")]
    pub click_tracking_url: Option<String>,
}

impl Part for ActivityContentDetailsPromotedItem {}


/// LINT.IfChange
/// Describes an invideo branding.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [set watermarks](struct.WatermarkSetCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct InvideoBranding {
    /// The channel to which this branding links. If not present it defaults to
    /// the current channel.
    #[serde(rename="targetChannelId")]
    pub target_channel_id: Option<String>,
    /// The spatial position within the video where the branding watermark will be
    /// displayed.
    pub position: Option<InvideoPosition>,
    /// The url of the uploaded image. Only used in apiary to api communication.
    #[serde(rename="imageUrl")]
    pub image_url: Option<String>,
    /// The temporal position within the video where watermark will be displayed.
    pub timing: Option<InvideoTiming>,
    /// The bytes the uploaded image. Only used in api to youtube communication.
    #[serde(rename="imageBytes")]
    pub image_bytes: Option<String>,
}

impl RequestValue for InvideoBranding {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list comments](struct.CommentListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct CommentListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#commentListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of comments that match the request criteria.
    pub items: Option<Vec<Comment>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// General pagination information.
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for CommentListResponse {}

impl ToParts for CommentListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// Describes original video file properties, including technical details about
/// audio and video streams, but also metadata information like content length,
/// digitization time, or geotagging information.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoFileDetails {
    /// The uploaded video file's combined (video and audio) bitrate in bits
    /// per second.
    #[serde(rename="bitrateBps")]
    pub bitrate_bps: Option<String>,
    /// The uploaded video file's container format.
    pub container: Option<String>,
    /// The uploaded file's type as detected by YouTube's video processing
    /// engine. Currently, YouTube only processes video files, but this field
    /// is present whether a video file or another type of file was uploaded.
    #[serde(rename="fileType")]
    pub file_type: Option<String>,
    /// The date and time when the uploaded video file was created. The value is
    /// specified in <a href="http://www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format. Currently, the following ISO 8601 formats are supported:
    /// <ul>
    /// <li>Date only: <code>YYYY-MM-DD</code></li>
    /// <li>Naive time: <code>YYYY-MM-DDTHH:MM:SS</code></li>
    /// <li>Time with timezone: <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code></li>
    /// </ul>
    #[serde(rename="creationTime")]
    pub creation_time: Option<String>,
    /// The length of the uploaded video in milliseconds.
    #[serde(rename="durationMs")]
    pub duration_ms: Option<String>,
    /// The uploaded file's name. This field is present whether a video file or
    /// another type of file was uploaded.
    #[serde(rename="fileName")]
    pub file_name: Option<String>,
    /// The uploaded file's size in bytes. This field is present whether
    /// a video file or another type of file was uploaded.
    #[serde(rename="fileSize")]
    pub file_size: Option<String>,
    /// A list of video streams contained in the uploaded video file. Each item
    /// in the list contains detailed metadata about a video stream.
    #[serde(rename="videoStreams")]
    pub video_streams: Option<Vec<VideoFileDetailsVideoStream>>,
    /// A list of audio streams contained in the uploaded video file. Each item
    /// in the list contains detailed metadata about an audio stream.
    #[serde(rename="audioStreams")]
    pub audio_streams: Option<Vec<VideoFileDetailsAudioStream>>,
}

impl Part for VideoFileDetails {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatBanSnippet {
    /// The duration of a ban, only filled if the ban has type TEMPORARY.
    #[serde(rename="banDurationSeconds")]
    pub ban_duration_seconds: Option<String>,
    /// The chat this ban is pertinent to.
    #[serde(rename="liveChatId")]
    pub live_chat_id: Option<String>,
    /// no description provided
    #[serde(rename="bannedUserDetails")]
    pub banned_user_details: Option<ChannelProfileDetails>,
    /// The type of ban.
    #[serde(rename="type")]
    pub type_: Option<String>,
}

impl Part for LiveChatBanSnippet {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list guide categories](struct.GuideCategoryListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GuideCategoryListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#guideCategoryListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of categories that can be associated with YouTube channels. In this
    /// map, the category ID is the map key, and its value is the corresponding
    /// <code>guideCategory</code> resource.
    pub items: Option<Vec<GuideCategory>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the previous page in the result set.
    #[serde(rename="prevPageToken")]
    pub prev_page_token: Option<String>,
    /// no description provided
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for GuideCategoryListResponse {}

impl ToParts for GuideCategoryListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.prev_page_token.is_some() { r = r + "prevPageToken,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// Basic details about a channel section, including title, style and position.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelSectionSnippet {
    /// The style of the channel section.
    pub style: Option<String>,
    /// Localized title, read-only.
    pub localized: Option<ChannelSectionLocalization>,
    /// The channel section's title for multiple_playlists and multiple_channels.
    pub title: Option<String>,
    /// The position of the channel section in the channel.
    pub position: Option<u32>,
    /// The ID that YouTube uses to uniquely identify the channel that published
    /// the channel section.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The type of the channel section.
    #[serde(rename="type")]
    pub type_: Option<String>,
    /// The language of the channel section's default title and description.
    #[serde(rename="defaultLanguage")]
    pub default_language: Option<String>,
}

impl Part for ChannelSectionSnippet {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatSuperStickerDetails {
    /// The tier in which the amount belongs. Lower amounts belong to lower
    /// tiers. The lowest tier is <code>1</code>.
    pub tier: Option<u32>,
    /// The currency in which the purchase was made.
    pub currency: Option<String>,
    /// A rendered string that displays the fund amount and currency to the user.
    #[serde(rename="amountDisplayString")]
    pub amount_display_string: Option<String>,
    /// Information about the Super Sticker.
    #[serde(rename="superStickerMetadata")]
    pub super_sticker_metadata: Option<SuperStickerMetadata>,
    /// The amount purchased by the user, in micros (1,750,000 micros = 1.75).
    #[serde(rename="amountMicros")]
    pub amount_micros: Option<String>,
}

impl Part for LiveChatSuperStickerDetails {}


/// Stub token pagination template to suppress results.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct TokenPagination { _never_set: Option<bool> }

impl Part for TokenPagination {}


/// Rights management policy for YouTube resources.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct AccessPolicy {
    /// A list of region codes that identify countries where the default policy do
    /// not apply.
    pub exception: Option<Vec<String>>,
    /// The value of <code>allowed</code> indicates whether the access to the
    /// policy is allowed or denied by default.
    pub allowed: Option<bool>,
}

impl Part for AccessPolicy {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [report abuse videos](struct.VideoReportAbuseCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoAbuseReport {
    /// The specific, or secondary, reason that this content is abusive (if
    /// available). The value is an abuse report reason ID that is a valid
    /// secondary reason for the primary reason.
    #[serde(rename="secondaryReasonId")]
    pub secondary_reason_id: Option<String>,
    /// The high-level, or primary, reason that the content is abusive. The value
    /// is an abuse report reason ID.
    #[serde(rename="reasonId")]
    pub reason_id: Option<String>,
    /// Additional comments regarding the abuse report.
    pub comments: Option<String>,
    /// The language that the content was viewed in.
    pub language: Option<String>,
    /// The ID that YouTube uses to uniquely identify the video.
    #[serde(rename="videoId")]
    pub video_id: Option<String>,
}

impl RequestValue for VideoAbuseReport {}


/// Information that identifies the recommended resource.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityContentDetailsRecommendation {
    /// The <code>resourceId</code> object contains information that
    /// identifies the recommended resource.
    #[serde(rename="resourceId")]
    pub resource_id: Option<ResourceId>,
    /// The reason that the resource is recommended to the user.
    pub reason: Option<String>,
    /// The <code>seedResourceId</code> object contains information about
    /// the resource that caused the recommendation.
    #[serde(rename="seedResourceId")]
    pub seed_resource_id: Option<ResourceId>,
}

impl Part for ActivityContentDetailsRecommendation {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatModeratorSnippet {
    /// The ID of the live chat this moderator can act on.
    #[serde(rename="liveChatId")]
    pub live_chat_id: Option<String>,
    /// Details about the moderator.
    #[serde(rename="moderatorDetails")]
    pub moderator_details: Option<ChannelProfileDetails>,
}

impl Part for LiveChatModeratorSnippet {}


/// A `__superChatEvent__` resource represents a Super Chat purchase on a YouTube
/// channel.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list super chat events](struct.SuperChatEventListCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SuperChatEvent {
    /// The `snippet` object contains basic details about the Super Chat event.
    pub snippet: Option<SuperChatEventSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// `"youtube#superChatEvent"`.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube assigns to uniquely identify the Super Chat event.
    pub id: Option<String>,
}

impl Resource for SuperChatEvent {}

impl ToParts for SuperChatEvent {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// Details about the content of an activity: the video that was shared, the
/// channel that was subscribed to, etc.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityContentDetails {
    /// The <code>comment</code> object contains information about a resource
    /// that received a comment. This property is only present if the
    /// <code>snippet.type</code> is <code>comment</code>.
    pub comment: Option<ActivityContentDetailsComment>,
    /// The <code>playlistItem</code> object contains information about a
    /// new playlist item. This property is only present if the
    /// <code>snippet.type</code> is <code>playlistItem</code>.
    #[serde(rename="playlistItem")]
    pub playlist_item: Option<ActivityContentDetailsPlaylistItem>,
    /// The <code>like</code> object contains information about a resource that
    /// received a positive (like) rating. This property is only present if
    /// the <code>snippet.type</code> is <code>like</code>.
    pub like: Option<ActivityContentDetailsLike>,
    /// The <code>promotedItem</code> object contains details about a resource
    /// which is being promoted. This property is only present if the
    /// <code>snippet.type</code> is <code>promotedItem</code>.
    #[serde(rename="promotedItem")]
    pub promoted_item: Option<ActivityContentDetailsPromotedItem>,
    /// The <code>recommendation</code> object contains information about a
    /// recommended resource. This property is only present if the
    /// <code>snippet.type</code> is <code>recommendation</code>.
    pub recommendation: Option<ActivityContentDetailsRecommendation>,
    /// The <code>favorite</code> object contains information about a video that
    /// was marked as a favorite video. This property is only present if the
    /// <code>snippet.type</code> is <code>favorite</code>.
    pub favorite: Option<ActivityContentDetailsFavorite>,
    /// The <code>upload</code> object contains information about the uploaded
    /// video. This property is only present if the <code>snippet.type</code>
    /// is <code>upload</code>.
    pub upload: Option<ActivityContentDetailsUpload>,
    /// The <code>social</code> object contains details about a social network
    /// post. This property is only present if the <code>snippet.type</code>
    /// is <code>social</code>.
    pub social: Option<ActivityContentDetailsSocial>,
    /// The <code>channelItem</code> object contains details about a resource
    /// which was added to a channel. This property is only present if the
    /// <code>snippet.type</code> is <code>channelItem</code>.
    #[serde(rename="channelItem")]
    pub channel_item: Option<ActivityContentDetailsChannelItem>,
    /// The <code>bulletin</code> object contains details about a channel
    /// bulletin post. This object is only present if the
    /// <code>snippet.type</code> is <code>bulletin</code>.
    pub bulletin: Option<ActivityContentDetailsBulletin>,
    /// The <code>subscription</code> object contains information about a
    /// channel that a user subscribed to. This property is only
    /// present if the <code>snippet.type</code> is <code>subscription</code>.
    pub subscription: Option<ActivityContentDetailsSubscription>,
}

impl Part for ActivityContentDetails {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PlaylistItemContentDetails {
    /// A user-generated note for this item.
    pub note: Option<String>,
    /// The date and time that the video was published to YouTube. The value is
    /// specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="videoPublishedAt")]
    pub video_published_at: Option<String>,
    /// The time, measured in seconds from the start of the video, when the video
    /// should start playing. (The playlist owner can specify the times when the
    /// video should start and stop playing when the video is played in the context
    /// of the playlist.) The default value is <code>0</code>.
    #[serde(rename="startAt")]
    pub start_at: Option<String>,
    /// The time, measured in seconds from the start of the video, when the video
    /// should stop playing. (The playlist owner can specify the times when the
    /// video should start and stop playing when the video is played in the context
    /// of the playlist.) By default, assume that the <code>video.endTime</code> is
    /// the end of the video.
    #[serde(rename="endAt")]
    pub end_at: Option<String>,
    /// The ID that YouTube uses to uniquely identify a video. To <a
    /// href="/youtube/v3/docs/video/list.html">retrieve the <code>video</code>
    /// resource</a>, set the <code>id</code> query parameter to this value in your
    /// API request.
    #[serde(rename="videoId")]
    pub video_id: Option<String>,
}

impl Part for PlaylistItemContentDetails {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list playlists](struct.PlaylistListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PlaylistListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#playlistListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of playlists that match the request criteria
    pub items: Option<Vec<Playlist>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the previous page in the result set.
    #[serde(rename="prevPageToken")]
    pub prev_page_token: Option<String>,
    /// General pagination information.
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for PlaylistListResponse {}

impl ToParts for PlaylistListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.prev_page_token.is_some() { r = r + "prevPageToken,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// Live broadcast state.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveBroadcastStatus {
    /// The broadcast's recording status.
    #[serde(rename="recordingStatus")]
    pub recording_status: Option<String>,
    /// Priority of the live broadcast event (internal state).
    #[serde(rename="liveBroadcastPriority")]
    pub live_broadcast_priority: Option<String>,
    /// This field will be set to True if the creator declares the broadcast to be
    /// kids only: go/live-cw-work.
    #[serde(rename="selfDeclaredMadeForKids")]
    pub self_declared_made_for_kids: Option<bool>,
    /// The broadcast's privacy status. Note that the broadcast represents
    /// exactly one YouTube video, so the privacy settings are identical to
    /// those supported for videos. In addition, you can set this field by
    /// modifying the broadcast resource or by setting the
    /// <code><a
    /// href="/youtube/v3/docs/videos#status.privacyStatus"
    /// >privacyStatus</a></code>
    /// field of the corresponding video resource.
    #[serde(rename="privacyStatus")]
    pub privacy_status: Option<String>,
    /// Whether the broadcast is made for kids or not, decided by YouTube instead
    /// of the creator. This field is read only.
    #[serde(rename="madeForKids")]
    pub made_for_kids: Option<bool>,
    /// The broadcast's status. The status can be updated using the API's
    /// <code><a
    /// href="/youtube/v3/live/docs/liveBroadcasts/transition"
    /// >liveBroadcasts.transition</a></code> method.
    #[serde(rename="lifeCycleStatus")]
    pub life_cycle_status: Option<String>,
}

impl Part for LiveBroadcastStatus {}


/// Geographical coordinates of a point, in WGS84.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GeoPoint {
    /// Latitude in degrees.
    pub latitude: Option<f64>,
    /// Altitude above the reference ellipsoid, in meters.
    pub altitude: Option<f64>,
    /// Longitude in degrees.
    pub longitude: Option<f64>,
}

impl Part for GeoPoint {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoAgeGating {
    /// Age-restricted trailers. For redband trailers and adult-rated video-games.
    /// Only users aged 18+ can view the content. The the field is
    /// <code>true</code> the content is restricted to viewers aged 18+. Otherwise
    /// The field won't be present.
    pub restricted: Option<bool>,
    /// Indicates whether or not the video has alcoholic beverage content. Only
    /// users of legal purchasing age in a particular country, as identified by
    /// ICAP, can view the content.
    #[serde(rename="alcoholContent")]
    pub alcohol_content: Option<bool>,
    /// Video game rating, if any.
    #[serde(rename="videoGameRating")]
    pub video_game_rating: Option<String>,
}

impl Part for VideoAgeGating {}


/// Player to be used for a video playback.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoPlayer {
    /// An <code>&lt;iframe&gt;</code> tag that embeds a player that will
    /// play the video.
    #[serde(rename="embedHtml")]
    pub embed_html: Option<String>,
    /// no description provided
    #[serde(rename="embedHeight")]
    pub embed_height: Option<String>,
    /// The embed width
    #[serde(rename="embedWidth")]
    pub embed_width: Option<String>,
}

impl Part for VideoPlayer {}


/// Basic details about a channel, including title, description and thumbnails.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelSnippet {
    /// The description of the channel.
    pub description: Option<String>,
    /// The channel's title.
    pub title: Option<String>,
    /// The country of the channel.
    pub country: Option<String>,
    /// The custom url of the channel.
    #[serde(rename="customUrl")]
    pub custom_url: Option<String>,
    /// The language of the channel's default title and description.
    #[serde(rename="defaultLanguage")]
    pub default_language: Option<String>,
    /// The date and time that the channel was created. The value is specified in
    /// < a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="publishedAt")]
    pub published_at: Option<String>,
    /// Localized title and description, read-only.
    pub localized: Option<ChannelLocalization>,
    /// A map of thumbnail images associated with the channel. For each object in
    /// the map, the key is the name of the thumbnail image, and the value is an
    /// object that contains other information about the thumbnail.<br><br> When
    /// displaying thumbnails in your application, make sure that your code uses
    /// the image URLs exactly as they are returned in API responses. For example,
    /// your application should not use the <code>http</code> domain instead of the
    /// <code>https</code> domain in a URL returned in an API response.<br><br>
    /// Beginning in July 2018, channel thumbnail URLs will only be available in
    /// the <code>https</code> domain, which is how the URLs appear in API
    /// responses. After that time, you might see broken images in your application
    /// if it tries to load YouTube images from the <code>http</code> domain.
    pub thumbnails: Option<ThumbnailDetails>,
}

impl Part for ChannelSnippet {}


/// Branding properties for the watch. All deprecated.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct WatchSettings {
    /// The background color for the video watch page's branded area.
    #[serde(rename="textColor")]
    pub text_color: Option<String>,
    /// An ID that uniquely identifies a playlist that displays next to the video
    /// player.
    #[serde(rename="featuredPlaylistId")]
    pub featured_playlist_id: Option<String>,
    /// The text color for the video watch page's branded area.
    #[serde(rename="backgroundColor")]
    pub background_color: Option<String>,
}

impl Part for WatchSettings {}


/// Information about an audio stream.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoFileDetailsAudioStream {
    /// The audio stream's bitrate, in bits per second.
    #[serde(rename="bitrateBps")]
    pub bitrate_bps: Option<String>,
    /// The audio codec that the stream uses.
    pub codec: Option<String>,
    /// A value that uniquely identifies a video vendor. Typically, the value
    /// is a four-letter vendor code.
    pub vendor: Option<String>,
    /// The number of audio channels that the stream contains.
    #[serde(rename="channelCount")]
    pub channel_count: Option<u32>,
}

impl Part for VideoFileDetailsAudioStream {}


/// A <code><strong>video</strong></code> resource represents a YouTube video.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [rate videos](struct.VideoRateCall.html) (none)
/// * [report abuse videos](struct.VideoReportAbuseCall.html) (none)
/// * [get rating videos](struct.VideoGetRatingCall.html) (none)
/// * [list videos](struct.VideoListCall.html) (none)
/// * [insert videos](struct.VideoInsertCall.html) (request|response)
/// * [update videos](struct.VideoUpdateCall.html) (request|response)
/// * [delete videos](struct.VideoDeleteCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Video {
    /// The <code>status</code> object contains information about the video's
    /// uploading, processing, and privacy statuses.
    pub status: Option<VideoStatus>,
    /// The <code>topicDetails</code> object encapsulates information about <a
    /// href="http://www.freebase.com">Freebase</a> topics associated with the
    /// video.
    #[serde(rename="topicDetails")]
    pub topic_details: Option<VideoTopicDetails>,
    /// The <code>monetizationDetails</code> object encapsulates information
    /// about the monetization status of the video.
    #[serde(rename="monetizationDetails")]
    pub monetization_details: Option<VideoMonetizationDetails>,
    /// The <code>suggestions</code> object encapsulates suggestions that identify
    /// opportunities to improve the video quality or the metadata for the uploaded
    /// video. This data can only be retrieved by the video owner.
    pub suggestions: Option<VideoSuggestions>,
    /// Age restriction details related to a video. This data can only be retrieved
    /// by the video owner.
    #[serde(rename="ageGating")]
    pub age_gating: Option<VideoAgeGating>,
    /// The <code>fileDetails</code> object encapsulates information about the
    /// video file that was uploaded to YouTube, including the file's resolution,
    /// duration, audio and video codecs, stream bitrates, and more. This data can
    /// only be retrieved by the video owner.
    #[serde(rename="fileDetails")]
    pub file_details: Option<VideoFileDetails>,
    /// The <code>player</code> object contains information that you would use to
    /// play the video in an embedded player.
    pub player: Option<VideoPlayer>,
    /// The ID that YouTube uses to uniquely identify the video.
    pub id: Option<String>,
    /// The <code>localizations</code> object contains localized versions of the
    /// basic details about the video, such as its title and description.
    pub localizations: Option<HashMap<String, VideoLocalization>>,
    /// The <code>liveStreamingDetails</code> object contains metadata about a live
    /// video broadcast. The object will only be present in a <code>video</code>
    /// resource if the video is an upcoming, live, or completed live broadcast.
    #[serde(rename="liveStreamingDetails")]
    pub live_streaming_details: Option<VideoLiveStreamingDetails>,
    /// The <code>snippet</code> object contains basic details about the video,
    /// such as its title, description, and category.
    pub snippet: Option<VideoSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#video"</code>.
    pub kind: Option<String>,
    /// The <code>statistics</code> object contains statistics about the video.
    pub statistics: Option<VideoStatistics>,
    /// The <code>projectDetails</code> object contains information about the
    /// project specific video metadata.
    #[serde(rename="projectDetails")]
    pub project_details: Option<VideoProjectDetails>,
    /// The <code>processingDetails</code> object encapsulates information about
    /// YouTube's progress in processing the uploaded video file. The properties
    /// in the object identify the current processing status and an estimate of
    /// the time remaining until YouTube finishes processing the video. This part
    /// also indicates whether different types of data or content, such as file
    /// details or thumbnail images, are available for the video.<br><br>
    /// The <code>processingProgress</code> object is designed to be polled so
    /// that the video uploaded can track the progress that YouTube has made in
    /// processing the uploaded video file. This data can only be retrieved by
    /// the video owner.
    #[serde(rename="processingDetails")]
    pub processing_details: Option<VideoProcessingDetails>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>contentDetails</code> object contains information about the video
    /// content, including the length of the video and its aspect ratio.
    #[serde(rename="contentDetails")]
    pub content_details: Option<VideoContentDetails>,
    /// The <code>recordingDetails</code> object encapsulates information about the
    /// location, date and address where the video was recorded.
    #[serde(rename="recordingDetails")]
    pub recording_details: Option<VideoRecordingDetails>,
}

impl RequestValue for Video {}
impl Resource for Video {}
impl ResponseResult for Video {}

impl ToParts for Video {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.status.is_some() { r = r + "status,"; }
        if self.topic_details.is_some() { r = r + "topicDetails,"; }
        if self.monetization_details.is_some() { r = r + "monetizationDetails,"; }
        if self.suggestions.is_some() { r = r + "suggestions,"; }
        if self.age_gating.is_some() { r = r + "ageGating,"; }
        if self.file_details.is_some() { r = r + "fileDetails,"; }
        if self.player.is_some() { r = r + "player,"; }
        if self.id.is_some() { r = r + "id,"; }
        if self.localizations.is_some() { r = r + "localizations,"; }
        if self.live_streaming_details.is_some() { r = r + "liveStreamingDetails,"; }
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.statistics.is_some() { r = r + "statistics,"; }
        if self.project_details.is_some() { r = r + "projectDetails,"; }
        if self.processing_details.is_some() { r = r + "processingDetails,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.content_details.is_some() { r = r + "contentDetails,"; }
        if self.recording_details.is_some() { r = r + "recordingDetails,"; }
        r.pop();
        r
    }
}

/// Details about the content of a YouTube Video.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoContentDetails {
    /// The value of <code>definition</code> indicates whether the video is
    /// available in high definition or only in standard definition.
    pub definition: Option<String>,
    /// Specifies the projection format of the video.
    pub projection: Option<String>,
    /// The <code>countryRestriction</code> object contains information about the
    /// countries where a video is (or is not) viewable.
    #[serde(rename="countryRestriction")]
    pub country_restriction: Option<AccessPolicy>,
    /// Indicates whether the video uploader has provided a custom
    /// thumbnail image for the video.
    /// This property is only visible to the video uploader.
    #[serde(rename="hasCustomThumbnail")]
    pub has_custom_thumbnail: Option<bool>,
    /// Specifies the ratings that the video received under various rating schemes.
    #[serde(rename="contentRating")]
    pub content_rating: Option<ContentRating>,
    /// The value of <code>captions</code> indicates whether the video
    /// has captions or not.
    pub caption: Option<String>,
    /// The <code>regionRestriction</code> object contains information about the
    /// countries where a video is (or is not) viewable. The object will contain
    /// either the <code>contentDetails.regionRestriction.allowed</code> property
    /// or the <code>contentDetails.regionRestriction.blocked</code> property.
    #[serde(rename="regionRestriction")]
    pub region_restriction: Option<VideoContentDetailsRegionRestriction>,
    /// The length of the video. The tag value is an <a
    /// href="//en.wikipedia.org/wiki/ISO_8601#Durations">ISO 8601</a> duration in
    /// the format <code>PT#M#S</code>, in which the letters <code>PT</code>
    /// indicate that the value specifies a period of time, and the letters
    /// <code>M</code> and <code>S</code> refer to length in minutes and seconds,
    /// respectively. The <code>#</code> characters preceding the <code>M</code>
    /// and <code>S</code> letters are both integers that specify the number of
    /// minutes (or seconds) of the video. For example, a value of
    /// <code>PT15M51S</code> indicates that the video is 15 minutes and 51 seconds
    /// long.
    pub duration: Option<String>,
    /// The value of <code>is_license_content</code> indicates whether the video is
    /// licensed content.
    #[serde(rename="licensedContent")]
    pub licensed_content: Option<bool>,
    /// The value of <code>dimension</code> indicates whether the video is
    /// available in 3D or in 2D.
    pub dimension: Option<String>,
}

impl Part for VideoContentDetails {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatFanFundingEventDetails {
    /// The currency in which the fund was made.
    pub currency: Option<String>,
    /// A rendered string that displays the fund amount and currency to the user.
    #[serde(rename="amountDisplayString")]
    pub amount_display_string: Option<String>,
    /// The amount of the fund.
    #[serde(rename="amountMicros")]
    pub amount_micros: Option<String>,
    /// The comment added by the user to this fan funding event.
    #[serde(rename="userComment")]
    pub user_comment: Option<String>,
}

impl Part for LiveChatFanFundingEventDetails {}


/// Describes a single promoted item id. It is a union of various possible types.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PromotedItemId {
    /// If the promoted item represents a website, this field represents the url
    /// pointing to the website. This field will be present only if
    /// <code>type</code> has the value <code>website</code>.
    #[serde(rename="websiteUrl")]
    pub website_url: Option<String>,
    /// If type is recentUpload, this field identifies the channel from which to
    /// take the recent upload. If missing, the channel is assumed to be the same
    /// channel for which the invideoPromotion is set.
    #[serde(rename="recentlyUploadedBy")]
    pub recently_uploaded_by: Option<String>,
    /// Describes the type of the promoted item.
    #[serde(rename="type")]
    pub type_: Option<String>,
    /// If the promoted item represents a video, this field represents the unique
    /// YouTube ID identifying it. This field will be present only if
    /// <code>type</code> has the value <code>video</code>.
    #[serde(rename="videoId")]
    pub video_id: Option<String>,
}

impl Part for PromotedItemId {}


/// Information about the playlist item's privacy status.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PlaylistItemStatus {
    /// This resource's privacy status.
    #[serde(rename="privacyStatus")]
    pub privacy_status: Option<String>,
}

impl Part for PlaylistItemStatus {}


/// Describes the spatial position of a visual widget inside a video. It is a
/// union of various position types, out of which only will be set one.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct InvideoPosition {
    /// Describes in which corner of the video the visual widget will appear.
    #[serde(rename="cornerPosition")]
    pub corner_position: Option<String>,
    /// Defines the position type.
    #[serde(rename="type")]
    pub type_: Option<String>,
}

impl Part for InvideoPosition {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct MembershipsDetails {
    /// Data about memberships duration without taking into consideration pricing
    /// levels.
    #[serde(rename="membershipsDuration")]
    pub memberships_duration: Option<MembershipsDuration>,
    /// Data about memberships duration on particular pricing levels.
    #[serde(rename="membershipsDurationAtLevels")]
    pub memberships_duration_at_levels: Option<Vec<MembershipsDurationAtLevel>>,
    /// Id of the highest level that the user has access to at the moment.
    #[serde(rename="highestAccessibleLevel")]
    pub highest_accessible_level: Option<String>,
    /// Display name for the highest level that the user has access to at the
    /// moment.
    #[serde(rename="highestAccessibleLevelDisplayName")]
    pub highest_accessible_level_display_name: Option<String>,
    /// Ids of all levels that the user has access to. This includes the currently
    /// active level and all other levels that are included because of a higher
    /// purchase.
    #[serde(rename="accessibleLevels")]
    pub accessible_levels: Option<Vec<String>>,
}

impl Part for MembershipsDetails {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list sponsors](struct.SponsorListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SponsorListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the `pageToken` parameter to
    /// retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// `"youtube#sponsorListResponse".
    pub kind: Option<String>,
    /// The `visitorId` identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of sponsors that match the request criteria.
    pub items: Option<Vec<Sponsor>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// no description provided
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for SponsorListResponse {}

impl ToParts for SponsorListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SuperStickerMetadata {
    /// Internationalized alt text that describes the sticker image and any
    /// animation associated with it.
    #[serde(rename="altText")]
    pub alt_text: Option<String>,
    /// Specifies the localization language in which the alt text is returned.
    #[serde(rename="altTextLanguage")]
    pub alt_text_language: Option<String>,
    /// Unique identifier of the Super Sticker. This is a shorter form of the
    /// alt_text that includes pack name and a recognizable characteristic of the
    /// sticker.
    #[serde(rename="stickerId")]
    pub sticker_id: Option<String>,
}

impl Part for SuperStickerMetadata {}


/// Project specific details about the content of a YouTube Video.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoProjectDetails {
    /// A list of project tags associated with the video during the upload.
    pub tags: Option<Vec<String>>,
}

impl Part for VideoProjectDetails {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct TestItemTestItemSnippet { _never_set: Option<bool> }

impl Part for TestItemTestItemSnippet {}


/// Basic details about a video category, such as its localized title.
/// Next Id: 16
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoStatus {
    /// The video's license.
    /// @mutable youtube.videos.insert youtube.videos.update
    pub license: Option<String>,
    /// This value indicates if the video can be embedded on another website.
    /// @mutable youtube.videos.insert youtube.videos.update
    pub embeddable: Option<bool>,
    /// The video's privacy status.
    #[serde(rename="privacyStatus")]
    pub privacy_status: Option<String>,
    /// This value indicates if the extended video statistics on the watch page
    /// can be viewed by everyone. Note that the view count, likes, etc will still
    /// be visible if this is disabled.
    /// @mutable youtube.videos.insert youtube.videos.update
    #[serde(rename="publicStatsViewable")]
    pub public_stats_viewable: Option<bool>,
    /// The date and time when the video is scheduled to publish. It can be set
    /// only if the privacy status of the video is private. The value is specified
    /// in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="publishAt")]
    pub publish_at: Option<String>,
    /// no description provided
    #[serde(rename="selfDeclaredMadeForKids")]
    pub self_declared_made_for_kids: Option<bool>,
    /// no description provided
    #[serde(rename="madeForKids")]
    pub made_for_kids: Option<bool>,
    /// The status of the uploaded video.
    #[serde(rename="uploadStatus")]
    pub upload_status: Option<String>,
    /// This value explains why YouTube rejected an uploaded video. This
    /// property is only present if the <code>uploadStatus</code> property
    /// indicates that the upload was rejected.
    #[serde(rename="rejectionReason")]
    pub rejection_reason: Option<String>,
    /// This value explains why a video failed to upload. This property is
    /// only present if the <code>uploadStatus</code> property indicates that
    /// the upload failed.
    #[serde(rename="failureReason")]
    pub failure_reason: Option<String>,
}

impl Part for VideoStatus {}


/// Localized versions of certain video properties (e.g. title).
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoLocalization {
    /// Localized version of the video's description.
    pub description: Option<String>,
    /// Localized version of the video's title.
    pub title: Option<String>,
}

impl Part for VideoLocalization {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoCard {
    /// Playback start time offset in milliseconds.
    /// Optional.
    #[serde(rename="playbackStartOffset")]
    pub playback_start_offset: Option<String>,
    /// Each card can have a custom message.
    /// Optional.
    #[serde(rename="customMessage")]
    pub custom_message: Option<String>,
    /// Encrypted Video ID.
    /// Required.
    #[serde(rename="videoId")]
    pub video_id: Option<String>,
}

impl Part for VideoCard {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [get rating videos](struct.VideoGetRatingCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoRatingListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// A list of ratings that match the request criteria.
    pub items: Option<Vec<VideoRating>>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#videoGetRatingResponse"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
}

impl ResponseResult for VideoRatingListResponse {}


/// Basic information about a third party account link, including its type and
/// type-specific information.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ThirdPartyLinkSnippet {
    /// Information specific to a link between a channel and a store on a
    /// merchandising platform.
    #[serde(rename="channelToStoreLink")]
    pub channel_to_store_link: Option<ChannelToStoreLinkDetails>,
    /// Type of the link named after the entities that are being linked.
    #[serde(rename="type")]
    pub type_: Option<String>,
}

impl Part for ThirdPartyLinkSnippet {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LevelDetails {
    /// The name that should be used when referring to this level.
    #[serde(rename="displayName")]
    pub display_name: Option<String>,
}

impl Part for LevelDetails {}


/// A <code><strong>liveBroadcast</strong></code> resource represents an event
/// that will be streamed, via live video, on YouTube.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [control live broadcasts](struct.LiveBroadcastControlCall.html) (response)
/// * [insert live broadcasts](struct.LiveBroadcastInsertCall.html) (request|response)
/// * [list live broadcasts](struct.LiveBroadcastListCall.html) (none)
/// * [transition live broadcasts](struct.LiveBroadcastTransitionCall.html) (response)
/// * [update live broadcasts](struct.LiveBroadcastUpdateCall.html) (request|response)
/// * [delete live broadcasts](struct.LiveBroadcastDeleteCall.html) (none)
/// * [bind live broadcasts](struct.LiveBroadcastBindCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveBroadcast {
    /// The <code>status</code> object contains information about the event's
    /// status.
    pub status: Option<LiveBroadcastStatus>,
    /// The <code>snippet</code> object contains basic details about the event,
    /// including its title, description, start time, and end time.
    pub snippet: Option<LiveBroadcastSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#liveBroadcast"</code>.
    pub kind: Option<String>,
    /// The <code>statistics</code> object contains info about the event's current
    /// stats. These include concurrent viewers and total chat count. Statistics
    /// can change (in either direction) during the lifetime of an event.
    /// Statistics are only returned while the event is live.
    pub statistics: Option<LiveBroadcastStatistics>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The <code>contentDetails</code> object contains information about the
    /// event's video content, such as whether the content can be shown in an
    /// embedded video player or if it will be archived and therefore available
    /// for viewing after the event has concluded.
    #[serde(rename="contentDetails")]
    pub content_details: Option<LiveBroadcastContentDetails>,
    /// The ID that YouTube assigns to uniquely identify the broadcast.
    pub id: Option<String>,
}

impl RequestValue for LiveBroadcast {}
impl Resource for LiveBroadcast {}
impl ResponseResult for LiveBroadcast {}

impl ToParts for LiveBroadcast {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.status.is_some() { r = r + "status,"; }
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.statistics.is_some() { r = r + "statistics,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.content_details.is_some() { r = r + "contentDetails,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// A <code><strong>third party account link</strong></code> resource represents
/// a link between a YouTube account or a channel and an account on a
/// third-party service.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list third party links](struct.ThirdPartyLinkListCall.html) (response)
/// * [delete third party links](struct.ThirdPartyLinkDeleteCall.html) (none)
/// * [insert third party links](struct.ThirdPartyLinkInsertCall.html) (request|response)
/// * [update third party links](struct.ThirdPartyLinkUpdateCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ThirdPartyLink {
    /// The <code>snippet</code> object contains basic details about the third-
    /// party account link.
    pub snippet: Option<ThirdPartyLinkSnippet>,
    /// The <code>status</code> object contains information about the status
    /// of the link.
    pub status: Option<ThirdPartyLinkStatus>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#thirdPartyLink"</code>.
    pub kind: Option<String>,
    /// Etag of this resource
    pub etag: Option<String>,
    /// The <code>linking_token</code> identifies a YouTube account and
    /// channel with which the third party account is linked.
    #[serde(rename="linkingToken")]
    pub linking_token: Option<String>,
}

impl RequestValue for ThirdPartyLink {}
impl Resource for ThirdPartyLink {}
impl ResponseResult for ThirdPartyLink {}

impl ToParts for ThirdPartyLink {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.status.is_some() { r = r + "status,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.linking_token.is_some() { r = r + "linkingToken,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveStreamConfigurationIssue {
    /// The short-form reason for this issue.
    pub reason: Option<String>,
    /// The kind of error happening.
    #[serde(rename="type")]
    pub type_: Option<String>,
    /// The long-form description of the issue and how to resolve it.
    pub description: Option<String>,
    /// How severe this issue is to the stream.
    pub severity: Option<String>,
}

impl Part for LiveStreamConfigurationIssue {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list live chat moderators](struct.LiveChatModeratorListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatModeratorListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#liveChatModeratorListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of moderators that match the request criteria.
    pub items: Option<Vec<LiveChatModerator>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the previous page in the result set.
    #[serde(rename="prevPageToken")]
    pub prev_page_token: Option<String>,
    /// General pagination information.
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for LiveChatModeratorListResponse {}

impl ToParts for LiveChatModeratorListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.prev_page_token.is_some() { r = r + "prevPageToken,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// A resource id is a generic reference that points to another YouTube resource.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ResourceId {
    /// The type of the API resource.
    pub kind: Option<String>,
    /// The ID that YouTube uses to uniquely identify the referred resource, if
    /// that resource is a channel. This property is only present if the
    /// <code>resourceId.kind</code> value is <code>youtube#channel</code>.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The ID that YouTube uses to uniquely identify the referred resource, if
    /// that resource is a playlist. This property is only present if the
    /// <code>resourceId.kind</code> value is <code>youtube#playlist</code>.
    #[serde(rename="playlistId")]
    pub playlist_id: Option<String>,
    /// The ID that YouTube uses to uniquely identify the referred resource, if
    /// that resource is a video. This property is only present if the
    /// <code>resourceId.kind</code> value is <code>youtube#video</code>.
    #[serde(rename="videoId")]
    pub video_id: Option<String>,
}

impl Part for ResourceId {}


/// Information about the uploaded video.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityContentDetailsUpload {
    /// The ID that YouTube uses to uniquely identify the uploaded video.
    #[serde(rename="videoId")]
    pub video_id: Option<String>,
}

impl Part for ActivityContentDetailsUpload {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list activities](struct.ActivityListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ActivityListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#activityListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// no description provided
    pub items: Option<Vec<Activity>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the previous page in the result set.
    #[serde(rename="prevPageToken")]
    pub prev_page_token: Option<String>,
    /// General pagination information.
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for ActivityListResponse {}

impl ToParts for ActivityListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.prev_page_token.is_some() { r = r + "prevPageToken,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PlaylistPlayer {
    /// An <code>&lt;iframe&gt;</code> tag that embeds a player that will
    /// play the playlist.
    #[serde(rename="embedHtml")]
    pub embed_html: Option<String>,
}

impl Part for PlaylistPlayer {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct MemberSnippet {
    /// Details about the user's membership.
    #[serde(rename="membershipsDetails")]
    pub memberships_details: Option<MembershipsDetails>,
    /// The id of the channel that's offering memberships.
    #[serde(rename="creatorChannelId")]
    pub creator_channel_id: Option<String>,
    /// Details about the member.
    #[serde(rename="memberDetails")]
    pub member_details: Option<ChannelProfileDetails>,
}

impl Part for MemberSnippet {}


/// A `__sponsor__` resource represents a sponsor for a YouTube channel.  A
/// sponsor provides recurring monetary support to a creator and receives special
/// benefits.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list sponsors](struct.SponsorListCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Sponsor {
    /// The `snippet` object contains basic details about the sponsor.
    pub snippet: Option<SponsorSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// `"youtube#sponsor"`.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
}

impl Resource for Sponsor {}

impl ToParts for Sponsor {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        r.pop();
        r
    }
}

/// Recording information associated with the video.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoRecordingDetails {
    /// The date and time when the video was recorded. The value is specified in <a
    /// href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// (<code>YYYY-MM-DDThh:mm:ss.sssZ</code>) format.
    #[serde(rename="recordingDate")]
    pub recording_date: Option<String>,
    /// The text description of the location where the video was recorded.
    #[serde(rename="locationDescription")]
    pub location_description: Option<String>,
    /// The geolocation information associated with the video.
    pub location: Option<GeoPoint>,
}

impl Part for VideoRecordingDetails {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PlaylistStatus {
    /// The playlist's privacy status.
    #[serde(rename="privacyStatus")]
    pub privacy_status: Option<String>,
}

impl Part for PlaylistStatus {}


/// Settings and Info of the monitor stream
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct MonitorStreamInfo {
    /// If you have set the
    /// <code><a href="#enableMonitorStream">enableMonitorStream</a></code>
    /// property to <code>true</code>, then this property determines the
    /// length of the live broadcast delay.
    #[serde(rename="broadcastStreamDelayMs")]
    pub broadcast_stream_delay_ms: Option<u32>,
    /// HTML code that embeds a player that plays the monitor stream.
    #[serde(rename="embedHtml")]
    pub embed_html: Option<String>,
    /// This value determines whether the monitor stream is enabled for the
    /// broadcast. If the monitor stream is enabled, then YouTube will
    /// broadcast the event content on a special stream intended only for
    /// the broadcaster's consumption. The broadcaster can use the stream
    /// to review the event content and also to identify the optimal times
    /// to insert cuepoints.<br><br>
    /// You need to set this value to <code>true</code> if you intend to have
    /// a broadcast delay for your event.<br><br>
    /// <strong>Note:</strong> This property cannot be updated once the
    /// broadcast is in the <code>testing</code> or <code>live</code> state.
    #[serde(rename="enableMonitorStream")]
    pub enable_monitor_stream: Option<bool>,
}

impl Part for MonitorStreamInfo {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct MembershipsLevelSnippet {
    /// Details about the pricing level.
    #[serde(rename="levelDetails")]
    pub level_details: Option<LevelDetails>,
    /// The id of the channel that's offering channel memberships.
    #[serde(rename="creatorChannelId")]
    pub creator_channel_id: Option<String>,
}

impl Part for MembershipsLevelSnippet {}


/// Details about the live streaming metadata.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoLiveStreamingDetails {
    /// The time that the broadcast is scheduled to begin. The value is specified
    /// in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="scheduledStartTime")]
    pub scheduled_start_time: Option<String>,
    /// The time that the broadcast actually ended. The value is specified
    /// in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format. This value will not be
    /// available until the broadcast is over.
    #[serde(rename="actualEndTime")]
    pub actual_end_time: Option<String>,
    /// The number of viewers currently watching the broadcast. The property and
    /// its value will be present if the broadcast has current viewers and the
    /// broadcast owner has not hidden the viewcount for the video. Note that
    /// YouTube stops tracking the number of concurrent viewers for a broadcast
    /// when the broadcast ends. So, this property would not identify the number
    /// of viewers watching an archived video of a live broadcast that already
    /// ended.
    #[serde(rename="concurrentViewers")]
    pub concurrent_viewers: Option<String>,
    /// The ID of the currently active live chat attached to this video. This
    /// field is filled only if the video is a currently live broadcast that has
    /// live chat. Once the broadcast transitions to complete this field will be
    /// removed and the live chat closed down. For persistent broadcasts that live
    /// chat id will no longer be tied to this video but rather to the new video
    /// being displayed at the persistent page.
    #[serde(rename="activeLiveChatId")]
    pub active_live_chat_id: Option<String>,
    /// The time that the broadcast actually started. The value is specified
    /// in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format. This value will not be
    /// available until the broadcast begins.
    #[serde(rename="actualStartTime")]
    pub actual_start_time: Option<String>,
    /// The time that the broadcast is scheduled to end. The value is specified
    /// in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format. If the value is empty or
    /// the property is not present, then the broadcast is scheduled to continue
    /// indefinitely.
    #[serde(rename="scheduledEndTime")]
    pub scheduled_end_time: Option<String>,
}

impl Part for VideoLiveStreamingDetails {}


/// Freebase topic information related to the video.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoTopicDetails {
    /// A list of Freebase topic IDs that are centrally associated with the video.
    /// These are topics that are centrally featured in the video, and it can be
    /// said that the video is mainly about each of these. You can retrieve
    /// information about each topic using the < a
    /// href="http://wiki.freebase.com/wiki/Topic_API">Freebase Topic API</a>.
    #[serde(rename="topicIds")]
    pub topic_ids: Option<Vec<String>>,
    /// Similar to topic_id, except that these topics are merely relevant to the
    /// video. These are topics that may be mentioned in, or appear in the video.
    /// You can retrieve information about each topic using <a
    /// href="http://wiki.freebase.com/wiki/Topic_API">Freebase Topic API</a>.
    #[serde(rename="relevantTopicIds")]
    pub relevant_topic_ids: Option<Vec<String>>,
    /// A list of Wikipedia URLs that provide a high-level description of the
    /// video's content.
    #[serde(rename="topicCategories")]
    pub topic_categories: Option<Vec<String>>,
}

impl Part for VideoTopicDetails {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveStreamHealthStatus {
    /// The status code of this stream
    pub status: Option<String>,
    /// The configurations issues on this stream
    #[serde(rename="configurationIssues")]
    pub configuration_issues: Option<Vec<LiveStreamConfigurationIssue>>,
    /// The last time this status was updated (in seconds)
    #[serde(rename="lastUpdateTimeSeconds")]
    pub last_update_time_seconds: Option<String>,
}

impl Part for LiveStreamHealthStatus {}


/// A `__videoAbuseReportReason__` resource identifies a reason that a video
/// could be reported as abusive. Video abuse report reasons are used with
/// `video.ReportAbuse`.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list video abuse report reasons](struct.VideoAbuseReportReasonListCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoAbuseReportReason {
    /// The `snippet` object contains basic details about the abuse report reason.
    pub snippet: Option<VideoAbuseReportReasonSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// `"youtube#videoAbuseReportReason"`.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID of this abuse report reason.
    pub id: Option<String>,
}

impl Resource for VideoAbuseReportReason {}

impl ToParts for VideoAbuseReportReason {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// An <code><strong>activity</strong></code> resource contains
/// information about an action that a particular channel, or user, has
/// taken on YouTube.The actions reported in activity feeds include rating
/// a video, sharing a video, marking a video as a favorite, commenting on
/// a video, uploading a video, and so forth. Each <code>activity</code>
/// resource identifies the type of action, the channel associated with
/// the action, and the resource(s) associated with the action, such as
/// the video that was rated or uploaded.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Activity {
    /// The <code>snippet</code> object contains basic details about the
    /// activity, including the activity's type and group ID.
    pub snippet: Option<ActivitySnippet>,
    /// The <code>contentDetails</code> object contains information about the
    /// content associated with the activity. For example, if the
    /// <code>snippet.type</code> value is <code>videoRated</code>, then the
    /// <code>contentDetails</code> object's content identifies the rated video.
    #[serde(rename="contentDetails")]
    pub content_details: Option<ActivityContentDetails>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#activity"</code>.
    pub kind: Option<String>,
    /// Etag of this resource
    pub etag: Option<String>,
    /// The ID that YouTube uses to uniquely identify the activity.
    pub id: Option<String>,
}

impl Part for Activity {}


/// Basic details about a subscription's subscriber including title,
/// description, channel ID and thumbnails.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SubscriptionSubscriberSnippet {
    /// The channel ID of the subscriber.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The description of the subscriber.
    pub description: Option<String>,
    /// Thumbnails for this subscriber.
    pub thumbnails: Option<ThumbnailDetails>,
    /// The title of the subscriber.
    pub title: Option<String>,
}

impl Part for SubscriptionSubscriberSnippet {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list comment threads](struct.CommentThreadListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct CommentThreadListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#commentThreadListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// A list of comment threads that match the request criteria.
    pub items: Option<Vec<CommentThread>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// General pagination information.
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for CommentThreadListResponse {}

impl ToParts for CommentThreadListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct MembershipsDurationAtLevel {
    /// The cumulative time the user has been a member for the given level in
    /// complete months (the time is rounded down to the nearest integer).
    #[serde(rename="memberTotalDurationMonths")]
    pub member_total_duration_months: Option<i32>,
    /// Pricing level ID.
    pub level: Option<String>,
    /// The date and time when the user became a continuous member for the given
    /// level.
    #[serde(rename="memberSince")]
    pub member_since: Option<String>,
}

impl Part for MembershipsDurationAtLevel {}


/// Playlist localization setting
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PlaylistLocalization {
    /// The localized strings for playlist's description.
    pub description: Option<String>,
    /// The localized strings for playlist's title.
    pub title: Option<String>,
}

impl Part for PlaylistLocalization {}


/// An <code><strong>i18nLanguage</strong></code> resource identifies a UI
/// language currently supported by YouTube.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list i18n languages](struct.I18nLanguageListCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct I18nLanguage {
    /// The <code>snippet</code> object contains basic details about the i18n
    /// language, such as language code and human-readable name.
    pub snippet: Option<I18nLanguageSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#i18nLanguage"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube uses to uniquely identify the i18n language.
    pub id: Option<String>,
}

impl Resource for I18nLanguage {}

impl ToParts for I18nLanguage {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// Basic broadcast information.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveBroadcastSnippet {
    /// The date and time that the broadcast actually ended. This information is
    /// only available once the broadcast's state is <code>complete</code>. The
    /// value is specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="actualEndTime")]
    pub actual_end_time: Option<String>,
    /// The broadcast's description. As with the <code>title</code>, you can set
    /// this field by modifying the broadcast resource or by setting the
    /// <code><a
    /// href="/youtube/v3/docs/videos#snippet.description">description</a></code>
    /// field of the corresponding video resource.
    pub description: Option<String>,
    /// The broadcast's title. Note that the broadcast represents exactly one
    /// YouTube video. You can set this field by modifying the broadcast resource
    /// or by setting the
    /// <code><a href="/youtube/v3/docs/videos#snippet.title">title</a></code>
    /// field of the corresponding video resource.
    pub title: Option<String>,
    /// The ID that YouTube uses to uniquely identify the channel that
    /// is publishing the broadcast.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The date and time that the broadcast was added to YouTube's live broadcast
    /// schedule. The value is specified in
    /// <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="publishedAt")]
    pub published_at: Option<String>,
    /// The id of the live chat for this broadcast.
    #[serde(rename="liveChatId")]
    pub live_chat_id: Option<String>,
    /// The date and time that the broadcast is scheduled to start. The value
    /// is specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="scheduledStartTime")]
    pub scheduled_start_time: Option<String>,
    /// The date and time that the broadcast actually started. This information is
    /// only available once the broadcast's state is <code>live</code>. The
    /// value is specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="actualStartTime")]
    pub actual_start_time: Option<String>,
    /// The date and time that the broadcast is scheduled to end. The value
    /// is specified in <a href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="scheduledEndTime")]
    pub scheduled_end_time: Option<String>,
    /// Indicates whether this broadcast is the default broadcast.
    /// Internal only.
    #[serde(rename="isDefaultBroadcast")]
    pub is_default_broadcast: Option<bool>,
    /// A map of thumbnail images associated with the broadcast. For each nested
    /// object in this object, the key is the name of the thumbnail image, and
    /// the value is an object that contains other information about the
    /// thumbnail.
    pub thumbnails: Option<ThumbnailDetails>,
}

impl Part for LiveBroadcastSnippet {}


/// Basic details about a comment thread.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct CommentThreadSnippet {
    /// The top level comment of this thread.
    #[serde(rename="topLevelComment")]
    pub top_level_comment: Option<Comment>,
    /// Whether the current viewer of the thread can reply to it. This is viewer
    /// specific - other viewers may see a different value for this field.
    #[serde(rename="canReply")]
    pub can_reply: Option<bool>,
    /// The YouTube channel the comments in the thread refer to or the channel
    /// with the video the comments refer to. If video_id isn't set the comments
    /// refer to the channel itself.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The total number of replies (not including the top level comment).
    #[serde(rename="totalReplyCount")]
    pub total_reply_count: Option<u32>,
    /// Whether the thread (and therefore all its comments) is visible to all
    /// YouTube users.
    #[serde(rename="isPublic")]
    pub is_public: Option<bool>,
    /// The ID of the video the comments refer to, if any. No video_id implies a
    /// channel discussion comment.
    #[serde(rename="videoId")]
    pub video_id: Option<String>,
}

impl Part for CommentThreadSnippet {}


/// Detailed settings of a broadcast.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveBroadcastContentDetails {
    /// This setting indicates whether the broadcast should automatically begin
    /// with an <a
    /// href="/youtube/v3/live/getting-started#Displaying_Slates">in-stream
    /// slate</a> when you update the broadcast's status to <code>live</code>.
    /// After updating the status, you then need to send a
    /// <code><a
    /// href="/youtube/v3/live/docs/liveCuepoints/insert">liveCuepoints.insert</a></code>
    /// request that sets the cuepoint's <code>eventState</code> to
    /// <code>end</code> to remove the in-stream slate and make your broadcast
    /// stream visible to viewers.
    #[serde(rename="startWithSlate")]
    pub start_with_slate: Option<bool>,
    /// The <code>monitorStream</code> object contains information about the
    /// monitor stream, which the broadcaster can use to review the event
    /// content before the broadcast stream is shown publicly.
    #[serde(rename="monitorStream")]
    pub monitor_stream: Option<MonitorStreamInfo>,
    /// Automatically start recording after the event goes live.
    /// The default value for this property is <code>true</code>.<br><br>
    /// 
    /// <strong>Important:</strong> You must also set the <code>enableDvr</code>
    /// property's value to
    /// <code>true</code> if you want the playback to be available immediately
    /// after the broadcast ends. If you set this property's value to
    /// <code>true</code> but do not also set the <code>enableDvr</code> property
    /// to <code>true</code>, there may be a delay of around one day before the
    /// archived video will be available for playback.
    #[serde(rename="recordFromStart")]
    pub record_from_start: Option<bool>,
    /// If both this and enable_low_latency are set, they must match.
    /// LATENCY_NORMAL should match enable_low_latency=false
    /// LATENCY_LOW should match enable_low_latency=true
    /// LATENCY_ULTRA_LOW should have enable_low_latency omitted.
    #[serde(rename="latencyPreference")]
    pub latency_preference: Option<String>,
    /// The mesh for projecting the video if <code>projection</code> is
    /// <code>mesh</code>. The mesh value must be a UTF-8 string containing the
    /// base-64 encoding of 3D mesh data that follows the <a
    /// href="https://github.com/google/spatial-media/blob/master/docs/spherical-video-v2-rfc.md">
    /// Spherical Video V2 RFC specification</a> for an mshp box, excluding the box
    /// size and type but including the following four reserved zero bytes for the
    /// version and flags.
    pub mesh: Option<String>,
    /// This setting indicates whether HTTP POST closed captioning is enabled for
    /// this broadcast. The ingestion URL of the closed captions is returned
    /// through the liveStreams API.  This is mutually exclusive with using the
    /// <code>closed_captions_type</code> property, and is equivalent to setting
    /// <code>closed_captions_type</code> to CLOSED_CAPTIONS_HTTP_POST.
    #[serde(rename="enableClosedCaptions")]
    pub enable_closed_captions: Option<bool>,
    /// Indicates whether this broadcast has low latency enabled.
    #[serde(rename="enableLowLatency")]
    pub enable_low_latency: Option<bool>,
    /// This setting indicates whether YouTube should enable content encryption
    /// for the broadcast.
    #[serde(rename="enableContentEncryption")]
    pub enable_content_encryption: Option<bool>,
    /// The projection format of this broadcast. This defaults to
    /// <code>rectangular</code>.
    pub projection: Option<String>,
    /// The date and time that the live stream referenced by
    /// <code>boundStreamId</code> was last updated.
    #[serde(rename="boundStreamLastUpdateTimeMs")]
    pub bound_stream_last_update_time_ms: Option<String>,
    /// This value uniquely identifies the
    /// <code><a href="/youtube/v3/live/docs/liveStreams">live stream</a></code>
    /// bound to the broadcast.
    #[serde(rename="boundStreamId")]
    pub bound_stream_id: Option<String>,
    /// This setting indicates whether auto stop is enabled for this broadcast.
    /// The default value for this property is <code>false</code>.<br><br>
    /// This setting can only be used by Events.
    #[serde(rename="enableAutoStop")]
    pub enable_auto_stop: Option<bool>,
    /// This setting indicates whether the broadcast video can be played in an
    /// embedded player. If you choose to archive the video (using the
    /// <code>enableArchive</code> property), this setting will also apply to
    /// the archived video.
    #[serde(rename="enableEmbed")]
    pub enable_embed: Option<bool>,
    /// no description provided
    #[serde(rename="closedCaptionsType")]
    pub closed_captions_type: Option<String>,
    /// This setting determines whether viewers can access DVR controls while
    /// watching the video. DVR controls enable the viewer to control the video
    /// playback experience by pausing, rewinding, or fast forwarding content.
    /// The default value for this property is <code>true</code>.<br><br>
    /// 
    /// <strong>Important:</strong> You must set the value to <code>true</code>
    /// and also set the <code>enableArchive</code> property's value to
    /// <code>true</code> if you want to make playback available immediately
    /// after the broadcast ends.
    #[serde(rename="enableDvr")]
    pub enable_dvr: Option<bool>,
    /// This setting indicates whether auto start is enabled for this broadcast.
    ///  The default value for this property is <code>false</code>.<br><br>
    ///  This setting can only be used by Events.
    #[serde(rename="enableAutoStart")]
    pub enable_auto_start: Option<bool>,
}

impl Part for LiveBroadcastContentDetails {}


/// Basic details about a video category, such as its localized title.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoCategorySnippet {
    /// no description provided
    pub assignable: Option<bool>,
    /// The YouTube channel that created the video category.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The video category's title.
    pub title: Option<String>,
}

impl Part for VideoCategorySnippet {}


/// Statistics about a channel: number of subscribers, number of videos in the
/// channel, etc.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ChannelStatistics {
    /// The number of comments for the channel.
    #[serde(rename="commentCount")]
    pub comment_count: Option<String>,
    /// The number of subscribers that the channel has.
    #[serde(rename="subscriberCount")]
    pub subscriber_count: Option<String>,
    /// The number of videos uploaded to the channel.
    #[serde(rename="videoCount")]
    pub video_count: Option<String>,
    /// Whether or not the number of subscribers is shown for this user.
    #[serde(rename="hiddenSubscriberCount")]
    pub hidden_subscriber_count: Option<bool>,
    /// The number of times the channel has been viewed.
    #[serde(rename="viewCount")]
    pub view_count: Option<String>,
}

impl Part for ChannelStatistics {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [list search](struct.SearchListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SearchListResponse {
    /// Serialized EventId of the request which produced this response.
    #[serde(rename="eventId")]
    pub event_id: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the next page in the result set.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#searchListResponse"</code>.
    pub kind: Option<String>,
    /// The <code>visitorId</code> identifies the visitor.
    #[serde(rename="visitorId")]
    pub visitor_id: Option<String>,
    /// Pagination information for token pagination.
    pub items: Option<Vec<SearchResult>>,
    /// no description provided
    #[serde(rename="tokenPagination")]
    pub token_pagination: Option<TokenPagination>,
    /// no description provided
    #[serde(rename="regionCode")]
    pub region_code: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The token that can be used as the value of the <code>pageToken</code>
    /// parameter to retrieve the previous page in the result set.
    #[serde(rename="prevPageToken")]
    pub prev_page_token: Option<String>,
    /// General pagination information.
    #[serde(rename="pageInfo")]
    pub page_info: Option<PageInfo>,
}

impl ResponseResult for SearchListResponse {}

impl ToParts for SearchListResponse {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.event_id.is_some() { r = r + "eventId,"; }
        if self.next_page_token.is_some() { r = r + "nextPageToken,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.visitor_id.is_some() { r = r + "visitorId,"; }
        if self.items.is_some() { r = r + "items,"; }
        if self.token_pagination.is_some() { r = r + "tokenPagination,"; }
        if self.region_code.is_some() { r = r + "regionCode,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.prev_page_token.is_some() { r = r + "prevPageToken,"; }
        if self.page_info.is_some() { r = r + "pageInfo,"; }
        r.pop();
        r
    }
}

/// A <code><strong>liveChatModerator</strong></code> resource represents a
/// moderator for a YouTube live chat. A chat moderator has the ability to
/// ban/unban users from a chat, remove message, etc.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [insert live chat moderators](struct.LiveChatModeratorInsertCall.html) (request|response)
/// * [list live chat moderators](struct.LiveChatModeratorListCall.html) (none)
/// * [delete live chat moderators](struct.LiveChatModeratorDeleteCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct LiveChatModerator {
    /// The <code>snippet</code> object contains basic details about the
    /// moderator.
    pub snippet: Option<LiveChatModeratorSnippet>,
    /// Identifies what kind of resource this is. Value: the fixed string
    /// <code>"youtube#liveChatModerator"</code>.
    pub kind: Option<String>,
    /// Etag of this resource.
    pub etag: Option<String>,
    /// The ID that YouTube assigns to uniquely identify the moderator.
    pub id: Option<String>,
}

impl RequestValue for LiveChatModerator {}
impl Resource for LiveChatModerator {}
impl ResponseResult for LiveChatModerator {}

impl ToParts for LiveChatModerator {
    /// Return a comma separated list of members that are currently set, i.e. for which `self.member.is_some()`.
    /// The produced string is suitable for use as a parts list that indicates the parts you are sending, and/or
    /// the parts you want to see in the server response.
    fn to_parts(&self) -> String {
        let mut r = String::new();
        if self.snippet.is_some() { r = r + "snippet,"; }
        if self.kind.is_some() { r = r + "kind,"; }
        if self.etag.is_some() { r = r + "etag,"; }
        if self.id.is_some() { r = r + "id,"; }
        r.pop();
        r
    }
}

/// Specifies suggestions on how to improve video content,
/// including encoding hints, tag suggestions, and editor suggestions.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VideoSuggestions {
    /// A list of errors that will prevent YouTube from successfully processing
    /// the uploaded video video. These errors indicate that, regardless of the
    /// video's current <a href="#processingProgress.processingStatus">processing
    /// status</a>, eventually, that status will almost certainly be
    /// <code>failed</code>.
    #[serde(rename="processingErrors")]
    pub processing_errors: Option<Vec<String>>,
    /// A list of keyword tags that could be added to the video's metadata to
    /// increase the likelihood that users will locate your video when searching
    /// or browsing on YouTube.
    #[serde(rename="tagSuggestions")]
    pub tag_suggestions: Option<Vec<VideoSuggestionsTagSuggestion>>,
    /// A list of video editing operations that might improve the video quality
    /// or playback experience of the uploaded video.
    #[serde(rename="editorSuggestions")]
    pub editor_suggestions: Option<Vec<String>>,
    /// A list of reasons why YouTube may have difficulty transcoding the
    /// uploaded video or that might result in an erroneous transcoding.
    /// These warnings are generated before YouTube actually processes the
    /// uploaded video file. In addition, they identify issues that are unlikely
    /// to cause the video processing to fail but that might cause problems
    /// such as sync issues, video artifacts, or a missing audio track.
    #[serde(rename="processingWarnings")]
    pub processing_warnings: Option<Vec<String>>,
    /// A list of suggestions that may improve YouTube's ability to process the
    /// video.
    #[serde(rename="processingHints")]
    pub processing_hints: Option<Vec<String>>,
}

impl Part for VideoSuggestions {}


/// Basic details about a search result, including title, description and
/// thumbnails of the item referenced by the search result.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SearchResultSnippet {
    /// It indicates if the resource (video or channel) has upcoming/active live
    /// broadcast content. Or it's "none" if there is not any upcoming/active
    /// live broadcasts.
    #[serde(rename="liveBroadcastContent")]
    pub live_broadcast_content: Option<String>,
    /// A description of the search result.
    pub description: Option<String>,
    /// The title of the search result.
    pub title: Option<String>,
    /// A map of thumbnail images associated with the search result. For each
    /// object in the map, the key is the name of the thumbnail image, and the
    /// value is an object that contains other information about the thumbnail.
    pub thumbnails: Option<ThumbnailDetails>,
    /// The value that YouTube uses to uniquely identify the channel that
    /// published the resource that the search result identifies.
    #[serde(rename="channelId")]
    pub channel_id: Option<String>,
    /// The creation date and time of the resource that the search result
    /// identifies. The value is specified in <a
    /// href="//www.w3.org/TR/NOTE-datetime">ISO 8601</a>
    /// format.
    #[serde(rename="publishedAt")]
    pub published_at: Option<String>,
    /// The title of the channel that published the resource that the search result
    /// identifies.
    #[serde(rename="channelTitle")]
    pub channel_title: Option<String>,
}

impl Part for SearchResultSnippet {}



// ###################
// MethodBuilders ###
// #################

/// A builder providing access to all methods supported on *channelSection* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `delete(...)`, `insert(...)`, `list(...)` and `update(...)`
/// // to build up your call.
/// let rb = hub.channel_sections();
/// # }
/// ```
pub struct ChannelSectionMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for ChannelSectionMethods<'a, C, A> {}

impl<'a, C, A> ChannelSectionMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>channelSection</code> resource
    ///            properties that the API response will include. The <code>part</code> names
    ///            that you can include in the parameter value are <code>id</code>,
    ///            <code>snippet</code>, and <code>contentDetails</code>.<br><br>If the
    ///            parameter identifies a property that contains child properties, the child
    ///            properties will be included in the response. For example, in a
    ///            <code>channelSection</code> resource, the <code>snippet</code> property
    ///            contains other properties, such as a display title for the channelSection.
    ///            If you set <code><strong>part=snippet</strong></code>, the API response
    ///            will also contain all of those nested properties.
    pub fn list(&self, part: &Vec<String>) -> ChannelSectionListCall<'a, C, A> {
        ChannelSectionListCall {
            hub: self.hub,
            _part: part.clone(),
            _on_behalf_of_content_owner: Default::default(),
            _mine: Default::default(),
            _id: Default::default(),
            _hl: Default::default(),
            _channel_id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: ChannelSection) -> ChannelSectionInsertCall<'a, C, A> {
        let parts = request.to_parts();
        ChannelSectionInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes a resource.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn delete(&self, id: &str) -> ChannelSectionDeleteCall<'a, C, A> {
        ChannelSectionDeleteCall {
            hub: self.hub,
            _id: id.to_string(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates an existing resource.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn update(&self, request: ChannelSection) -> ChannelSectionUpdateCall<'a, C, A> {
        let parts = request.to_parts();
        ChannelSectionUpdateCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *playlist* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `delete(...)`, `insert(...)`, `list(...)` and `update(...)`
/// // to build up your call.
/// let rb = hub.playlists();
/// # }
/// ```
pub struct PlaylistMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for PlaylistMethods<'a, C, A> {}

impl<'a, C, A> PlaylistMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: Playlist) -> PlaylistInsertCall<'a, C, A> {
        let parts = request.to_parts();
        PlaylistInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>playlist</code> resource
    ///            properties that the API response will include.<br><br>If the parameter
    ///            identifies a property that contains child properties, the child properties
    ///            will be included in the response. For example, in a <code>playlist</code>
    ///            resource, the <code>snippet</code> property contains properties like
    ///            <code>author</code>, <code>title</code>, <code>description</code>,
    ///            <code>tags</code>, and <code>timeCreated</code>. As such, if you set
    ///            <code><strong>part=snippet</strong></code>, the API response will contain
    ///            all of those properties.
    pub fn list(&self, part: &Vec<String>) -> PlaylistListCall<'a, C, A> {
        PlaylistListCall {
            hub: self.hub,
            _part: part.clone(),
            _page_token: Default::default(),
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _mine: Default::default(),
            _max_results: Default::default(),
            _id: Default::default(),
            _hl: Default::default(),
            _channel_id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes a resource.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn delete(&self, id: &str) -> PlaylistDeleteCall<'a, C, A> {
        PlaylistDeleteCall {
            hub: self.hub,
            _id: id.to_string(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates an existing resource.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn update(&self, request: Playlist) -> PlaylistUpdateCall<'a, C, A> {
        let parts = request.to_parts();
        PlaylistUpdateCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *video* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `delete(...)`, `get_rating(...)`, `insert(...)`, `list(...)`, `rate(...)`, `report_abuse(...)` and `update(...)`
/// // to build up your call.
/// let rb = hub.videos();
/// # }
/// ```
pub struct VideoMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for VideoMethods<'a, C, A> {}

impl<'a, C, A> VideoMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Report abuse for a video.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn report_abuse(&self, request: VideoAbuseReport) -> VideoReportAbuseCall<'a, C, A> {
        VideoReportAbuseCall {
            hub: self.hub,
            _request: request,
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>video</code> resource properties
    ///            that the API response will include.<br><br>If the parameter identifies a
    ///            property that contains child properties, the child properties will be
    ///            included in the response. For example, in a <code>video</code> resource,
    ///            the <code>snippet</code> property contains the <code>channelId</code>,
    ///            <code>title</code>, <code>description</code>, <code>tags</code>, and
    ///            <code>categoryId</code> properties. As such, if you set
    ///            <code><strong>part=snippet</strong></code>, the API response will contain
    ///            all of those properties.
    pub fn list(&self, part: &Vec<String>) -> VideoListCall<'a, C, A> {
        VideoListCall {
            hub: self.hub,
            _part: part.clone(),
            _video_category_id: Default::default(),
            _region_code: Default::default(),
            _page_token: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _my_rating: Default::default(),
            _max_width: Default::default(),
            _max_results: Default::default(),
            _max_height: Default::default(),
            _locale: Default::default(),
            _id: Default::default(),
            _hl: Default::default(),
            _chart: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Adds a like or dislike rating to a video or removes a rating from a video.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    /// * `rating` - No description provided.
    pub fn rate(&self, id: &str, rating: &str) -> VideoRateCall<'a, C, A> {
        VideoRateCall {
            hub: self.hub,
            _id: id.to_string(),
            _rating: rating.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the ratings that the authorized user gave to a list of specified
    /// videos.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn get_rating(&self, id: &Vec<String>) -> VideoGetRatingCall<'a, C, A> {
        VideoGetRatingCall {
            hub: self.hub,
            _id: id.clone(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes a resource.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn delete(&self, id: &str) -> VideoDeleteCall<'a, C, A> {
        VideoDeleteCall {
            hub: self.hub,
            _id: id.to_string(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates an existing resource.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn update(&self, request: Video) -> VideoUpdateCall<'a, C, A> {
        let parts = request.to_parts();
        VideoUpdateCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: Video) -> VideoInsertCall<'a, C, A> {
        let parts = request.to_parts();
        VideoInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _stabilize: Default::default(),
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _notify_subscribers: Default::default(),
            _auto_levels: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *activity* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `list(...)`
/// // to build up your call.
/// let rb = hub.activities();
/// # }
/// ```
pub struct ActivityMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for ActivityMethods<'a, C, A> {}

impl<'a, C, A> ActivityMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>activity</code> resource
    ///            properties that the API response will include.<br><br>If the parameter
    ///            identifies a property that contains child properties, the child properties
    ///            will be included in the response. For example, in an <code>activity</code>
    ///            resource, the <code>snippet</code> property contains other properties that
    ///            identify the type of activity, a display title for the activity, and so
    ///            forth. If you set <code><strong>part=snippet</strong></code>, the API
    ///            response will also contain all of those nested properties.
    pub fn list(&self, part: &Vec<String>) -> ActivityListCall<'a, C, A> {
        ActivityListCall {
            hub: self.hub,
            _part: part.clone(),
            _region_code: Default::default(),
            _published_before: Default::default(),
            _published_after: Default::default(),
            _page_token: Default::default(),
            _mine: Default::default(),
            _max_results: Default::default(),
            _home: Default::default(),
            _channel_id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *liveStream* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `delete(...)`, `insert(...)`, `list(...)` and `update(...)`
/// // to build up your call.
/// let rb = hub.live_streams();
/// # }
/// ```
pub struct LiveStreamMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for LiveStreamMethods<'a, C, A> {}

impl<'a, C, A> LiveStreamMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates an existing stream for the authenticated user.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn update(&self, request: LiveStream) -> LiveStreamUpdateCall<'a, C, A> {
        let parts = request.to_parts();
        LiveStreamUpdateCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes an existing stream for the authenticated user.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn delete(&self, id: &str) -> LiveStreamDeleteCall<'a, C, A> {
        LiveStreamDeleteCall {
            hub: self.hub,
            _id: id.to_string(),
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieve the list of streams associated with the given channel. --
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>liveStream</code> resource
    ///            properties that the API response will include. The <code>part</code> names
    ///            that you can include in the parameter value are <code>id</code>,
    ///            <code>snippet</code>, <code>cdn</code>, and <code>status</code>.
    pub fn list(&self, part: &Vec<String>) -> LiveStreamListCall<'a, C, A> {
        LiveStreamListCall {
            hub: self.hub,
            _part: part.clone(),
            _page_token: Default::default(),
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _mine: Default::default(),
            _max_results: Default::default(),
            _id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new stream for the authenticated user.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: LiveStream) -> LiveStreamInsertCall<'a, C, A> {
        let parts = request.to_parts();
        LiveStreamInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *channel* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `list(...)` and `update(...)`
/// // to build up your call.
/// let rb = hub.channels();
/// # }
/// ```
pub struct ChannelMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for ChannelMethods<'a, C, A> {}

impl<'a, C, A> ChannelMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates an existing resource.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn update(&self, request: Channel) -> ChannelUpdateCall<'a, C, A> {
        let parts = request.to_parts();
        ChannelUpdateCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>channel</code> resource
    ///            properties that the API response will include.<br><br>If the parameter
    ///            identifies a property that contains child properties, the child properties
    ///            will be included in the response. For example, in a <code>channel</code>
    ///            resource, the <code>contentDetails</code> property contains other
    ///            properties, such as the <code>uploads</code> properties. As such, if you
    ///            set <code><strong>part=contentDetails</strong></code>, the API response
    ///            will also contain all of those nested properties.
    pub fn list(&self, part: &Vec<String>) -> ChannelListCall<'a, C, A> {
        ChannelListCall {
            hub: self.hub,
            _part: part.clone(),
            _page_token: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _my_subscribers: Default::default(),
            _mine: Default::default(),
            _max_results: Default::default(),
            _managed_by_me: Default::default(),
            _id: Default::default(),
            _hl: Default::default(),
            _for_username: Default::default(),
            _category_id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *watermark* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `set(...)` and `unset(...)`
/// // to build up your call.
/// let rb = hub.watermarks();
/// # }
/// ```
pub struct WatermarkMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for WatermarkMethods<'a, C, A> {}

impl<'a, C, A> WatermarkMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Allows upload of watermark image and setting it for a channel.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `channelId` - No description provided.
    pub fn set(&self, request: InvideoBranding, channel_id: &str) -> WatermarkSetCall<'a, C, A> {
        WatermarkSetCall {
            hub: self.hub,
            _request: request,
            _channel_id: channel_id.to_string(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Allows removal of channel watermark.
    /// 
    /// # Arguments
    ///
    /// * `channelId` - No description provided.
    pub fn unset(&self, channel_id: &str) -> WatermarkUnsetCall<'a, C, A> {
        WatermarkUnsetCall {
            hub: self.hub,
            _channel_id: channel_id.to_string(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *liveChatModerator* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `delete(...)`, `insert(...)` and `list(...)`
/// // to build up your call.
/// let rb = hub.live_chat_moderators();
/// # }
/// ```
pub struct LiveChatModeratorMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for LiveChatModeratorMethods<'a, C, A> {}

impl<'a, C, A> LiveChatModeratorMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: LiveChatModerator) -> LiveChatModeratorInsertCall<'a, C, A> {
        let parts = request.to_parts();
        LiveChatModeratorInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `liveChatId` - The id of the live chat for which moderators should be returned.
    /// * `part` - The <code><strong>part</strong></code> parameter specifies the
    ///            <code>liveChatModerator</code> resource parts that the API response will
    ///            include. Supported values are <code>id</code> and <code>snippet</code>.
    pub fn list(&self, live_chat_id: &str, part: &Vec<String>) -> LiveChatModeratorListCall<'a, C, A> {
        LiveChatModeratorListCall {
            hub: self.hub,
            _live_chat_id: live_chat_id.to_string(),
            _part: part.clone(),
            _page_token: Default::default(),
            _max_results: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes a chat moderator.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn delete(&self, id: &str) -> LiveChatModeratorDeleteCall<'a, C, A> {
        LiveChatModeratorDeleteCall {
            hub: self.hub,
            _id: id.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *caption* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `delete(...)`, `download(...)`, `insert(...)`, `list(...)` and `update(...)`
/// // to build up your call.
/// let rb = hub.captions();
/// # }
/// ```
pub struct CaptionMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for CaptionMethods<'a, C, A> {}

impl<'a, C, A> CaptionMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: Caption) -> CaptionInsertCall<'a, C, A> {
        let parts = request.to_parts();
        CaptionInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _sync: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _on_behalf_of: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes a resource.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn delete(&self, id: &str) -> CaptionDeleteCall<'a, C, A> {
        CaptionDeleteCall {
            hub: self.hub,
            _id: id.to_string(),
            _on_behalf_of_content_owner: Default::default(),
            _on_behalf_of: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Downloads a caption track.
    /// 
    /// # Arguments
    ///
    /// * `id` - The ID of the caption track to download, required for One Platform.
    pub fn download(&self, id: &str) -> CaptionDownloadCall<'a, C, A> {
        CaptionDownloadCall {
            hub: self.hub,
            _id: id.to_string(),
            _tlang: Default::default(),
            _tfmt: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _on_behalf_of: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `videoId` - Returns the captions for the specified video.
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>caption</code> resource parts
    ///            that the API response will include. The <code>part</code> names that you
    ///            can include in the parameter value are <code>id</code> and
    ///            <code>snippet</code>.
    pub fn list(&self, video_id: &str, part: &Vec<String>) -> CaptionListCall<'a, C, A> {
        CaptionListCall {
            hub: self.hub,
            _video_id: video_id.to_string(),
            _part: part.clone(),
            _on_behalf_of_content_owner: Default::default(),
            _on_behalf_of: Default::default(),
            _id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates an existing resource.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn update(&self, request: Caption) -> CaptionUpdateCall<'a, C, A> {
        let parts = request.to_parts();
        CaptionUpdateCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _sync: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _on_behalf_of: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *abuseReport* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `insert(...)`
/// // to build up your call.
/// let rb = hub.abuse_reports();
/// # }
/// ```
pub struct AbuseReportMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for AbuseReportMethods<'a, C, A> {}

impl<'a, C, A> AbuseReportMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: AbuseReport) -> AbuseReportInsertCall<'a, C, A> {
        let parts = request.to_parts();
        AbuseReportInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *i18nLanguage* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `list(...)`
/// // to build up your call.
/// let rb = hub.i18n_languages();
/// # }
/// ```
pub struct I18nLanguageMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for I18nLanguageMethods<'a, C, A> {}

impl<'a, C, A> I18nLanguageMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies the
    ///            <code>i18nLanguage</code> resource properties that the API response will
    ///            include. Set the parameter value to <code>snippet</code>.
    pub fn list(&self, part: &Vec<String>) -> I18nLanguageListCall<'a, C, A> {
        I18nLanguageListCall {
            hub: self.hub,
            _part: part.clone(),
            _hl: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *guideCategory* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `list(...)`
/// // to build up your call.
/// let rb = hub.guide_categories();
/// # }
/// ```
pub struct GuideCategoryMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for GuideCategoryMethods<'a, C, A> {}

impl<'a, C, A> GuideCategoryMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of guide categories.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies the
    ///            <code>guideCategory</code> resource properties that the API response will
    ///            include. Set the parameter value to <code>snippet</code>.
    pub fn list(&self, part: &Vec<String>) -> GuideCategoryListCall<'a, C, A> {
        GuideCategoryListCall {
            hub: self.hub,
            _part: part.clone(),
            _region_code: Default::default(),
            _id: Default::default(),
            _hl: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *membershipsLevel* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `list(...)`
/// // to build up your call.
/// let rb = hub.memberships_levels();
/// # }
/// ```
pub struct MembershipsLevelMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for MembershipsLevelMethods<'a, C, A> {}

impl<'a, C, A> MembershipsLevelMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of all pricing levels offered by a creator to the fans.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies the
    ///            <code>membershipsLevel</code> resource parts that the API response will
    ///            include. Supported values are <code>id</code> and <code>snippet</code>.
    pub fn list(&self, part: &Vec<String>) -> MembershipsLevelListCall<'a, C, A> {
        MembershipsLevelListCall {
            hub: self.hub,
            _part: part.clone(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *commentThread* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `insert(...)`, `list(...)` and `update(...)`
/// // to build up your call.
/// let rb = hub.comment_threads();
/// # }
/// ```
pub struct CommentThreadMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for CommentThreadMethods<'a, C, A> {}

impl<'a, C, A> CommentThreadMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>commentThread</code> resource
    ///            properties that the API response will include.
    pub fn list(&self, part: &Vec<String>) -> CommentThreadListCall<'a, C, A> {
        CommentThreadListCall {
            hub: self.hub,
            _part: part.clone(),
            _video_id: Default::default(),
            _text_format: Default::default(),
            _search_terms: Default::default(),
            _page_token: Default::default(),
            _order: Default::default(),
            _moderation_status: Default::default(),
            _max_results: Default::default(),
            _id: Default::default(),
            _channel_id: Default::default(),
            _all_threads_related_to_channel_id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates an existing resource.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn update(&self, request: CommentThread) -> CommentThreadUpdateCall<'a, C, A> {
        let parts = request.to_parts();
        CommentThreadUpdateCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: CommentThread) -> CommentThreadInsertCall<'a, C, A> {
        let parts = request.to_parts();
        CommentThreadInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *comment* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `delete(...)`, `insert(...)`, `list(...)`, `mark_as_spam(...)`, `set_moderation_status(...)` and `update(...)`
/// // to build up your call.
/// let rb = hub.comments();
/// # }
/// ```
pub struct CommentMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for CommentMethods<'a, C, A> {}

impl<'a, C, A> CommentMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: Comment) -> CommentInsertCall<'a, C, A> {
        let parts = request.to_parts();
        CommentInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes a resource.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn delete(&self, id: &str) -> CommentDeleteCall<'a, C, A> {
        CommentDeleteCall {
            hub: self.hub,
            _id: id.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>comment</code> resource
    ///            properties that the API response will include.
    pub fn list(&self, part: &Vec<String>) -> CommentListCall<'a, C, A> {
        CommentListCall {
            hub: self.hub,
            _part: part.clone(),
            _text_format: Default::default(),
            _parent_id: Default::default(),
            _page_token: Default::default(),
            _max_results: Default::default(),
            _id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Sets the moderation status of one or more comments.
    /// 
    /// # Arguments
    ///
    /// * `id` - Modifies the moderation status of the comments with the given IDs
    /// * `moderationStatus` - Specifies the requested moderation status. Note, comments can be in
    ///                        statuses, which are not available through this call. For example, this
    ///                        call does not allow to mark a comment as 'likely spam'.
    ///                        Valid values: MODERATION_STATUS_PUBLISHED,
    ///                        MODERATION_STATUS_HELD_FOR_REVIEW, MODERATION_STATUS_REJECTED.
    pub fn set_moderation_status(&self, id: &Vec<String>, moderation_status: &str) -> CommentSetModerationStatuCall<'a, C, A> {
        CommentSetModerationStatuCall {
            hub: self.hub,
            _id: id.clone(),
            _moderation_status: moderation_status.to_string(),
            _ban_author: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates an existing resource.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn update(&self, request: Comment) -> CommentUpdateCall<'a, C, A> {
        let parts = request.to_parts();
        CommentUpdateCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Expresses the caller's opinion that one or more comments should be flagged
    /// as spam.
    /// 
    /// # Arguments
    ///
    /// * `id` - Flags the comments with the given IDs as spam in the caller's opinion.
    pub fn mark_as_spam(&self, id: &Vec<String>) -> CommentMarkAsSpamCall<'a, C, A> {
        CommentMarkAsSpamCall {
            hub: self.hub,
            _id: id.clone(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *playlistItem* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `delete(...)`, `insert(...)`, `list(...)` and `update(...)`
/// // to build up your call.
/// let rb = hub.playlist_items();
/// # }
/// ```
pub struct PlaylistItemMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for PlaylistItemMethods<'a, C, A> {}

impl<'a, C, A> PlaylistItemMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: PlaylistItem) -> PlaylistItemInsertCall<'a, C, A> {
        let parts = request.to_parts();
        PlaylistItemInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes a resource.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn delete(&self, id: &str) -> PlaylistItemDeleteCall<'a, C, A> {
        PlaylistItemDeleteCall {
            hub: self.hub,
            _id: id.to_string(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>playlistItem</code> resource
    ///            properties that the API response will include.<br><br>If the parameter
    ///            identifies a property that contains child properties, the child properties
    ///            will be included in the response. For example, in a
    ///            <code>playlistItem</code> resource, the <code>snippet</code> property
    ///            contains numerous fields, including the <code>title</code>,
    ///            <code>description</code>, <code>position</code>, and
    ///            <code>resourceId</code> properties. As such, if you set
    ///            <code><strong>part=snippet</strong></code>, the API response will contain
    ///            all of those properties.
    pub fn list(&self, part: &Vec<String>) -> PlaylistItemListCall<'a, C, A> {
        PlaylistItemListCall {
            hub: self.hub,
            _part: part.clone(),
            _video_id: Default::default(),
            _playlist_id: Default::default(),
            _page_token: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _max_results: Default::default(),
            _id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates an existing resource.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn update(&self, request: PlaylistItem) -> PlaylistItemUpdateCall<'a, C, A> {
        let parts = request.to_parts();
        PlaylistItemUpdateCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *liveChatMessage* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `delete(...)`, `insert(...)` and `list(...)`
/// // to build up your call.
/// let rb = hub.live_chat_messages();
/// # }
/// ```
pub struct LiveChatMessageMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for LiveChatMessageMethods<'a, C, A> {}

impl<'a, C, A> LiveChatMessageMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `liveChatId` - The id of the live chat for which comments should be returned.
    /// * `part` - The <code><strong>part</strong></code> parameter specifies the
    ///            <code>liveChatComment</code> resource parts that the API response will
    ///            include. Supported values are <code>id</code> and <code>snippet</code>.
    pub fn list(&self, live_chat_id: &str, part: &Vec<String>) -> LiveChatMessageListCall<'a, C, A> {
        LiveChatMessageListCall {
            hub: self.hub,
            _live_chat_id: live_chat_id.to_string(),
            _part: part.clone(),
            _profile_image_size: Default::default(),
            _page_token: Default::default(),
            _max_results: Default::default(),
            _hl: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes a chat message.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn delete(&self, id: &str) -> LiveChatMessageDeleteCall<'a, C, A> {
        LiveChatMessageDeleteCall {
            hub: self.hub,
            _id: id.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: LiveChatMessage) -> LiveChatMessageInsertCall<'a, C, A> {
        let parts = request.to_parts();
        LiveChatMessageInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *videoCategory* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `list(...)`
/// // to build up your call.
/// let rb = hub.video_categories();
/// # }
/// ```
pub struct VideoCategoryMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for VideoCategoryMethods<'a, C, A> {}

impl<'a, C, A> VideoCategoryMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies the
    ///            <code>videoCategory</code> resource properties that the API response will
    ///            include. Set the parameter value to <code>snippet</code>.
    pub fn list(&self, part: &Vec<String>) -> VideoCategoryListCall<'a, C, A> {
        VideoCategoryListCall {
            hub: self.hub,
            _part: part.clone(),
            _region_code: Default::default(),
            _id: Default::default(),
            _hl: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *i18nRegion* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `list(...)`
/// // to build up your call.
/// let rb = hub.i18n_regions();
/// # }
/// ```
pub struct I18nRegionMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for I18nRegionMethods<'a, C, A> {}

impl<'a, C, A> I18nRegionMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies the
    ///            <code>i18nRegion</code> resource properties that the API response will
    ///            include. Set the parameter value to <code>snippet</code>.
    pub fn list(&self, part: &Vec<String>) -> I18nRegionListCall<'a, C, A> {
        I18nRegionListCall {
            hub: self.hub,
            _part: part.clone(),
            _hl: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *subscription* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `delete(...)`, `insert(...)` and `list(...)`
/// // to build up your call.
/// let rb = hub.subscriptions();
/// # }
/// ```
pub struct SubscriptionMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for SubscriptionMethods<'a, C, A> {}

impl<'a, C, A> SubscriptionMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: Subscription) -> SubscriptionInsertCall<'a, C, A> {
        let parts = request.to_parts();
        SubscriptionInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>subscription</code> resource
    ///            properties that the API response will include.<br><br>If the parameter
    ///            identifies a property that contains child properties, the child properties
    ///            will be included in the response. For example, in a
    ///            <code>subscription</code> resource, the <code>snippet</code> property
    ///            contains other properties, such as a display title for the subscription. If
    ///            you set <code><strong>part=snippet</strong></code>, the API response will
    ///            also contain all of those nested properties.
    pub fn list(&self, part: &Vec<String>) -> SubscriptionListCall<'a, C, A> {
        SubscriptionListCall {
            hub: self.hub,
            _part: part.clone(),
            _page_token: Default::default(),
            _order: Default::default(),
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _my_subscribers: Default::default(),
            _my_recent_subscribers: Default::default(),
            _mine: Default::default(),
            _max_results: Default::default(),
            _id: Default::default(),
            _for_channel_id: Default::default(),
            _channel_id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes a resource.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn delete(&self, id: &str) -> SubscriptionDeleteCall<'a, C, A> {
        SubscriptionDeleteCall {
            hub: self.hub,
            _id: id.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *liveChatBan* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `delete(...)` and `insert(...)`
/// // to build up your call.
/// let rb = hub.live_chat_bans();
/// # }
/// ```
pub struct LiveChatBanMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for LiveChatBanMethods<'a, C, A> {}

impl<'a, C, A> LiveChatBanMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes a chat ban.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn delete(&self, id: &str) -> LiveChatBanDeleteCall<'a, C, A> {
        LiveChatBanDeleteCall {
            hub: self.hub,
            _id: id.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: LiveChatBan) -> LiveChatBanInsertCall<'a, C, A> {
        let parts = request.to_parts();
        LiveChatBanInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *sponsor* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `list(...)`
/// // to build up your call.
/// let rb = hub.sponsors();
/// # }
/// ```
pub struct SponsorMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for SponsorMethods<'a, C, A> {}

impl<'a, C, A> SponsorMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of sponsors that match the request criteria for a
    /// channel.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies the
    ///            <code>sponsor</code> resource parts that the API response will include.
    ///            Supported values are <code>id</code> and <code>snippet</code>.
    pub fn list(&self, part: &Vec<String>) -> SponsorListCall<'a, C, A> {
        SponsorListCall {
            hub: self.hub,
            _part: part.clone(),
            _page_token: Default::default(),
            _max_results: Default::default(),
            _filter: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *videoAbuseReportReason* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `list(...)`
/// // to build up your call.
/// let rb = hub.video_abuse_report_reasons();
/// # }
/// ```
pub struct VideoAbuseReportReasonMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for VideoAbuseReportReasonMethods<'a, C, A> {}

impl<'a, C, A> VideoAbuseReportReasonMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies the
    ///            <code>videoCategory</code> resource parts that the API response will
    ///            include. Supported values are <code>id</code> and <code>snippet</code>.
    pub fn list(&self, part: &Vec<String>) -> VideoAbuseReportReasonListCall<'a, C, A> {
        VideoAbuseReportReasonListCall {
            hub: self.hub,
            _part: part.clone(),
            _hl: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *thirdPartyLink* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `delete(...)`, `insert(...)`, `list(...)` and `update(...)`
/// // to build up your call.
/// let rb = hub.third_party_links();
/// # }
/// ```
pub struct ThirdPartyLinkMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for ThirdPartyLinkMethods<'a, C, A> {}

impl<'a, C, A> ThirdPartyLinkMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes a resource.
    /// 
    /// # Arguments
    ///
    /// * `linkingToken` - Delete the partner links with the given linking token.
    /// * `type` - Type of the link to be deleted.
    pub fn delete(&self, linking_token: &str, type_: &str) -> ThirdPartyLinkDeleteCall<'a, C, A> {
        ThirdPartyLinkDeleteCall {
            hub: self.hub,
            _linking_token: linking_token.to_string(),
            _type_: type_.to_string(),
            _part: Default::default(),
            _delegate: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates an existing resource.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn update(&self, request: ThirdPartyLink) -> ThirdPartyLinkUpdateCall<'a, C, A> {
        let parts = request.to_parts();
        ThirdPartyLinkUpdateCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _delegate: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: ThirdPartyLink) -> ThirdPartyLinkInsertCall<'a, C, A> {
        let parts = request.to_parts();
        ThirdPartyLinkInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _delegate: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies the
    ///            <code>thirdPartyLink</code> resource parts that the API response will
    ///            include. Supported values are <code>linkingToken</code>,
    ///            <code>status</code>, and <code>snippet</code>.
    pub fn list(&self, part: &Vec<String>) -> ThirdPartyLinkListCall<'a, C, A> {
        ThirdPartyLinkListCall {
            hub: self.hub,
            _part: part.clone(),
            _type_: Default::default(),
            _linking_token: Default::default(),
            _delegate: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *member* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `list(...)`
/// // to build up your call.
/// let rb = hub.members();
/// # }
/// ```
pub struct MemberMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for MemberMethods<'a, C, A> {}

impl<'a, C, A> MemberMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of members that match the request criteria for a channel.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies the
    ///            <code>member</code> resource parts that the API response will include. Set
    ///            the parameter value to <code>snippet</code>.
    pub fn list(&self, part: &Vec<String>) -> MemberListCall<'a, C, A> {
        MemberListCall {
            hub: self.hub,
            _part: part.clone(),
            _page_token: Default::default(),
            _mode: Default::default(),
            _max_results: Default::default(),
            _has_access_to_level: Default::default(),
            _filter_by_member_channel_id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *liveBroadcast* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `bind(...)`, `control(...)`, `delete(...)`, `insert(...)`, `list(...)`, `transition(...)` and `update(...)`
/// // to build up your call.
/// let rb = hub.live_broadcasts();
/// # }
/// ```
pub struct LiveBroadcastMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for LiveBroadcastMethods<'a, C, A> {}

impl<'a, C, A> LiveBroadcastMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Slate and recording control of the live broadcast.
    /// Support actions: slate on/off, recording start/stop/pause/resume.
    /// Design doc: goto/yt-api-liveBroadcast-control
    /// 
    /// # Arguments
    ///
    /// * `id` - Broadcast to operate.
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>liveBroadcast</code> resource
    ///            properties that the API response will include. The <code>part</code> names
    ///            that you can include in the parameter value are <code>id</code>,
    ///            <code>snippet</code>, <code>contentDetails</code>, and <code>status</code>.
    pub fn control(&self, id: &str, part: &Vec<String>) -> LiveBroadcastControlCall<'a, C, A> {
        LiveBroadcastControlCall {
            hub: self.hub,
            _id: id.to_string(),
            _part: part.clone(),
            _walltime: Default::default(),
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _offset_time_ms: Default::default(),
            _display_slate: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates an existing broadcast for the authenticated user.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn update(&self, request: LiveBroadcast) -> LiveBroadcastUpdateCall<'a, C, A> {
        let parts = request.to_parts();
        LiveBroadcastUpdateCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new stream for the authenticated user.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: LiveBroadcast) -> LiveBroadcastInsertCall<'a, C, A> {
        let parts = request.to_parts();
        LiveBroadcastInsertCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieve the list of broadcasts associated with the given channel.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>liveBroadcast</code> resource
    ///            properties that the API response will include. The <code>part</code> names
    ///            that you can include in the parameter value are <code>id</code>,
    ///            <code>snippet</code>, <code>contentDetails</code>, and <code>status</code>.
    pub fn list(&self, part: &Vec<String>) -> LiveBroadcastListCall<'a, C, A> {
        LiveBroadcastListCall {
            hub: self.hub,
            _part: part.clone(),
            _page_token: Default::default(),
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _mine: Default::default(),
            _max_results: Default::default(),
            _id: Default::default(),
            _broadcast_type: Default::default(),
            _broadcast_status: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Delete a given broadcast.
    /// 
    /// # Arguments
    ///
    /// * `id` - No description provided.
    pub fn delete(&self, id: &str) -> LiveBroadcastDeleteCall<'a, C, A> {
        LiveBroadcastDeleteCall {
            hub: self.hub,
            _id: id.to_string(),
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Transition a broadcast to a given status.
    /// 
    /// # Arguments
    ///
    /// * `id` - Broadcast to transition.
    /// * `broadcastStatus` - The status to which the broadcast is going to transition.
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>liveBroadcast</code> resource
    ///            properties that the API response will include. The <code>part</code> names
    ///            that you can include in the parameter value are <code>id</code>,
    ///            <code>snippet</code>, <code>contentDetails</code>, and <code>status</code>.
    pub fn transition(&self, id: &str, broadcast_status: &str, part: &Vec<String>) -> LiveBroadcastTransitionCall<'a, C, A> {
        LiveBroadcastTransitionCall {
            hub: self.hub,
            _id: id.to_string(),
            _broadcast_status: broadcast_status.to_string(),
            _part: part.clone(),
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Bind a broadcast to a stream.
    /// 
    /// # Arguments
    ///
    /// * `id` - Broadcast to bind to the stream
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>liveBroadcast</code> resource
    ///            properties that the API response will include. The <code>part</code> names
    ///            that you can include in the parameter value are <code>id</code>,
    ///            <code>snippet</code>, <code>contentDetails</code>, and <code>status</code>.
    pub fn bind(&self, id: &str, part: &Vec<String>) -> LiveBroadcastBindCall<'a, C, A> {
        LiveBroadcastBindCall {
            hub: self.hub,
            _id: id.to_string(),
            _part: part.clone(),
            _stream_id: Default::default(),
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *channelBanner* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `insert(...)`
/// // to build up your call.
/// let rb = hub.channel_banners();
/// # }
/// ```
pub struct ChannelBannerMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for ChannelBannerMethods<'a, C, A> {}

impl<'a, C, A> ChannelBannerMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Inserts a new resource into this collection.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn insert(&self, request: ChannelBannerResource) -> ChannelBannerInsertCall<'a, C, A> {
        ChannelBannerInsertCall {
            hub: self.hub,
            _request: request,
            _on_behalf_of_content_owner_channel: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _channel_id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *search* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `list(...)`
/// // to build up your call.
/// let rb = hub.search();
/// # }
/// ```
pub struct SearchMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for SearchMethods<'a, C, A> {}

impl<'a, C, A> SearchMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of search resources
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies a
    ///            comma-separated list of one or more <code>search</code> resource properties
    ///            that the API response will include. Set the parameter value to
    ///            <code>snippet</code>.
    pub fn list(&self, part: &Vec<String>) -> SearchListCall<'a, C, A> {
        SearchListCall {
            hub: self.hub,
            _part: part.clone(),
            _video_type: Default::default(),
            _video_syndicated: Default::default(),
            _video_license: Default::default(),
            _video_embeddable: Default::default(),
            _video_duration: Default::default(),
            _video_dimension: Default::default(),
            _video_definition: Default::default(),
            _video_category_id: Default::default(),
            _video_caption: Default::default(),
            _type_: Default::default(),
            _topic_id: Default::default(),
            _safe_search: Default::default(),
            _relevance_language: Default::default(),
            _related_to_video_id: Default::default(),
            _region_code: Default::default(),
            _q: Default::default(),
            _published_before: Default::default(),
            _published_after: Default::default(),
            _page_token: Default::default(),
            _order: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _max_results: Default::default(),
            _location_radius: Default::default(),
            _location: Default::default(),
            _for_mine: Default::default(),
            _for_developer: Default::default(),
            _for_content_owner: Default::default(),
            _event_type: Default::default(),
            _channel_type: Default::default(),
            _channel_id: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *superChatEvent* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `list(...)`
/// // to build up your call.
/// let rb = hub.super_chat_events();
/// # }
/// ```
pub struct SuperChatEventMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for SuperChatEventMethods<'a, C, A> {}

impl<'a, C, A> SuperChatEventMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a list of resources, possibly filtered.
    /// 
    /// # Arguments
    ///
    /// * `part` - The <code><strong>part</strong></code> parameter specifies the
    ///            <code>superChatEvent</code> resource parts that the API response will
    ///            include. Supported values are <code>id</code> and <code>snippet</code>.
    pub fn list(&self, part: &Vec<String>) -> SuperChatEventListCall<'a, C, A> {
        SuperChatEventListCall {
            hub: self.hub,
            _part: part.clone(),
            _page_token: Default::default(),
            _max_results: Default::default(),
            _hl: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *thumbnail* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `set(...)`
/// // to build up your call.
/// let rb = hub.thumbnails();
/// # }
/// ```
pub struct ThumbnailMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for ThumbnailMethods<'a, C, A> {}

impl<'a, C, A> ThumbnailMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// As this is not an insert in a strict sense (it supports uploading/setting
    /// of a thumbnail for multiple videos, which doesn't result in creation of a
    /// single resource), I use a custom verb here.
    /// 
    /// # Arguments
    ///
    /// * `videoId` - Returns the Thumbnail with the given video IDs for Stubby or Apiary.
    pub fn set(&self, video_id: &str) -> ThumbnailSetCall<'a, C, A> {
        ThumbnailSetCall {
            hub: self.hub,
            _video_id: video_id.to_string(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *youtube* resources.
/// It is not used directly, but through the `YouTube` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_youtube3 as youtube3;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use youtube3::YouTube;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `v3_infocards(...)`, `v3_infocards_list(...)` and `v3_tests_create(...)`
/// // to build up your call.
/// let rb = hub.youtube();
/// # }
/// ```
pub struct YoutubeMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
}

impl<'a, C, A> MethodsBuilder for YoutubeMethods<'a, C, A> {}

impl<'a, C, A> YoutubeMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates infocards for a given video.
    /// Note:
    /// * If the card id is not provided, a new card will be created.
    /// * If the card id is provided, that card will be updated.
    /// * Existing cards will be discarded if they're not included in the request.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn v3_infocards(&self, request: InfoCards) -> YoutubeV3InfocardCall<'a, C, A> {
        let parts = request.to_parts();
        YoutubeV3InfocardCall {
            hub: self.hub,
            _request: request,
            _part: parts,
            _video_id: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// POST method.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn v3_tests_create(&self, request: TestItem) -> YoutubeV3TestCreateCall<'a, C, A> {
        YoutubeV3TestCreateCall {
            hub: self.hub,
            _request: request,
            _part: Default::default(),
            _delegate: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves all infocards for a given video.
    /// 
    /// # Arguments
    ///
    /// * `part` - The properties to return.
    pub fn v3_infocards_list(&self, part: &Vec<String>) -> YoutubeV3InfocardListCall<'a, C, A> {
        YoutubeV3InfocardListCall {
            hub: self.hub,
            _part: part.clone(),
            _video_id: Default::default(),
            _on_behalf_of_content_owner: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}





// ###################
// CallBuilders   ###
// #################

/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *channelSection* resource.
/// It is not used directly, but through a `ChannelSectionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.channel_sections().list("part")
///              .on_behalf_of_content_owner("no")
///              .mine(true)
///              .add_id("eirmod")
///              .hl("dolore")
///              .channel_id("invidunt")
///              .doit();
/// # }
/// ```
pub struct ChannelSectionListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _on_behalf_of_content_owner: Option<String>,
    _mine: Option<bool>,
    _id: Vec<String>,
    _hl: Option<String>,
    _channel_id: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ChannelSectionListCall<'a, C, A> {}

impl<'a, C, A> ChannelSectionListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, ChannelSectionListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.channelSections.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(8 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._mine {
            params.push(("mine", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        if let Some(value) = self._hl {
            params.push(("hl", value.to_string()));
        }
        if let Some(value) = self._channel_id {
            params.push(("channelId", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwner", "mine", "id", "hl", "channelId"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/channelSections";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>channelSection</code> resource
    /// properties that the API response will include. The <code>part</code> names
    /// that you can include in the parameter value are <code>id</code>,
    /// <code>snippet</code>, and <code>contentDetails</code>.<br><br>If the
    /// parameter identifies a property that contains child properties, the child
    /// properties will be included in the response. For example, in a
    /// <code>channelSection</code> resource, the <code>snippet</code> property
    /// contains other properties, such as a display title for the channelSection.
    /// If you set <code><strong>part=snippet</strong></code>, the API response
    /// will also contain all of those nested properties.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> ChannelSectionListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> ChannelSectionListCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// Return the ChannelSections owned by the authenticated user.
    ///
    /// Sets the *mine* query property to the given value.
    pub fn mine(mut self, new_value: bool) -> ChannelSectionListCall<'a, C, A> {
        self._mine = Some(new_value);
        self
    }
    /// Return the ChannelSections with the given IDs for Stubby or Apiary.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> ChannelSectionListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// Return content in specified language
    ///
    /// Sets the *hl* query property to the given value.
    pub fn hl(mut self, new_value: &str) -> ChannelSectionListCall<'a, C, A> {
        self._hl = Some(new_value.to_string());
        self
    }
    /// Return the ChannelSections owned by the specified channel ID.
    ///
    /// Sets the *channel id* query property to the given value.
    pub fn channel_id(mut self, new_value: &str) -> ChannelSectionListCall<'a, C, A> {
        self._channel_id = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ChannelSectionListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ChannelSectionListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ChannelSectionListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *channelSection* resource.
/// It is not used directly, but through a `ChannelSectionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::ChannelSection;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = ChannelSection::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.channel_sections().insert(req)
///              .on_behalf_of_content_owner_channel("aliquyam")
///              .on_behalf_of_content_owner("accusam")
///              .doit();
/// # }
/// ```
pub struct ChannelSectionInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: ChannelSection,
    _part: Vec<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ChannelSectionInsertCall<'a, C, A> {}

impl<'a, C, A> ChannelSectionInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, ChannelSection)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.channelSections.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/channelSections";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: ChannelSection) -> ChannelSectionInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will
    /// include.<br/><br/>The <code>part</code> names that you can include in the
    /// parameter value are <code>snippet</code> and <code>contentDetails</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> ChannelSectionInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> ChannelSectionInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> ChannelSectionInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ChannelSectionInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ChannelSectionInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ChannelSectionInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes a resource.
///
/// A builder for the *delete* method supported by a *channelSection* resource.
/// It is not used directly, but through a `ChannelSectionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.channel_sections().delete("id")
///              .on_behalf_of_content_owner("sea")
///              .doit();
/// # }
/// ```
pub struct ChannelSectionDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ChannelSectionDeleteCall<'a, C, A> {}

impl<'a, C, A> ChannelSectionDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.channelSections.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["id", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/channelSections";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> ChannelSectionDeleteCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> ChannelSectionDeleteCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ChannelSectionDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ChannelSectionDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ChannelSectionDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates an existing resource.
///
/// A builder for the *update* method supported by a *channelSection* resource.
/// It is not used directly, but through a `ChannelSectionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::ChannelSection;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = ChannelSection::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.channel_sections().update(req)
///              .on_behalf_of_content_owner("et")
///              .doit();
/// # }
/// ```
pub struct ChannelSectionUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: ChannelSection,
    _part: Vec<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ChannelSectionUpdateCall<'a, C, A> {}

impl<'a, C, A> ChannelSectionUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, ChannelSection)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.channelSections.update",
                               http_method: hyper::method::Method::Put });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/channelSections";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Put, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: ChannelSection) -> ChannelSectionUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will
    /// include.<br/><br/>The <code>part</code> names that you can include in the
    /// parameter value are <code>snippet</code> and <code>contentDetails</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> ChannelSectionUpdateCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> ChannelSectionUpdateCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ChannelSectionUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ChannelSectionUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ChannelSectionUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *playlist* resource.
/// It is not used directly, but through a `PlaylistMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::Playlist;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = Playlist::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.playlists().insert(req)
///              .on_behalf_of_content_owner_channel("duo")
///              .on_behalf_of_content_owner("et")
///              .doit();
/// # }
/// ```
pub struct PlaylistInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: Playlist,
    _part: Vec<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for PlaylistInsertCall<'a, C, A> {}

impl<'a, C, A> PlaylistInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, Playlist)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.playlists.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/playlists";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: Playlist) -> PlaylistInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will include.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> PlaylistInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> PlaylistInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> PlaylistInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> PlaylistInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> PlaylistInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> PlaylistInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *playlist* resource.
/// It is not used directly, but through a `PlaylistMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.playlists().list("part")
///              .page_token("sanctus")
///              .on_behalf_of_content_owner_channel("et")
///              .on_behalf_of_content_owner("amet")
///              .mine(true)
///              .max_results(56)
///              .add_id("ut")
///              .hl("ea")
///              .channel_id("sed")
///              .doit();
/// # }
/// ```
pub struct PlaylistListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _page_token: Option<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _mine: Option<bool>,
    _max_results: Option<u32>,
    _id: Vec<String>,
    _hl: Option<String>,
    _channel_id: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for PlaylistListCall<'a, C, A> {}

impl<'a, C, A> PlaylistListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, PlaylistListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.playlists.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(11 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._mine {
            params.push(("mine", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        if let Some(value) = self._hl {
            params.push(("hl", value.to_string()));
        }
        if let Some(value) = self._channel_id {
            params.push(("channelId", value.to_string()));
        }
        for &field in ["alt", "part", "pageToken", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner", "mine", "maxResults", "id", "hl", "channelId"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/playlists";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>playlist</code> resource
    /// properties that the API response will include.<br><br>If the parameter
    /// identifies a property that contains child properties, the child properties
    /// will be included in the response. For example, in a <code>playlist</code>
    /// resource, the <code>snippet</code> property contains properties like
    /// <code>author</code>, <code>title</code>, <code>description</code>,
    /// <code>tags</code>, and <code>timeCreated</code>. As such, if you set
    /// <code><strong>part=snippet</strong></code>, the API response will contain
    /// all of those properties.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> PlaylistListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> PlaylistListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> PlaylistListCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> PlaylistListCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// Return the playlists owned by the authenticated user.
    ///
    /// Sets the *mine* query property to the given value.
    pub fn mine(mut self, new_value: bool) -> PlaylistListCall<'a, C, A> {
        self._mine = Some(new_value);
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> PlaylistListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// Return the playlists with the given IDs for Stubby or Apiary.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> PlaylistListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// Returen content in specified language
    ///
    /// Sets the *hl* query property to the given value.
    pub fn hl(mut self, new_value: &str) -> PlaylistListCall<'a, C, A> {
        self._hl = Some(new_value.to_string());
        self
    }
    /// Return the playlists owned by the specified channel ID.
    ///
    /// Sets the *channel id* query property to the given value.
    pub fn channel_id(mut self, new_value: &str) -> PlaylistListCall<'a, C, A> {
        self._channel_id = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> PlaylistListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> PlaylistListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> PlaylistListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes a resource.
///
/// A builder for the *delete* method supported by a *playlist* resource.
/// It is not used directly, but through a `PlaylistMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.playlists().delete("id")
///              .on_behalf_of_content_owner("dolor")
///              .doit();
/// # }
/// ```
pub struct PlaylistDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for PlaylistDeleteCall<'a, C, A> {}

impl<'a, C, A> PlaylistDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.playlists.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["id", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/playlists";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> PlaylistDeleteCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> PlaylistDeleteCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> PlaylistDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> PlaylistDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> PlaylistDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates an existing resource.
///
/// A builder for the *update* method supported by a *playlist* resource.
/// It is not used directly, but through a `PlaylistMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::Playlist;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = Playlist::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.playlists().update(req)
///              .on_behalf_of_content_owner("dolor")
///              .doit();
/// # }
/// ```
pub struct PlaylistUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: Playlist,
    _part: Vec<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for PlaylistUpdateCall<'a, C, A> {}

impl<'a, C, A> PlaylistUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, Playlist)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.playlists.update",
                               http_method: hyper::method::Method::Put });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/playlists";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Put, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: Playlist) -> PlaylistUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will
    /// include.<br/><br/>Note that this method will override the existing values
    /// for mutable properties that are contained in any parts that the request
    /// body specifies. For example, a
    /// playlist's description is contained in the <code>snippet</code> part, which
    /// must be included in the request body. If the request does not specify a
    /// value for the <code>snippet.description</code> property, the playlist's
    /// existing description will be deleted.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> PlaylistUpdateCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> PlaylistUpdateCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> PlaylistUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> PlaylistUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> PlaylistUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Report abuse for a video.
///
/// A builder for the *reportAbuse* method supported by a *video* resource.
/// It is not used directly, but through a `VideoMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::VideoAbuseReport;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = VideoAbuseReport::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.videos().report_abuse(req)
///              .on_behalf_of_content_owner("et")
///              .doit();
/// # }
/// ```
pub struct VideoReportAbuseCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: VideoAbuseReport,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for VideoReportAbuseCall<'a, C, A> {}

impl<'a, C, A> VideoReportAbuseCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.videos.reportAbuse",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/videos/reportAbuse";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: VideoAbuseReport) -> VideoReportAbuseCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> VideoReportAbuseCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> VideoReportAbuseCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> VideoReportAbuseCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> VideoReportAbuseCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *video* resource.
/// It is not used directly, but through a `VideoMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.videos().list("part")
///              .video_category_id("amet.")
///              .region_code("voluptua.")
///              .page_token("Lorem")
///              .on_behalf_of_content_owner("gubergren")
///              .my_rating("justo")
///              .max_width(-52)
///              .max_results(75)
///              .max_height(-28)
///              .locale("rebum.")
///              .add_id("consetetur")
///              .hl("sadipscing")
///              .chart("vero")
///              .doit();
/// # }
/// ```
pub struct VideoListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _video_category_id: Option<String>,
    _region_code: Option<String>,
    _page_token: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _my_rating: Option<String>,
    _max_width: Option<i32>,
    _max_results: Option<u32>,
    _max_height: Option<i32>,
    _locale: Option<String>,
    _id: Vec<String>,
    _hl: Option<String>,
    _chart: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for VideoListCall<'a, C, A> {}

impl<'a, C, A> VideoListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, VideoListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.videos.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(15 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._video_category_id {
            params.push(("videoCategoryId", value.to_string()));
        }
        if let Some(value) = self._region_code {
            params.push(("regionCode", value.to_string()));
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._my_rating {
            params.push(("myRating", value.to_string()));
        }
        if let Some(value) = self._max_width {
            params.push(("maxWidth", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if let Some(value) = self._max_height {
            params.push(("maxHeight", value.to_string()));
        }
        if let Some(value) = self._locale {
            params.push(("locale", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        if let Some(value) = self._hl {
            params.push(("hl", value.to_string()));
        }
        if let Some(value) = self._chart {
            params.push(("chart", value.to_string()));
        }
        for &field in ["alt", "part", "videoCategoryId", "regionCode", "pageToken", "onBehalfOfContentOwner", "myRating", "maxWidth", "maxResults", "maxHeight", "locale", "id", "hl", "chart"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/videos";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>video</code> resource properties
    /// that the API response will include.<br><br>If the parameter identifies a
    /// property that contains child properties, the child properties will be
    /// included in the response. For example, in a <code>video</code> resource,
    /// the <code>snippet</code> property contains the <code>channelId</code>,
    /// <code>title</code>, <code>description</code>, <code>tags</code>, and
    /// <code>categoryId</code> properties. As such, if you set
    /// <code><strong>part=snippet</strong></code>, the API response will contain
    /// all of those properties.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> VideoListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Use chart that is specific to the specified video category
    ///
    /// Sets the *video category id* query property to the given value.
    pub fn video_category_id(mut self, new_value: &str) -> VideoListCall<'a, C, A> {
        self._video_category_id = Some(new_value.to_string());
        self
    }
    /// Use a chart that is specific to the specified region
    ///
    /// Sets the *region code* query property to the given value.
    pub fn region_code(mut self, new_value: &str) -> VideoListCall<'a, C, A> {
        self._region_code = Some(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.<br><br><strong>Note:</strong>
    /// This parameter is supported for use in conjunction with the <code><a
    /// href="#myRating">myRating</a></code> and <code><a
    /// href="#chart">chart</a></code> parameters, but it is not supported for use
    /// in conjunction with the <code><a href="#id">id</a></code> parameter.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> VideoListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> VideoListCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// Return videos liked/disliked by the authenticated user.
    /// Does not support RateType.RATED_TYPE_NONE.
    ///
    /// Sets the *my rating* query property to the given value.
    pub fn my_rating(mut self, new_value: &str) -> VideoListCall<'a, C, A> {
        self._my_rating = Some(new_value.to_string());
        self
    }
    /// Return the player with maximum height specified in
    ///
    /// Sets the *max width* query property to the given value.
    pub fn max_width(mut self, new_value: i32) -> VideoListCall<'a, C, A> {
        self._max_width = Some(new_value);
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result
    /// set.<br><br><strong>Note:</strong> This parameter is supported for use in
    /// conjunction with the <code><a href="#myRating">myRating</a></code> and
    /// <code><a href="#chart">chart</a></code> parameters, but it is not supported
    /// for use in conjunction with the <code><a href="#id">id</a></code>
    /// parameter.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> VideoListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    ///
    /// Sets the *max height* query property to the given value.
    pub fn max_height(mut self, new_value: i32) -> VideoListCall<'a, C, A> {
        self._max_height = Some(new_value);
        self
    }
    ///
    /// Sets the *locale* query property to the given value.
    pub fn locale(mut self, new_value: &str) -> VideoListCall<'a, C, A> {
        self._locale = Some(new_value.to_string());
        self
    }
    /// Return videos with the given ids.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> VideoListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// Stands for "host language". Specifies the localization language of the
    /// metadata to be filled into snippet.localized. The field is filled with the
    /// default metadata if there is no localization in the specified language.
    /// The parameter value must be a language code included in the list returned
    /// by the i18nLanguages.list method (e.g. en_US, es_MX).
    ///
    /// Sets the *hl* query property to the given value.
    pub fn hl(mut self, new_value: &str) -> VideoListCall<'a, C, A> {
        self._hl = Some(new_value.to_string());
        self
    }
    /// Return the videos that are in the specified chart.
    ///
    /// Sets the *chart* query property to the given value.
    pub fn chart(mut self, new_value: &str) -> VideoListCall<'a, C, A> {
        self._chart = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> VideoListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> VideoListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> VideoListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Adds a like or dislike rating to a video or removes a rating from a video.
///
/// A builder for the *rate* method supported by a *video* resource.
/// It is not used directly, but through a `VideoMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.videos().rate("id", "rating")
///              .doit();
/// # }
/// ```
pub struct VideoRateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _rating: String,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for VideoRateCall<'a, C, A> {}

impl<'a, C, A> VideoRateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.videos.rate",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        params.push(("rating", self._rating.to_string()));
        for &field in ["id", "rating"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/videos/rate";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> VideoRateCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    ///
    /// Sets the *rating* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn rating(mut self, new_value: &str) -> VideoRateCall<'a, C, A> {
        self._rating = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> VideoRateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> VideoRateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> VideoRateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the ratings that the authorized user gave to a list of specified
/// videos.
///
/// A builder for the *getRating* method supported by a *video* resource.
/// It is not used directly, but through a `VideoMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.videos().get_rating("id")
///              .on_behalf_of_content_owner("dolore")
///              .doit();
/// # }
/// ```
pub struct VideoGetRatingCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: Vec<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for VideoGetRatingCall<'a, C, A> {}

impl<'a, C, A> VideoGetRatingCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, VideoRatingListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.videos.getRating",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "id", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/videos/getRating";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_id(mut self, new_value: &str) -> VideoGetRatingCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> VideoGetRatingCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> VideoGetRatingCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> VideoGetRatingCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> VideoGetRatingCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes a resource.
///
/// A builder for the *delete* method supported by a *video* resource.
/// It is not used directly, but through a `VideoMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.videos().delete("id")
///              .on_behalf_of_content_owner("aliquyam")
///              .doit();
/// # }
/// ```
pub struct VideoDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for VideoDeleteCall<'a, C, A> {}

impl<'a, C, A> VideoDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.videos.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["id", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/videos";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> VideoDeleteCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The actual
    /// CMS account that the user authenticates with must be linked to the
    /// specified YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> VideoDeleteCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> VideoDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> VideoDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> VideoDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates an existing resource.
///
/// A builder for the *update* method supported by a *video* resource.
/// It is not used directly, but through a `VideoMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::Video;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = Video::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.videos().update(req)
///              .on_behalf_of_content_owner("Lorem")
///              .doit();
/// # }
/// ```
pub struct VideoUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: Video,
    _part: Vec<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for VideoUpdateCall<'a, C, A> {}

impl<'a, C, A> VideoUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, Video)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.videos.update",
                               http_method: hyper::method::Method::Put });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/videos";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Put, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: Video) -> VideoUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will
    /// include.<br/><br/>Note that this method will override the existing values
    /// for all of the mutable properties that are contained in any parts that the
    /// parameter value specifies. For example, a
    /// video's privacy setting is contained in the <code>status</code> part. As
    /// such, if your request is updating a private video, and the request's
    /// <code>part</code> parameter value includes the <code>status</code> part,
    /// the
    /// video's privacy setting will be updated to whatever value the request body
    /// specifies. If the request body does not specify a value, the existing
    /// privacy setting will be removed and the video will revert to the default
    /// privacy setting.<br/><br/>In addition, not all parts contain properties
    /// that can be set when inserting or updating a video. For example, the
    /// <code>statistics</code> object encapsulates statistics that YouTube
    /// calculates for a video and does not contain values that you can set or
    /// modify. If the parameter value specifies a <code>part</code> that does not
    /// contain mutable values, that <code>part</code> will still be included in
    /// the API response.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> VideoUpdateCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The actual
    /// CMS account that the user authenticates with must be linked to the
    /// specified YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> VideoUpdateCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> VideoUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> VideoUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> VideoUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *video* resource.
/// It is not used directly, but through a `VideoMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::Video;
/// use std::fs;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = Video::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `upload(...)`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.videos().insert(req)
///              .stabilize(true)
///              .on_behalf_of_content_owner_channel("clita")
///              .on_behalf_of_content_owner("consetetur")
///              .notify_subscribers(false)
///              .auto_levels(true)
///              .upload(fs::File::open("file.ext").unwrap(), "application/octet-stream".parse().unwrap());
/// # }
/// ```
pub struct VideoInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: Video,
    _part: Vec<String>,
    _stabilize: Option<bool>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _notify_subscribers: Option<bool>,
    _auto_levels: Option<bool>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for VideoInsertCall<'a, C, A> {}

impl<'a, C, A> VideoInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    fn doit<RS>(mut self, mut reader: RS, reader_mime_type: mime::Mime, protocol: &'static str) -> Result<(hyper::client::Response, Video)>
		where RS: ReadSeek {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.videos.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(9 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._stabilize {
            params.push(("stabilize", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._notify_subscribers {
            params.push(("notifySubscribers", value.to_string()));
        }
        if let Some(value) = self._auto_levels {
            params.push(("autoLevels", value.to_string()));
        }
        for &field in ["alt", "part", "stabilize", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner", "notifySubscribers", "autoLevels"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let (mut url, upload_type) =
            if protocol == "simple" {
                (self.hub._root_url.clone() + "upload/youtube/v3/videos", "multipart")
            } else {
                unreachable!()
            };
        params.push(("uploadType", upload_type.to_string()));
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut mp_reader: MultiPartReader = Default::default();
                let (mut body_reader, content_type) = match protocol {
                    "simple" => {
                        mp_reader.reserve_exact(2);
                        let size = reader.seek(io::SeekFrom::End(0)).unwrap();
                    reader.seek(io::SeekFrom::Start(0)).unwrap();
                    if size > 137438953472 {
                    	return Err(Error::UploadSizeLimitExceeded(size, 137438953472))
                    }
                        mp_reader.add_part(&mut request_value_reader, request_size, json_mime_type.clone())
                                 .add_part(&mut reader, size, reader_mime_type.clone());
                        let mime_type = mp_reader.mime_type();
                        (&mut mp_reader as &mut dyn io::Read, ContentType(mime_type))
                    },
                    _ => (&mut request_value_reader as &mut dyn io::Read, ContentType(json_mime_type.clone())),
                };
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(content_type)
                    .body(&mut body_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }

    /// Upload media all at once.
    /// If the upload fails for whichever reason, all progress is lost.
    ///
    /// * *max size*: 137438953472
    /// * *multipart*: yes
    /// * *valid mime types*: 'video/*' and 'application/octet-stream'
    pub fn upload<RS>(self, stream: RS, mime_type: mime::Mime) -> Result<(hyper::client::Response, Video)>
                where RS: ReadSeek {
        self.doit(stream, mime_type, "simple")
    }

    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: Video) -> VideoInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will
    /// include.<br/><br/>Note that not all parts contain properties that can be
    /// set when inserting or updating a video. For example, the
    /// <code>statistics</code> object encapsulates statistics that YouTube
    /// calculates for a video and does not contain values that you can set or
    /// modify. If the parameter value specifies a <code>part</code> that does not
    /// contain mutable values, that <code>part</code> will still be included in
    /// the API response.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> VideoInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Should stabilize be applied to the upload.
    ///
    /// Sets the *stabilize* query property to the given value.
    pub fn stabilize(mut self, new_value: bool) -> VideoInsertCall<'a, C, A> {
        self._stabilize = Some(new_value);
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> VideoInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> VideoInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// Notify the channel subscribers about the new video. As default, the
    /// notification is enabled.
    ///
    /// Sets the *notify subscribers* query property to the given value.
    pub fn notify_subscribers(mut self, new_value: bool) -> VideoInsertCall<'a, C, A> {
        self._notify_subscribers = Some(new_value);
        self
    }
    /// Should auto-levels be applied to the upload.
    ///
    /// Sets the *auto levels* query property to the given value.
    pub fn auto_levels(mut self, new_value: bool) -> VideoInsertCall<'a, C, A> {
        self._auto_levels = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> VideoInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> VideoInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> VideoInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *activity* resource.
/// It is not used directly, but through a `ActivityMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.activities().list("part")
///              .region_code("sanctus")
///              .published_before("takimata")
///              .published_after("At")
///              .page_token("labore")
///              .mine(true)
///              .max_results(35)
///              .home(false)
///              .channel_id("rebum.")
///              .doit();
/// # }
/// ```
pub struct ActivityListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _region_code: Option<String>,
    _published_before: Option<String>,
    _published_after: Option<String>,
    _page_token: Option<String>,
    _mine: Option<bool>,
    _max_results: Option<u32>,
    _home: Option<bool>,
    _channel_id: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ActivityListCall<'a, C, A> {}

impl<'a, C, A> ActivityListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, ActivityListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.activities.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(11 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._region_code {
            params.push(("regionCode", value.to_string()));
        }
        if let Some(value) = self._published_before {
            params.push(("publishedBefore", value.to_string()));
        }
        if let Some(value) = self._published_after {
            params.push(("publishedAfter", value.to_string()));
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._mine {
            params.push(("mine", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if let Some(value) = self._home {
            params.push(("home", value.to_string()));
        }
        if let Some(value) = self._channel_id {
            params.push(("channelId", value.to_string()));
        }
        for &field in ["alt", "part", "regionCode", "publishedBefore", "publishedAfter", "pageToken", "mine", "maxResults", "home", "channelId"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/activities";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>activity</code> resource
    /// properties that the API response will include.<br><br>If the parameter
    /// identifies a property that contains child properties, the child properties
    /// will be included in the response. For example, in an <code>activity</code>
    /// resource, the <code>snippet</code> property contains other properties that
    /// identify the type of activity, a display title for the activity, and so
    /// forth. If you set <code><strong>part=snippet</strong></code>, the API
    /// response will also contain all of those nested properties.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> ActivityListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    ///
    /// Sets the *region code* query property to the given value.
    pub fn region_code(mut self, new_value: &str) -> ActivityListCall<'a, C, A> {
        self._region_code = Some(new_value.to_string());
        self
    }
    ///
    /// Sets the *published before* query property to the given value.
    pub fn published_before(mut self, new_value: &str) -> ActivityListCall<'a, C, A> {
        self._published_before = Some(new_value.to_string());
        self
    }
    ///
    /// Sets the *published after* query property to the given value.
    pub fn published_after(mut self, new_value: &str) -> ActivityListCall<'a, C, A> {
        self._published_after = Some(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ActivityListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    ///
    /// Sets the *mine* query property to the given value.
    pub fn mine(mut self, new_value: bool) -> ActivityListCall<'a, C, A> {
        self._mine = Some(new_value);
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> ActivityListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    ///
    /// Sets the *home* query property to the given value.
    pub fn home(mut self, new_value: bool) -> ActivityListCall<'a, C, A> {
        self._home = Some(new_value);
        self
    }
    ///
    /// Sets the *channel id* query property to the given value.
    pub fn channel_id(mut self, new_value: &str) -> ActivityListCall<'a, C, A> {
        self._channel_id = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ActivityListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ActivityListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ActivityListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates an existing stream for the authenticated user.
///
/// A builder for the *update* method supported by a *liveStream* resource.
/// It is not used directly, but through a `LiveStreamMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::LiveStream;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = LiveStream::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_streams().update(req)
///              .on_behalf_of_content_owner_channel("dolore")
///              .on_behalf_of_content_owner("nonumy")
///              .doit();
/// # }
/// ```
pub struct LiveStreamUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: LiveStream,
    _part: Vec<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveStreamUpdateCall<'a, C, A> {}

impl<'a, C, A> LiveStreamUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveStream)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveStreams.update",
                               http_method: hyper::method::Method::Put });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveStreams";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Put, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: LiveStream) -> LiveStreamUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will
    /// include.<br><br>The <code>part</code> properties that you can include in
    /// the parameter value are <code>id</code>, <code>snippet</code>,
    /// <code>cdn</code>, and <code>status</code>.<br><br>Note that this method
    /// will override the existing values for all of the mutable properties that
    /// are contained in any parts that the parameter value specifies. If the
    /// request body does not specify a value for a mutable property, the existing
    /// value for that property will be removed.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> LiveStreamUpdateCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> LiveStreamUpdateCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> LiveStreamUpdateCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveStreamUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveStreamUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveStreamUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes an existing stream for the authenticated user.
///
/// A builder for the *delete* method supported by a *liveStream* resource.
/// It is not used directly, but through a `LiveStreamMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_streams().delete("id")
///              .on_behalf_of_content_owner_channel("aliquyam")
///              .on_behalf_of_content_owner("sit")
///              .doit();
/// # }
/// ```
pub struct LiveStreamDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveStreamDeleteCall<'a, C, A> {}

impl<'a, C, A> LiveStreamDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveStreams.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["id", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/liveStreams";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> LiveStreamDeleteCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> LiveStreamDeleteCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> LiveStreamDeleteCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveStreamDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveStreamDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveStreamDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieve the list of streams associated with the given channel. --
///
/// A builder for the *list* method supported by a *liveStream* resource.
/// It is not used directly, but through a `LiveStreamMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_streams().list("part")
///              .page_token("consetetur")
///              .on_behalf_of_content_owner_channel("labore")
///              .on_behalf_of_content_owner("sed")
///              .mine(true)
///              .max_results(39)
///              .add_id("aliquyam")
///              .doit();
/// # }
/// ```
pub struct LiveStreamListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _page_token: Option<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _mine: Option<bool>,
    _max_results: Option<u32>,
    _id: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveStreamListCall<'a, C, A> {}

impl<'a, C, A> LiveStreamListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveStreamListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveStreams.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(9 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._mine {
            params.push(("mine", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        for &field in ["alt", "part", "pageToken", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner", "mine", "maxResults", "id"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveStreams";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>liveStream</code> resource
    /// properties that the API response will include. The <code>part</code> names
    /// that you can include in the parameter value are <code>id</code>,
    /// <code>snippet</code>, <code>cdn</code>, and <code>status</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> LiveStreamListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> LiveStreamListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> LiveStreamListCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> LiveStreamListCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    ///
    /// Sets the *mine* query property to the given value.
    pub fn mine(mut self, new_value: bool) -> LiveStreamListCall<'a, C, A> {
        self._mine = Some(new_value);
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> LiveStreamListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// Return LiveStreams with the given ids from Stubby or Apiary.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> LiveStreamListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveStreamListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveStreamListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveStreamListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new stream for the authenticated user.
///
/// A builder for the *insert* method supported by a *liveStream* resource.
/// It is not used directly, but through a `LiveStreamMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::LiveStream;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = LiveStream::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_streams().insert(req)
///              .on_behalf_of_content_owner_channel("eos")
///              .on_behalf_of_content_owner("tempor")
///              .doit();
/// # }
/// ```
pub struct LiveStreamInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: LiveStream,
    _part: Vec<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveStreamInsertCall<'a, C, A> {}

impl<'a, C, A> LiveStreamInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveStream)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveStreams.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveStreams";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: LiveStream) -> LiveStreamInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will
    /// include.<br><br>The <code>part</code> properties that you can include in
    /// the parameter value are <code>id</code>, <code>snippet</code>,
    /// <code>cdn</code>, and <code>status</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> LiveStreamInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> LiveStreamInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> LiveStreamInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveStreamInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveStreamInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveStreamInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates an existing resource.
///
/// A builder for the *update* method supported by a *channel* resource.
/// It is not used directly, but through a `ChannelMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::Channel;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = Channel::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.channels().update(req)
///              .on_behalf_of_content_owner("sea")
///              .doit();
/// # }
/// ```
pub struct ChannelUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: Channel,
    _part: Vec<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ChannelUpdateCall<'a, C, A> {}

impl<'a, C, A> ChannelUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, Channel)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.channels.update",
                               http_method: hyper::method::Method::Put });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/channels";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Put, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: Channel) -> ChannelUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will
    /// include.<br/><br/>The API currently only allows the parameter value to be
    /// set to either <code>brandingSettings</code> or
    /// <code>invideoPromotion</code>. (You cannot update both of those parts with
    /// a single request.)<br/><br/>Note that this method overrides the existing
    /// values for all of the mutable properties that are contained in any parts
    /// that the parameter value specifies.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> ChannelUpdateCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The <code><strong>onBehalfOfContentOwner</strong></code> parameter
    /// indicates that the authenticated user is acting on behalf of the content
    /// owner specified in the parameter value. This parameter is intended for
    /// YouTube content partners that own and manage many different YouTube
    /// channels. It allows content owners to authenticate once and get access to
    /// all their video and channel data, without having to provide authentication
    /// credentials for each individual channel. The actual CMS account that the
    /// user authenticates with needs to be linked to the specified YouTube content
    /// owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> ChannelUpdateCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ChannelUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ChannelUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ChannelUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *channel* resource.
/// It is not used directly, but through a `ChannelMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.channels().list("part")
///              .page_token("ipsum")
///              .on_behalf_of_content_owner("aliquyam")
///              .my_subscribers(false)
///              .mine(false)
///              .max_results(60)
///              .managed_by_me(true)
///              .add_id("justo")
///              .hl("est")
///              .for_username("amet")
///              .category_id("accusam")
///              .doit();
/// # }
/// ```
pub struct ChannelListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _page_token: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _my_subscribers: Option<bool>,
    _mine: Option<bool>,
    _max_results: Option<u32>,
    _managed_by_me: Option<bool>,
    _id: Vec<String>,
    _hl: Option<String>,
    _for_username: Option<String>,
    _category_id: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ChannelListCall<'a, C, A> {}

impl<'a, C, A> ChannelListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, ChannelListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.channels.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(13 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._my_subscribers {
            params.push(("mySubscribers", value.to_string()));
        }
        if let Some(value) = self._mine {
            params.push(("mine", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if let Some(value) = self._managed_by_me {
            params.push(("managedByMe", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        if let Some(value) = self._hl {
            params.push(("hl", value.to_string()));
        }
        if let Some(value) = self._for_username {
            params.push(("forUsername", value.to_string()));
        }
        if let Some(value) = self._category_id {
            params.push(("categoryId", value.to_string()));
        }
        for &field in ["alt", "part", "pageToken", "onBehalfOfContentOwner", "mySubscribers", "mine", "maxResults", "managedByMe", "id", "hl", "forUsername", "categoryId"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/channels";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>channel</code> resource
    /// properties that the API response will include.<br><br>If the parameter
    /// identifies a property that contains child properties, the child properties
    /// will be included in the response. For example, in a <code>channel</code>
    /// resource, the <code>contentDetails</code> property contains other
    /// properties, such as the <code>uploads</code> properties. As such, if you
    /// set <code><strong>part=contentDetails</strong></code>, the API response
    /// will also contain all of those nested properties.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> ChannelListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ChannelListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> ChannelListCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// Return the channels subscribed to the authenticated user
    ///
    /// Sets the *my subscribers* query property to the given value.
    pub fn my_subscribers(mut self, new_value: bool) -> ChannelListCall<'a, C, A> {
        self._my_subscribers = Some(new_value);
        self
    }
    /// Return the ids of channels owned by the authenticated user.
    ///
    /// Sets the *mine* query property to the given value.
    pub fn mine(mut self, new_value: bool) -> ChannelListCall<'a, C, A> {
        self._mine = Some(new_value);
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> ChannelListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// Return the channels managed by the authenticated user.
    ///
    /// Sets the *managed by me* query property to the given value.
    pub fn managed_by_me(mut self, new_value: bool) -> ChannelListCall<'a, C, A> {
        self._managed_by_me = Some(new_value);
        self
    }
    /// Return the channels with the specified IDs.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> ChannelListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// Stands for "host language". Specifies the localization language of the
    /// metadata to be filled into snippet.localized. The field is filled with the
    /// default metadata if there is no localization in the specified language.
    /// The parameter value must be a language code included in the list returned
    /// by the i18nLanguages.list method (e.g. en_US, es_MX).
    ///
    /// Sets the *hl* query property to the given value.
    pub fn hl(mut self, new_value: &str) -> ChannelListCall<'a, C, A> {
        self._hl = Some(new_value.to_string());
        self
    }
    /// Return the channel associated with a YouTube username.
    ///
    /// Sets the *for username* query property to the given value.
    pub fn for_username(mut self, new_value: &str) -> ChannelListCall<'a, C, A> {
        self._for_username = Some(new_value.to_string());
        self
    }
    /// Return the channels within the specified guide category ID.
    ///
    /// Sets the *category id* query property to the given value.
    pub fn category_id(mut self, new_value: &str) -> ChannelListCall<'a, C, A> {
        self._category_id = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ChannelListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ChannelListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ChannelListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Allows upload of watermark image and setting it for a channel.
///
/// A builder for the *set* method supported by a *watermark* resource.
/// It is not used directly, but through a `WatermarkMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::InvideoBranding;
/// use std::fs;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = InvideoBranding::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `upload(...)`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.watermarks().set(req, "channelId")
///              .on_behalf_of_content_owner("diam")
///              .upload(fs::File::open("file.ext").unwrap(), "application/octet-stream".parse().unwrap());
/// # }
/// ```
pub struct WatermarkSetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: InvideoBranding,
    _channel_id: String,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for WatermarkSetCall<'a, C, A> {}

impl<'a, C, A> WatermarkSetCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    fn doit<RS>(mut self, mut reader: RS, reader_mime_type: mime::Mime, protocol: &'static str) -> Result<hyper::client::Response>
		where RS: ReadSeek {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.watermarks.set",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("channelId", self._channel_id.to_string()));
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["channelId", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let (mut url, upload_type) =
            if protocol == "simple" {
                (self.hub._root_url.clone() + "upload/youtube/v3/watermarks/set", "multipart")
            } else {
                unreachable!()
            };
        params.push(("uploadType", upload_type.to_string()));
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut mp_reader: MultiPartReader = Default::default();
                let (mut body_reader, content_type) = match protocol {
                    "simple" => {
                        mp_reader.reserve_exact(2);
                        let size = reader.seek(io::SeekFrom::End(0)).unwrap();
                    reader.seek(io::SeekFrom::Start(0)).unwrap();
                    if size > 10485760 {
                    	return Err(Error::UploadSizeLimitExceeded(size, 10485760))
                    }
                        mp_reader.add_part(&mut request_value_reader, request_size, json_mime_type.clone())
                                 .add_part(&mut reader, size, reader_mime_type.clone());
                        let mime_type = mp_reader.mime_type();
                        (&mut mp_reader as &mut dyn io::Read, ContentType(mime_type))
                    },
                    _ => (&mut request_value_reader as &mut dyn io::Read, ContentType(json_mime_type.clone())),
                };
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(content_type)
                    .body(&mut body_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }

    /// Upload media all at once.
    /// If the upload fails for whichever reason, all progress is lost.
    ///
    /// * *max size*: 10485760
    /// * *multipart*: yes
    /// * *valid mime types*: 'image/jpeg', 'image/png' and 'application/octet-stream'
    pub fn upload<RS>(self, stream: RS, mime_type: mime::Mime) -> Result<hyper::client::Response>
                where RS: ReadSeek {
        self.doit(stream, mime_type, "simple")
    }

    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: InvideoBranding) -> WatermarkSetCall<'a, C, A> {
        self._request = new_value;
        self
    }
    ///
    /// Sets the *channel id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn channel_id(mut self, new_value: &str) -> WatermarkSetCall<'a, C, A> {
        self._channel_id = new_value.to_string();
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> WatermarkSetCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> WatermarkSetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> WatermarkSetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> WatermarkSetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Allows removal of channel watermark.
///
/// A builder for the *unset* method supported by a *watermark* resource.
/// It is not used directly, but through a `WatermarkMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.watermarks().unset("channelId")
///              .on_behalf_of_content_owner("est")
///              .doit();
/// # }
/// ```
pub struct WatermarkUnsetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _channel_id: String,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for WatermarkUnsetCall<'a, C, A> {}

impl<'a, C, A> WatermarkUnsetCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.watermarks.unset",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("channelId", self._channel_id.to_string()));
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["channelId", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/watermarks/unset";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *channel id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn channel_id(mut self, new_value: &str) -> WatermarkUnsetCall<'a, C, A> {
        self._channel_id = new_value.to_string();
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> WatermarkUnsetCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> WatermarkUnsetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> WatermarkUnsetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> WatermarkUnsetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *liveChatModerator* resource.
/// It is not used directly, but through a `LiveChatModeratorMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::LiveChatModerator;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = LiveChatModerator::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_chat_moderators().insert(req)
///              .doit();
/// # }
/// ```
pub struct LiveChatModeratorInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: LiveChatModerator,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveChatModeratorInsertCall<'a, C, A> {}

impl<'a, C, A> LiveChatModeratorInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveChatModerator)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveChatModerators.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveChat/moderators";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: LiveChatModerator) -> LiveChatModeratorInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response returns. Set the
    /// parameter value to <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> LiveChatModeratorInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveChatModeratorInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveChatModeratorInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveChatModeratorInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *liveChatModerator* resource.
/// It is not used directly, but through a `LiveChatModeratorMethods` instance.
///
/// **Settable Parts**
/// 
/// * *<code>id</code>*
/// * *<code>snippet</code>*
///
/// # Scopes
///
/// You will need authorization for at least one of the following scopes to make a valid call, possibly depending on *parts*:
///
/// * *https://www.googleapis.com/auth/youtube*
/// * *https://www.googleapis.com/auth/youtube.force-ssl*
/// * *https://www.googleapis.com/auth/youtube.readonly*
///
/// The default scope will be `Scope::Readonly`.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_chat_moderators().list("liveChatId", "part")
///              .page_token("ut")
///              .max_results(82)
///              .doit();
/// # }
/// ```
pub struct LiveChatModeratorListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _live_chat_id: String,
    _part: Vec<String>,
    _page_token: Option<String>,
    _max_results: Option<u32>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveChatModeratorListCall<'a, C, A> {}

impl<'a, C, A> LiveChatModeratorListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveChatModeratorListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveChatModerators.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        params.push(("liveChatId", self._live_chat_id.to_string()));
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        for &field in ["alt", "liveChatId", "part", "pageToken", "maxResults"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveChat/moderators";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The id of the live chat for which moderators should be returned.
    ///
    /// Sets the *live chat id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn live_chat_id(mut self, new_value: &str) -> LiveChatModeratorListCall<'a, C, A> {
        self._live_chat_id = new_value.to_string();
        self
    }
    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>liveChatModerator</code> resource parts that the API response will
    /// include. Supported values are <code>id</code> and <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    ///
    /// **Settable Parts**
    /// 
    /// * *<code>id</code>*
    /// * *<code>snippet</code>*
    pub fn add_part(mut self, new_value: &str) -> LiveChatModeratorListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> LiveChatModeratorListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> LiveChatModeratorListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveChatModeratorListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveChatModeratorListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveChatModeratorListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes a chat moderator.
///
/// A builder for the *delete* method supported by a *liveChatModerator* resource.
/// It is not used directly, but through a `LiveChatModeratorMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_chat_moderators().delete("id")
///              .doit();
/// # }
/// ```
pub struct LiveChatModeratorDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveChatModeratorDeleteCall<'a, C, A> {}

impl<'a, C, A> LiveChatModeratorDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveChatModerators.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(2 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        for &field in ["id"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/liveChat/moderators";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> LiveChatModeratorDeleteCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveChatModeratorDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveChatModeratorDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveChatModeratorDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *caption* resource.
/// It is not used directly, but through a `CaptionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::Caption;
/// use std::fs;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = Caption::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `upload(...)`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.captions().insert(req)
///              .sync(false)
///              .on_behalf_of_content_owner("duo")
///              .on_behalf_of("sed")
///              .upload(fs::File::open("file.ext").unwrap(), "application/octet-stream".parse().unwrap());
/// # }
/// ```
pub struct CaptionInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: Caption,
    _part: Vec<String>,
    _sync: Option<bool>,
    _on_behalf_of_content_owner: Option<String>,
    _on_behalf_of: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CaptionInsertCall<'a, C, A> {}

impl<'a, C, A> CaptionInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    fn doit<RS>(mut self, mut reader: RS, reader_mime_type: mime::Mime, protocol: &'static str) -> Result<(hyper::client::Response, Caption)>
		where RS: ReadSeek {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.captions.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(7 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._sync {
            params.push(("sync", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of {
            params.push(("onBehalfOf", value.to_string()));
        }
        for &field in ["alt", "part", "sync", "onBehalfOfContentOwner", "onBehalfOf"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let (mut url, upload_type) =
            if protocol == "simple" {
                (self.hub._root_url.clone() + "upload/youtube/v3/captions", "multipart")
            } else {
                unreachable!()
            };
        params.push(("uploadType", upload_type.to_string()));
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut mp_reader: MultiPartReader = Default::default();
                let (mut body_reader, content_type) = match protocol {
                    "simple" => {
                        mp_reader.reserve_exact(2);
                        let size = reader.seek(io::SeekFrom::End(0)).unwrap();
                    reader.seek(io::SeekFrom::Start(0)).unwrap();
                    if size > 104857600 {
                    	return Err(Error::UploadSizeLimitExceeded(size, 104857600))
                    }
                        mp_reader.add_part(&mut request_value_reader, request_size, json_mime_type.clone())
                                 .add_part(&mut reader, size, reader_mime_type.clone());
                        let mime_type = mp_reader.mime_type();
                        (&mut mp_reader as &mut dyn io::Read, ContentType(mime_type))
                    },
                    _ => (&mut request_value_reader as &mut dyn io::Read, ContentType(json_mime_type.clone())),
                };
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(content_type)
                    .body(&mut body_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }

    /// Upload media all at once.
    /// If the upload fails for whichever reason, all progress is lost.
    ///
    /// * *max size*: 104857600
    /// * *multipart*: yes
    /// * *valid mime types*: 'text/xml', 'application/octet-stream' and '*/*'
    pub fn upload<RS>(self, stream: RS, mime_type: mime::Mime) -> Result<(hyper::client::Response, Caption)>
                where RS: ReadSeek {
        self.doit(stream, mime_type, "simple")
    }

    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: Caption) -> CaptionInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>caption</code> resource parts that the API response will include. Set
    /// the parameter value to <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> CaptionInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Extra parameter to allow automatically syncing the uploaded
    /// caption/transcript with the audio.
    ///
    /// Sets the *sync* query property to the given value.
    pub fn sync(mut self, new_value: bool) -> CaptionInsertCall<'a, C, A> {
        self._sync = Some(new_value);
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the request's authorization credentials identify a YouTube CMS user
    /// who is acting on behalf of the content owner specified in the parameter
    /// value. This parameter is intended for YouTube content partners that own and
    /// manage many different YouTube channels. It allows content owners to
    /// authenticate once and get access to all their video and channel data,
    /// without having to provide authentication credentials for each individual
    /// channel. The actual CMS account that the user authenticates with must be
    /// linked to the specified YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> CaptionInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// ID of the Google+ Page for the channel that the request is be on behalf of
    ///
    /// Sets the *on behalf of* query property to the given value.
    pub fn on_behalf_of(mut self, new_value: &str) -> CaptionInsertCall<'a, C, A> {
        self._on_behalf_of = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CaptionInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CaptionInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CaptionInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes a resource.
///
/// A builder for the *delete* method supported by a *caption* resource.
/// It is not used directly, but through a `CaptionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.captions().delete("id")
///              .on_behalf_of_content_owner("ea")
///              .on_behalf_of("ea")
///              .doit();
/// # }
/// ```
pub struct CaptionDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _on_behalf_of_content_owner: Option<String>,
    _on_behalf_of: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CaptionDeleteCall<'a, C, A> {}

impl<'a, C, A> CaptionDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.captions.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of {
            params.push(("onBehalfOf", value.to_string()));
        }
        for &field in ["id", "onBehalfOfContentOwner", "onBehalfOf"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/captions";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> CaptionDeleteCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the request's authorization credentials identify a YouTube CMS user
    /// who is acting on behalf of the content owner specified in the parameter
    /// value. This parameter is intended for YouTube content partners that own and
    /// manage many different YouTube channels. It allows content owners to
    /// authenticate once and get access to all their video and channel data,
    /// without having to provide authentication credentials for each individual
    /// channel. The actual CMS account that the user authenticates with must be
    /// linked to the specified YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> CaptionDeleteCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// ID of the Google+ Page for the channel that the request is be on behalf of
    ///
    /// Sets the *on behalf of* query property to the given value.
    pub fn on_behalf_of(mut self, new_value: &str) -> CaptionDeleteCall<'a, C, A> {
        self._on_behalf_of = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CaptionDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CaptionDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CaptionDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Downloads a caption track.
///
/// This method supports **media download**. To enable it, adjust the builder like this:
/// `.param("alt", "media")`.
///
/// A builder for the *download* method supported by a *caption* resource.
/// It is not used directly, but through a `CaptionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.captions().download("id")
///              .tlang("dolor")
///              .tfmt("diam")
///              .on_behalf_of_content_owner("kasd")
///              .on_behalf_of("invidunt")
///              .doit();
/// # }
/// ```
pub struct CaptionDownloadCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _tlang: Option<String>,
    _tfmt: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _on_behalf_of: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CaptionDownloadCall<'a, C, A> {}

impl<'a, C, A> CaptionDownloadCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.captions.download",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        if let Some(value) = self._tlang {
            params.push(("tlang", value.to_string()));
        }
        if let Some(value) = self._tfmt {
            params.push(("tfmt", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of {
            params.push(("onBehalfOf", value.to_string()));
        }
        for &field in ["id", "tlang", "tfmt", "onBehalfOfContentOwner", "onBehalfOf"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/captions/{id}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{id}", "id")].iter() {
            let mut replace_with: Option<&str> = None;
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = Some(value);
                    break;
                }
            }
            url = url.replace(find_this, replace_with.expect("to find substitution value in params"));
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["id"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The ID of the caption track to download, required for One Platform.
    ///
    /// Sets the *id* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> CaptionDownloadCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// tlang is the language code; machine translate the captions into
    /// this language.
    ///
    /// Sets the *tlang* query property to the given value.
    pub fn tlang(mut self, new_value: &str) -> CaptionDownloadCall<'a, C, A> {
        self._tlang = Some(new_value.to_string());
        self
    }
    /// Convert the captions into this format. Supported options are
    /// sbv, srt, and vtt.
    ///
    /// Sets the *tfmt* query property to the given value.
    pub fn tfmt(mut self, new_value: &str) -> CaptionDownloadCall<'a, C, A> {
        self._tfmt = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the request's authorization credentials identify a YouTube CMS user
    /// who is acting on behalf of the content owner specified in the parameter
    /// value. This parameter is intended for YouTube content partners that own and
    /// manage many different YouTube channels. It allows content owners to
    /// authenticate once and get access to all their video and channel data,
    /// without having to provide authentication credentials for each individual
    /// channel. The actual CMS account that the user authenticates with must be
    /// linked to the specified YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> CaptionDownloadCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// ID of the Google+ Page for the channel that the request is be on behalf of
    ///
    /// Sets the *on behalf of* query property to the given value.
    pub fn on_behalf_of(mut self, new_value: &str) -> CaptionDownloadCall<'a, C, A> {
        self._on_behalf_of = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CaptionDownloadCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CaptionDownloadCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CaptionDownloadCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *caption* resource.
/// It is not used directly, but through a `CaptionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.captions().list("videoId", "part")
///              .on_behalf_of_content_owner("clita")
///              .on_behalf_of("invidunt")
///              .add_id("eirmod")
///              .doit();
/// # }
/// ```
pub struct CaptionListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _video_id: String,
    _part: Vec<String>,
    _on_behalf_of_content_owner: Option<String>,
    _on_behalf_of: Option<String>,
    _id: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CaptionListCall<'a, C, A> {}

impl<'a, C, A> CaptionListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, CaptionListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.captions.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(7 + self._additional_params.len());
        params.push(("videoId", self._video_id.to_string()));
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of {
            params.push(("onBehalfOf", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        for &field in ["alt", "videoId", "part", "onBehalfOfContentOwner", "onBehalfOf", "id"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/captions";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// Returns the captions for the specified video.
    ///
    /// Sets the *video id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn video_id(mut self, new_value: &str) -> CaptionListCall<'a, C, A> {
        self._video_id = new_value.to_string();
        self
    }
    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>caption</code> resource parts
    /// that the API response will include. The <code>part</code> names that you
    /// can include in the parameter value are <code>id</code> and
    /// <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> CaptionListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the request's authorization credentials identify a YouTube CMS user
    /// who is acting on behalf of the content owner specified in the parameter
    /// value. This parameter is intended for YouTube content partners that own and
    /// manage many different YouTube channels. It allows content owners to
    /// authenticate once and get access to all their video and channel data,
    /// without having to provide authentication credentials for each individual
    /// channel. The actual CMS account that the user authenticates with must be
    /// linked to the specified YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> CaptionListCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// ID of the Google+ Page for the channel that the request is on behalf of.
    ///
    /// Sets the *on behalf of* query property to the given value.
    pub fn on_behalf_of(mut self, new_value: &str) -> CaptionListCall<'a, C, A> {
        self._on_behalf_of = Some(new_value.to_string());
        self
    }
    /// Returns the captions with the given IDs for Stubby or Apiary.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> CaptionListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CaptionListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CaptionListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CaptionListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates an existing resource.
///
/// A builder for the *update* method supported by a *caption* resource.
/// It is not used directly, but through a `CaptionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::Caption;
/// use std::fs;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = Caption::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `upload(...)`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.captions().update(req)
///              .sync(false)
///              .on_behalf_of_content_owner("consetetur")
///              .on_behalf_of("et")
///              .upload(fs::File::open("file.ext").unwrap(), "application/octet-stream".parse().unwrap());
/// # }
/// ```
pub struct CaptionUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: Caption,
    _part: Vec<String>,
    _sync: Option<bool>,
    _on_behalf_of_content_owner: Option<String>,
    _on_behalf_of: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CaptionUpdateCall<'a, C, A> {}

impl<'a, C, A> CaptionUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    fn doit<RS>(mut self, mut reader: RS, reader_mime_type: mime::Mime, protocol: &'static str) -> Result<(hyper::client::Response, Caption)>
		where RS: ReadSeek {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.captions.update",
                               http_method: hyper::method::Method::Put });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(7 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._sync {
            params.push(("sync", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of {
            params.push(("onBehalfOf", value.to_string()));
        }
        for &field in ["alt", "part", "sync", "onBehalfOfContentOwner", "onBehalfOf"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let (mut url, upload_type) =
            if protocol == "simple" {
                (self.hub._root_url.clone() + "upload/youtube/v3/captions", "multipart")
            } else {
                unreachable!()
            };
        params.push(("uploadType", upload_type.to_string()));
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut mp_reader: MultiPartReader = Default::default();
                let (mut body_reader, content_type) = match protocol {
                    "simple" => {
                        mp_reader.reserve_exact(2);
                        let size = reader.seek(io::SeekFrom::End(0)).unwrap();
                    reader.seek(io::SeekFrom::Start(0)).unwrap();
                    if size > 104857600 {
                    	return Err(Error::UploadSizeLimitExceeded(size, 104857600))
                    }
                        mp_reader.add_part(&mut request_value_reader, request_size, json_mime_type.clone())
                                 .add_part(&mut reader, size, reader_mime_type.clone());
                        let mime_type = mp_reader.mime_type();
                        (&mut mp_reader as &mut dyn io::Read, ContentType(mime_type))
                    },
                    _ => (&mut request_value_reader as &mut dyn io::Read, ContentType(json_mime_type.clone())),
                };
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Put, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(content_type)
                    .body(&mut body_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }

    /// Upload media all at once.
    /// If the upload fails for whichever reason, all progress is lost.
    ///
    /// * *max size*: 104857600
    /// * *multipart*: yes
    /// * *valid mime types*: 'text/xml', 'application/octet-stream' and '*/*'
    pub fn upload<RS>(self, stream: RS, mime_type: mime::Mime) -> Result<(hyper::client::Response, Caption)>
                where RS: ReadSeek {
        self.doit(stream, mime_type, "simple")
    }

    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: Caption) -> CaptionUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>caption</code> resource parts
    /// that the API response will include. The <code>part</code> names that you
    /// can include in the parameter value are <code>id</code> and
    /// <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> CaptionUpdateCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Extra parameter to allow automatically syncing the uploaded
    /// caption/transcript with the audio.
    ///
    /// Sets the *sync* query property to the given value.
    pub fn sync(mut self, new_value: bool) -> CaptionUpdateCall<'a, C, A> {
        self._sync = Some(new_value);
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the request's authorization credentials identify a YouTube CMS user
    /// who is acting on behalf of the content owner specified in the parameter
    /// value. This parameter is intended for YouTube content partners that own and
    /// manage many different YouTube channels. It allows content owners to
    /// authenticate once and get access to all their video and channel data,
    /// without having to provide authentication credentials for each individual
    /// channel. The actual CMS account that the user authenticates with must be
    /// linked to the specified YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> CaptionUpdateCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// ID of the Google+ Page for the channel that the request is on behalf of.
    ///
    /// Sets the *on behalf of* query property to the given value.
    pub fn on_behalf_of(mut self, new_value: &str) -> CaptionUpdateCall<'a, C, A> {
        self._on_behalf_of = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CaptionUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CaptionUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CaptionUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *abuseReport* resource.
/// It is not used directly, but through a `AbuseReportMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::AbuseReport;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = AbuseReport::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.abuse_reports().insert(req)
///              .doit();
/// # }
/// ```
pub struct AbuseReportInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: AbuseReport,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for AbuseReportInsertCall<'a, C, A> {}

impl<'a, C, A> AbuseReportInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, AbuseReport)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.abuseReports.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/abuseReports";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: AbuseReport) -> AbuseReportInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will include.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> AbuseReportInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> AbuseReportInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> AbuseReportInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> AbuseReportInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *i18nLanguage* resource.
/// It is not used directly, but through a `I18nLanguageMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.i18n_languages().list("part")
///              .hl("sit")
///              .doit();
/// # }
/// ```
pub struct I18nLanguageListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _hl: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for I18nLanguageListCall<'a, C, A> {}

impl<'a, C, A> I18nLanguageListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, I18nLanguageListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.i18nLanguages.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._hl {
            params.push(("hl", value.to_string()));
        }
        for &field in ["alt", "part", "hl"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/i18nLanguages";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>i18nLanguage</code> resource properties that the API response will
    /// include. Set the parameter value to <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> I18nLanguageListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    ///
    /// Sets the *hl* query property to the given value.
    pub fn hl(mut self, new_value: &str) -> I18nLanguageListCall<'a, C, A> {
        self._hl = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> I18nLanguageListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> I18nLanguageListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> I18nLanguageListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of guide categories.
///
/// A builder for the *list* method supported by a *guideCategory* resource.
/// It is not used directly, but through a `GuideCategoryMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.guide_categories().list("part")
///              .region_code("elitr")
///              .add_id("nonumy")
///              .hl("rebum.")
///              .doit();
/// # }
/// ```
pub struct GuideCategoryListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _region_code: Option<String>,
    _id: Vec<String>,
    _hl: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for GuideCategoryListCall<'a, C, A> {}

impl<'a, C, A> GuideCategoryListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, GuideCategoryListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.guideCategories.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._region_code {
            params.push(("regionCode", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        if let Some(value) = self._hl {
            params.push(("hl", value.to_string()));
        }
        for &field in ["alt", "part", "regionCode", "id", "hl"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/guideCategories";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>guideCategory</code> resource properties that the API response will
    /// include. Set the parameter value to <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> GuideCategoryListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Return all categories in the given region code.
    ///
    /// Sets the *region code* query property to the given value.
    pub fn region_code(mut self, new_value: &str) -> GuideCategoryListCall<'a, C, A> {
        self._region_code = Some(new_value.to_string());
        self
    }
    /// Return the guide categories with the given IDs.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> GuideCategoryListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    ///
    /// Sets the *hl* query property to the given value.
    pub fn hl(mut self, new_value: &str) -> GuideCategoryListCall<'a, C, A> {
        self._hl = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> GuideCategoryListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> GuideCategoryListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> GuideCategoryListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of all pricing levels offered by a creator to the fans.
///
/// A builder for the *list* method supported by a *membershipsLevel* resource.
/// It is not used directly, but through a `MembershipsLevelMethods` instance.
///
/// **Settable Parts**
/// 
/// * *<code>id</code>*
/// * *<code>snippet</code>*
///
/// # Scopes
///
/// You will need authorization for at least one of the following scopes to make a valid call, possibly depending on *parts*:
///
/// * *https://www.googleapis.com/auth/youtube*
/// * *https://www.googleapis.com/auth/youtube.channel-memberships.creator*
/// * *https://www.googleapis.com/auth/youtube.force-ssl*
/// * *https://www.googleapis.com/auth/youtube.readonly*
/// * *https://www.googleapis.com/auth/youtubepartner*
///
/// The default scope will be `Scope::Readonly`.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.memberships_levels().list("part")
///              .doit();
/// # }
/// ```
pub struct MembershipsLevelListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for MembershipsLevelListCall<'a, C, A> {}

impl<'a, C, A> MembershipsLevelListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, MembershipsLevelListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.membershipsLevels.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/membershipsLevels";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>membershipsLevel</code> resource parts that the API response will
    /// include. Supported values are <code>id</code> and <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    ///
    /// **Settable Parts**
    /// 
    /// * *<code>id</code>*
    /// * *<code>snippet</code>*
    pub fn add_part(mut self, new_value: &str) -> MembershipsLevelListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> MembershipsLevelListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> MembershipsLevelListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> MembershipsLevelListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *commentThread* resource.
/// It is not used directly, but through a `CommentThreadMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.comment_threads().list("part")
///              .video_id("diam")
///              .text_format("ut")
///              .search_terms("ut")
///              .page_token("amet.")
///              .order("ipsum")
///              .moderation_status("ut")
///              .max_results(98)
///              .add_id("sea")
///              .channel_id("ut")
///              .all_threads_related_to_channel_id("eirmod")
///              .doit();
/// # }
/// ```
pub struct CommentThreadListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _video_id: Option<String>,
    _text_format: Option<String>,
    _search_terms: Option<String>,
    _page_token: Option<String>,
    _order: Option<String>,
    _moderation_status: Option<String>,
    _max_results: Option<u32>,
    _id: Vec<String>,
    _channel_id: Option<String>,
    _all_threads_related_to_channel_id: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CommentThreadListCall<'a, C, A> {}

impl<'a, C, A> CommentThreadListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, CommentThreadListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.commentThreads.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(13 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._video_id {
            params.push(("videoId", value.to_string()));
        }
        if let Some(value) = self._text_format {
            params.push(("textFormat", value.to_string()));
        }
        if let Some(value) = self._search_terms {
            params.push(("searchTerms", value.to_string()));
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._order {
            params.push(("order", value.to_string()));
        }
        if let Some(value) = self._moderation_status {
            params.push(("moderationStatus", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        if let Some(value) = self._channel_id {
            params.push(("channelId", value.to_string()));
        }
        if let Some(value) = self._all_threads_related_to_channel_id {
            params.push(("allThreadsRelatedToChannelId", value.to_string()));
        }
        for &field in ["alt", "part", "videoId", "textFormat", "searchTerms", "pageToken", "order", "moderationStatus", "maxResults", "id", "channelId", "allThreadsRelatedToChannelId"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/commentThreads";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>commentThread</code> resource
    /// properties that the API response will include.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> CommentThreadListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Returns the comment threads of the specified video.
    ///
    /// Sets the *video id* query property to the given value.
    pub fn video_id(mut self, new_value: &str) -> CommentThreadListCall<'a, C, A> {
        self._video_id = Some(new_value.to_string());
        self
    }
    /// The requested text format for the returned comments.
    ///
    /// Sets the *text format* query property to the given value.
    pub fn text_format(mut self, new_value: &str) -> CommentThreadListCall<'a, C, A> {
        self._text_format = Some(new_value.to_string());
        self
    }
    /// Limits the returned comment threads to those matching the specified
    /// key words. Not compatible with the 'id' filter.
    ///
    /// Sets the *search terms* query property to the given value.
    pub fn search_terms(mut self, new_value: &str) -> CommentThreadListCall<'a, C, A> {
        self._search_terms = Some(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> CommentThreadListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    ///
    /// Sets the *order* query property to the given value.
    pub fn order(mut self, new_value: &str) -> CommentThreadListCall<'a, C, A> {
        self._order = Some(new_value.to_string());
        self
    }
    /// Limits the returned comment threads to those with the specified
    /// moderation status. Not compatible with the 'id' filter.
    /// Valid values: published, heldForReview, likelySpam.
    ///
    /// Sets the *moderation status* query property to the given value.
    pub fn moderation_status(mut self, new_value: &str) -> CommentThreadListCall<'a, C, A> {
        self._moderation_status = Some(new_value.to_string());
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> CommentThreadListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// Returns the comment threads with the given IDs for Stubby or Apiary.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> CommentThreadListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// Returns the comment threads for all the channel comments (ie does not
    /// include comments left on videos).
    ///
    /// Sets the *channel id* query property to the given value.
    pub fn channel_id(mut self, new_value: &str) -> CommentThreadListCall<'a, C, A> {
        self._channel_id = Some(new_value.to_string());
        self
    }
    /// Returns the comment threads of all videos of the channel and the
    /// channel comments as well.
    ///
    /// Sets the *all threads related to channel id* query property to the given value.
    pub fn all_threads_related_to_channel_id(mut self, new_value: &str) -> CommentThreadListCall<'a, C, A> {
        self._all_threads_related_to_channel_id = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CommentThreadListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CommentThreadListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CommentThreadListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates an existing resource.
///
/// A builder for the *update* method supported by a *commentThread* resource.
/// It is not used directly, but through a `CommentThreadMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::CommentThread;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = CommentThread::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.comment_threads().update(req)
///              .doit();
/// # }
/// ```
pub struct CommentThreadUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: CommentThread,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CommentThreadUpdateCall<'a, C, A> {}

impl<'a, C, A> CommentThreadUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, CommentThread)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.commentThreads.update",
                               http_method: hyper::method::Method::Put });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/commentThreads";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Put, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: CommentThread) -> CommentThreadUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of <code>commentThread</code> resource properties that
    /// the API response will include. You must at least include the
    /// <code>snippet</code> part in the parameter value since that part contains
    /// all of the properties that the API request can update.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> CommentThreadUpdateCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CommentThreadUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CommentThreadUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CommentThreadUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *commentThread* resource.
/// It is not used directly, but through a `CommentThreadMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::CommentThread;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = CommentThread::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.comment_threads().insert(req)
///              .doit();
/// # }
/// ```
pub struct CommentThreadInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: CommentThread,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CommentThreadInsertCall<'a, C, A> {}

impl<'a, C, A> CommentThreadInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, CommentThread)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.commentThreads.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/commentThreads";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: CommentThread) -> CommentThreadInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter identifies the properties
    /// that the API response will include. Set the parameter value to
    /// <code>snippet</code>. The <code>snippet</code> part has a quota cost of 2
    /// units.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> CommentThreadInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CommentThreadInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CommentThreadInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CommentThreadInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *comment* resource.
/// It is not used directly, but through a `CommentMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::Comment;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = Comment::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.comments().insert(req)
///              .doit();
/// # }
/// ```
pub struct CommentInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: Comment,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CommentInsertCall<'a, C, A> {}

impl<'a, C, A> CommentInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, Comment)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.comments.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/comments";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: Comment) -> CommentInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter identifies the properties
    /// that the API response will include. Set the parameter value to
    /// <code>snippet</code>. The <code>snippet</code> part has a quota cost of 2
    /// units.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> CommentInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CommentInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CommentInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CommentInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes a resource.
///
/// A builder for the *delete* method supported by a *comment* resource.
/// It is not used directly, but through a `CommentMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.comments().delete("id")
///              .doit();
/// # }
/// ```
pub struct CommentDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CommentDeleteCall<'a, C, A> {}

impl<'a, C, A> CommentDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.comments.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(2 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        for &field in ["id"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/comments";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> CommentDeleteCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CommentDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CommentDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CommentDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *comment* resource.
/// It is not used directly, but through a `CommentMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.comments().list("part")
///              .text_format("dolor")
///              .parent_id("et")
///              .page_token("et")
///              .max_results(75)
///              .add_id("ut")
///              .doit();
/// # }
/// ```
pub struct CommentListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _text_format: Option<String>,
    _parent_id: Option<String>,
    _page_token: Option<String>,
    _max_results: Option<u32>,
    _id: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CommentListCall<'a, C, A> {}

impl<'a, C, A> CommentListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, CommentListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.comments.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(8 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._text_format {
            params.push(("textFormat", value.to_string()));
        }
        if let Some(value) = self._parent_id {
            params.push(("parentId", value.to_string()));
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        for &field in ["alt", "part", "textFormat", "parentId", "pageToken", "maxResults", "id"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/comments";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>comment</code> resource
    /// properties that the API response will include.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> CommentListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The requested text format for the returned comments.
    ///
    /// Sets the *text format* query property to the given value.
    pub fn text_format(mut self, new_value: &str) -> CommentListCall<'a, C, A> {
        self._text_format = Some(new_value.to_string());
        self
    }
    /// Returns replies to the specified comment.
    /// Note, currently YouTube features only one level of replies (ie replies
    /// to top level comments). However replies to replies may be supported in
    /// the future.
    ///
    /// Sets the *parent id* query property to the given value.
    pub fn parent_id(mut self, new_value: &str) -> CommentListCall<'a, C, A> {
        self._parent_id = Some(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> CommentListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> CommentListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// Returns the comments with the given IDs for One Platform.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> CommentListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CommentListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CommentListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CommentListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Sets the moderation status of one or more comments.
///
/// A builder for the *setModerationStatus* method supported by a *comment* resource.
/// It is not used directly, but through a `CommentMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.comments().set_moderation_status("id", "moderationStatus")
///              .ban_author(false)
///              .doit();
/// # }
/// ```
pub struct CommentSetModerationStatuCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: Vec<String>,
    _moderation_status: String,
    _ban_author: Option<bool>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CommentSetModerationStatuCall<'a, C, A> {}

impl<'a, C, A> CommentSetModerationStatuCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.comments.setModerationStatus",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        params.push(("moderationStatus", self._moderation_status.to_string()));
        if let Some(value) = self._ban_author {
            params.push(("banAuthor", value.to_string()));
        }
        for &field in ["id", "moderationStatus", "banAuthor"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/comments/setModerationStatus";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// Modifies the moderation status of the comments with the given IDs
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_id(mut self, new_value: &str) -> CommentSetModerationStatuCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// Specifies the requested moderation status. Note, comments can be in
    /// statuses, which are not available through this call. For example, this
    /// call does not allow to mark a comment as 'likely spam'.
    /// Valid values: MODERATION_STATUS_PUBLISHED,
    /// MODERATION_STATUS_HELD_FOR_REVIEW, MODERATION_STATUS_REJECTED.
    ///
    /// Sets the *moderation status* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn moderation_status(mut self, new_value: &str) -> CommentSetModerationStatuCall<'a, C, A> {
        self._moderation_status = new_value.to_string();
        self
    }
    /// If set to true the author of the comment gets added to the ban list.
    /// This means all future comments of the author will autmomatically be
    /// rejected.
    /// Only valid in combination with STATUS_REJECTED.
    ///
    /// Sets the *ban author* query property to the given value.
    pub fn ban_author(mut self, new_value: bool) -> CommentSetModerationStatuCall<'a, C, A> {
        self._ban_author = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CommentSetModerationStatuCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CommentSetModerationStatuCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CommentSetModerationStatuCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates an existing resource.
///
/// A builder for the *update* method supported by a *comment* resource.
/// It is not used directly, but through a `CommentMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::Comment;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = Comment::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.comments().update(req)
///              .doit();
/// # }
/// ```
pub struct CommentUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: Comment,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CommentUpdateCall<'a, C, A> {}

impl<'a, C, A> CommentUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, Comment)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.comments.update",
                               http_method: hyper::method::Method::Put });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/comments";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Put, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: Comment) -> CommentUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter identifies the properties
    /// that the API response will include. You must at least include the
    /// <code>snippet</code> part in the parameter value since that part contains
    /// all of the properties that the API request can update.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> CommentUpdateCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CommentUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CommentUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CommentUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Expresses the caller's opinion that one or more comments should be flagged
/// as spam.
///
/// A builder for the *markAsSpam* method supported by a *comment* resource.
/// It is not used directly, but through a `CommentMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.comments().mark_as_spam("id")
///              .doit();
/// # }
/// ```
pub struct CommentMarkAsSpamCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for CommentMarkAsSpamCall<'a, C, A> {}

impl<'a, C, A> CommentMarkAsSpamCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.comments.markAsSpam",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(2 + self._additional_params.len());
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        for &field in ["id"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/comments/markAsSpam";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::ForceSsl.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// Flags the comments with the given IDs as spam in the caller's opinion.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_id(mut self, new_value: &str) -> CommentMarkAsSpamCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> CommentMarkAsSpamCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> CommentMarkAsSpamCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::ForceSsl`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> CommentMarkAsSpamCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *playlistItem* resource.
/// It is not used directly, but through a `PlaylistItemMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::PlaylistItem;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = PlaylistItem::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.playlist_items().insert(req)
///              .on_behalf_of_content_owner("dolore")
///              .doit();
/// # }
/// ```
pub struct PlaylistItemInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: PlaylistItem,
    _part: Vec<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for PlaylistItemInsertCall<'a, C, A> {}

impl<'a, C, A> PlaylistItemInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, PlaylistItem)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.playlistItems.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/playlistItems";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: PlaylistItem) -> PlaylistItemInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will include.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> PlaylistItemInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> PlaylistItemInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> PlaylistItemInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> PlaylistItemInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> PlaylistItemInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes a resource.
///
/// A builder for the *delete* method supported by a *playlistItem* resource.
/// It is not used directly, but through a `PlaylistItemMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.playlist_items().delete("id")
///              .on_behalf_of_content_owner("dolor")
///              .doit();
/// # }
/// ```
pub struct PlaylistItemDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for PlaylistItemDeleteCall<'a, C, A> {}

impl<'a, C, A> PlaylistItemDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.playlistItems.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["id", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/playlistItems";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> PlaylistItemDeleteCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> PlaylistItemDeleteCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> PlaylistItemDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> PlaylistItemDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> PlaylistItemDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *playlistItem* resource.
/// It is not used directly, but through a `PlaylistItemMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.playlist_items().list("part")
///              .video_id("et")
///              .playlist_id("nonumy")
///              .page_token("et")
///              .on_behalf_of_content_owner("sed")
///              .max_results(91)
///              .add_id("invidunt")
///              .doit();
/// # }
/// ```
pub struct PlaylistItemListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _video_id: Option<String>,
    _playlist_id: Option<String>,
    _page_token: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _max_results: Option<u32>,
    _id: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for PlaylistItemListCall<'a, C, A> {}

impl<'a, C, A> PlaylistItemListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, PlaylistItemListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.playlistItems.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(9 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._video_id {
            params.push(("videoId", value.to_string()));
        }
        if let Some(value) = self._playlist_id {
            params.push(("playlistId", value.to_string()));
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        for &field in ["alt", "part", "videoId", "playlistId", "pageToken", "onBehalfOfContentOwner", "maxResults", "id"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/playlistItems";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>playlistItem</code> resource
    /// properties that the API response will include.<br><br>If the parameter
    /// identifies a property that contains child properties, the child properties
    /// will be included in the response. For example, in a
    /// <code>playlistItem</code> resource, the <code>snippet</code> property
    /// contains numerous fields, including the <code>title</code>,
    /// <code>description</code>, <code>position</code>, and
    /// <code>resourceId</code> properties. As such, if you set
    /// <code><strong>part=snippet</strong></code>, the API response will contain
    /// all of those properties.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> PlaylistItemListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Return the playlist items associated with the given video ID.
    ///
    /// Sets the *video id* query property to the given value.
    pub fn video_id(mut self, new_value: &str) -> PlaylistItemListCall<'a, C, A> {
        self._video_id = Some(new_value.to_string());
        self
    }
    /// Return the playlist items within the given playlist.
    ///
    /// Sets the *playlist id* query property to the given value.
    pub fn playlist_id(mut self, new_value: &str) -> PlaylistItemListCall<'a, C, A> {
        self._playlist_id = Some(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> PlaylistItemListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> PlaylistItemListCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> PlaylistItemListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> PlaylistItemListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> PlaylistItemListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> PlaylistItemListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> PlaylistItemListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates an existing resource.
///
/// A builder for the *update* method supported by a *playlistItem* resource.
/// It is not used directly, but through a `PlaylistItemMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::PlaylistItem;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = PlaylistItem::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.playlist_items().update(req)
///              .on_behalf_of_content_owner("rebum.")
///              .doit();
/// # }
/// ```
pub struct PlaylistItemUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: PlaylistItem,
    _part: Vec<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for PlaylistItemUpdateCall<'a, C, A> {}

impl<'a, C, A> PlaylistItemUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, PlaylistItem)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.playlistItems.update",
                               http_method: hyper::method::Method::Put });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/playlistItems";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Put, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: PlaylistItem) -> PlaylistItemUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will
    /// include.<br/><br/>Note that this method will override the existing values
    /// for all of the mutable properties that are contained in any parts that the
    /// parameter value specifies. For example, a playlist item can specify a start
    /// time and end time, which identify the times portion of the video that
    /// should play when users watch the video in the playlist. If your request is
    /// updating a playlist item that sets these values, and the
    /// request's <code>part</code> parameter value includes the
    /// <code>contentDetails</code> part, the playlist item's start and end times
    /// will be updated to whatever value the request body specifies. If the
    /// request body does not specify values, the existing start and end times will
    /// be removed and replaced with the default settings.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> PlaylistItemUpdateCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> PlaylistItemUpdateCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> PlaylistItemUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> PlaylistItemUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> PlaylistItemUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *liveChatMessage* resource.
/// It is not used directly, but through a `LiveChatMessageMethods` instance.
///
/// **Settable Parts**
/// 
/// * *<code>id</code>*
/// * *<code>snippet</code>*
///
/// # Scopes
///
/// You will need authorization for at least one of the following scopes to make a valid call, possibly depending on *parts*:
///
/// * *https://www.googleapis.com/auth/youtube*
/// * *https://www.googleapis.com/auth/youtube.force-ssl*
/// * *https://www.googleapis.com/auth/youtube.readonly*
///
/// The default scope will be `Scope::Readonly`.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_chat_messages().list("liveChatId", "part")
///              .profile_image_size(7)
///              .page_token("consetetur")
///              .max_results(92)
///              .hl("elitr")
///              .doit();
/// # }
/// ```
pub struct LiveChatMessageListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _live_chat_id: String,
    _part: Vec<String>,
    _profile_image_size: Option<u32>,
    _page_token: Option<String>,
    _max_results: Option<u32>,
    _hl: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveChatMessageListCall<'a, C, A> {}

impl<'a, C, A> LiveChatMessageListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveChatMessageListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveChatMessages.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(8 + self._additional_params.len());
        params.push(("liveChatId", self._live_chat_id.to_string()));
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._profile_image_size {
            params.push(("profileImageSize", value.to_string()));
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if let Some(value) = self._hl {
            params.push(("hl", value.to_string()));
        }
        for &field in ["alt", "liveChatId", "part", "profileImageSize", "pageToken", "maxResults", "hl"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveChat/messages";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The id of the live chat for which comments should be returned.
    ///
    /// Sets the *live chat id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn live_chat_id(mut self, new_value: &str) -> LiveChatMessageListCall<'a, C, A> {
        self._live_chat_id = new_value.to_string();
        self
    }
    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>liveChatComment</code> resource parts that the API response will
    /// include. Supported values are <code>id</code> and <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    ///
    /// **Settable Parts**
    /// 
    /// * *<code>id</code>*
    /// * *<code>snippet</code>*
    pub fn add_part(mut self, new_value: &str) -> LiveChatMessageListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Specifies the size of the profile image that should be
    /// returned for each user.
    ///
    /// Sets the *profile image size* query property to the given value.
    pub fn profile_image_size(mut self, new_value: u32) -> LiveChatMessageListCall<'a, C, A> {
        self._profile_image_size = Some(new_value);
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> property identify other pages that could be
    /// retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> LiveChatMessageListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> LiveChatMessageListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// Specifies the localization language in which the system messages
    /// should be returned.
    ///
    /// Sets the *hl* query property to the given value.
    pub fn hl(mut self, new_value: &str) -> LiveChatMessageListCall<'a, C, A> {
        self._hl = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveChatMessageListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveChatMessageListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveChatMessageListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes a chat message.
///
/// A builder for the *delete* method supported by a *liveChatMessage* resource.
/// It is not used directly, but through a `LiveChatMessageMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_chat_messages().delete("id")
///              .doit();
/// # }
/// ```
pub struct LiveChatMessageDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveChatMessageDeleteCall<'a, C, A> {}

impl<'a, C, A> LiveChatMessageDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveChatMessages.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(2 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        for &field in ["id"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/liveChat/messages";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> LiveChatMessageDeleteCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveChatMessageDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveChatMessageDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveChatMessageDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *liveChatMessage* resource.
/// It is not used directly, but through a `LiveChatMessageMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::LiveChatMessage;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = LiveChatMessage::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_chat_messages().insert(req)
///              .doit();
/// # }
/// ```
pub struct LiveChatMessageInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: LiveChatMessage,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveChatMessageInsertCall<'a, C, A> {}

impl<'a, C, A> LiveChatMessageInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveChatMessage)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveChatMessages.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveChat/messages";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: LiveChatMessage) -> LiveChatMessageInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes. It
    /// identifies the properties that the write operation will set as well as the
    /// properties that the API response will include. Set the parameter value to
    /// <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> LiveChatMessageInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveChatMessageInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveChatMessageInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveChatMessageInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *videoCategory* resource.
/// It is not used directly, but through a `VideoCategoryMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.video_categories().list("part")
///              .region_code("consetetur")
///              .add_id("diam")
///              .hl("accusam")
///              .doit();
/// # }
/// ```
pub struct VideoCategoryListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _region_code: Option<String>,
    _id: Vec<String>,
    _hl: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for VideoCategoryListCall<'a, C, A> {}

impl<'a, C, A> VideoCategoryListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, VideoCategoryListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.videoCategories.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._region_code {
            params.push(("regionCode", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        if let Some(value) = self._hl {
            params.push(("hl", value.to_string()));
        }
        for &field in ["alt", "part", "regionCode", "id", "hl"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/videoCategories";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>videoCategory</code> resource properties that the API response will
    /// include. Set the parameter value to <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> VideoCategoryListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    ///
    /// Sets the *region code* query property to the given value.
    pub fn region_code(mut self, new_value: &str) -> VideoCategoryListCall<'a, C, A> {
        self._region_code = Some(new_value.to_string());
        self
    }
    /// Returns the video categories with the given IDs for Stubby or Apiary.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> VideoCategoryListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    ///
    /// Sets the *hl* query property to the given value.
    pub fn hl(mut self, new_value: &str) -> VideoCategoryListCall<'a, C, A> {
        self._hl = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> VideoCategoryListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> VideoCategoryListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> VideoCategoryListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *i18nRegion* resource.
/// It is not used directly, but through a `I18nRegionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.i18n_regions().list("part")
///              .hl("consetetur")
///              .doit();
/// # }
/// ```
pub struct I18nRegionListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _hl: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for I18nRegionListCall<'a, C, A> {}

impl<'a, C, A> I18nRegionListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, I18nRegionListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.i18nRegions.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._hl {
            params.push(("hl", value.to_string()));
        }
        for &field in ["alt", "part", "hl"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/i18nRegions";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>i18nRegion</code> resource properties that the API response will
    /// include. Set the parameter value to <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> I18nRegionListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    ///
    /// Sets the *hl* query property to the given value.
    pub fn hl(mut self, new_value: &str) -> I18nRegionListCall<'a, C, A> {
        self._hl = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> I18nRegionListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> I18nRegionListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> I18nRegionListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *subscription* resource.
/// It is not used directly, but through a `SubscriptionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::Subscription;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = Subscription::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.subscriptions().insert(req)
///              .doit();
/// # }
/// ```
pub struct SubscriptionInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: Subscription,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for SubscriptionInsertCall<'a, C, A> {}

impl<'a, C, A> SubscriptionInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, Subscription)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.subscriptions.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/subscriptions";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: Subscription) -> SubscriptionInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will include.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> SubscriptionInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> SubscriptionInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> SubscriptionInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> SubscriptionInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *subscription* resource.
/// It is not used directly, but through a `SubscriptionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.subscriptions().list("part")
///              .page_token("aliquyam")
///              .order("elitr")
///              .on_behalf_of_content_owner_channel("ea")
///              .on_behalf_of_content_owner("et")
///              .my_subscribers(false)
///              .my_recent_subscribers(true)
///              .mine(false)
///              .max_results(94)
///              .add_id("dolore")
///              .for_channel_id("Lorem")
///              .channel_id("consetetur")
///              .doit();
/// # }
/// ```
pub struct SubscriptionListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _page_token: Option<String>,
    _order: Option<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _my_subscribers: Option<bool>,
    _my_recent_subscribers: Option<bool>,
    _mine: Option<bool>,
    _max_results: Option<u32>,
    _id: Vec<String>,
    _for_channel_id: Option<String>,
    _channel_id: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for SubscriptionListCall<'a, C, A> {}

impl<'a, C, A> SubscriptionListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, SubscriptionListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.subscriptions.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(14 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._order {
            params.push(("order", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._my_subscribers {
            params.push(("mySubscribers", value.to_string()));
        }
        if let Some(value) = self._my_recent_subscribers {
            params.push(("myRecentSubscribers", value.to_string()));
        }
        if let Some(value) = self._mine {
            params.push(("mine", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        if let Some(value) = self._for_channel_id {
            params.push(("forChannelId", value.to_string()));
        }
        if let Some(value) = self._channel_id {
            params.push(("channelId", value.to_string()));
        }
        for &field in ["alt", "part", "pageToken", "order", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner", "mySubscribers", "myRecentSubscribers", "mine", "maxResults", "id", "forChannelId", "channelId"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/subscriptions";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>subscription</code> resource
    /// properties that the API response will include.<br><br>If the parameter
    /// identifies a property that contains child properties, the child properties
    /// will be included in the response. For example, in a
    /// <code>subscription</code> resource, the <code>snippet</code> property
    /// contains other properties, such as a display title for the subscription. If
    /// you set <code><strong>part=snippet</strong></code>, the API response will
    /// also contain all of those nested properties.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> SubscriptionListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> SubscriptionListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// The order of the returned subscriptions
    ///
    /// Sets the *order* query property to the given value.
    pub fn order(mut self, new_value: &str) -> SubscriptionListCall<'a, C, A> {
        self._order = Some(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> SubscriptionListCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> SubscriptionListCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// Return the subscribers of the given channel owner.
    ///
    /// Sets the *my subscribers* query property to the given value.
    pub fn my_subscribers(mut self, new_value: bool) -> SubscriptionListCall<'a, C, A> {
        self._my_subscribers = Some(new_value);
        self
    }
    ///
    /// Sets the *my recent subscribers* query property to the given value.
    pub fn my_recent_subscribers(mut self, new_value: bool) -> SubscriptionListCall<'a, C, A> {
        self._my_recent_subscribers = Some(new_value);
        self
    }
    /// Flag for returning the subscriptions of the authenticated user.
    ///
    /// Sets the *mine* query property to the given value.
    pub fn mine(mut self, new_value: bool) -> SubscriptionListCall<'a, C, A> {
        self._mine = Some(new_value);
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> SubscriptionListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// Return the subscriptions with the given IDs for Stubby or Apiary.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> SubscriptionListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// Return the subscriptions to the subset of these channels that the
    /// authenticated user is subscribed to.
    ///
    /// Sets the *for channel id* query property to the given value.
    pub fn for_channel_id(mut self, new_value: &str) -> SubscriptionListCall<'a, C, A> {
        self._for_channel_id = Some(new_value.to_string());
        self
    }
    /// Return the subscriptions of the given channel owner.
    ///
    /// Sets the *channel id* query property to the given value.
    pub fn channel_id(mut self, new_value: &str) -> SubscriptionListCall<'a, C, A> {
        self._channel_id = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> SubscriptionListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> SubscriptionListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> SubscriptionListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes a resource.
///
/// A builder for the *delete* method supported by a *subscription* resource.
/// It is not used directly, but through a `SubscriptionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.subscriptions().delete("id")
///              .doit();
/// # }
/// ```
pub struct SubscriptionDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for SubscriptionDeleteCall<'a, C, A> {}

impl<'a, C, A> SubscriptionDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.subscriptions.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(2 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        for &field in ["id"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/subscriptions";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> SubscriptionDeleteCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> SubscriptionDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> SubscriptionDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> SubscriptionDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes a chat ban.
///
/// A builder for the *delete* method supported by a *liveChatBan* resource.
/// It is not used directly, but through a `LiveChatBanMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_chat_bans().delete("id")
///              .doit();
/// # }
/// ```
pub struct LiveChatBanDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveChatBanDeleteCall<'a, C, A> {}

impl<'a, C, A> LiveChatBanDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveChatBans.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(2 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        for &field in ["id"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/liveChat/bans";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> LiveChatBanDeleteCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveChatBanDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveChatBanDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveChatBanDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *liveChatBan* resource.
/// It is not used directly, but through a `LiveChatBanMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::LiveChatBan;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = LiveChatBan::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_chat_bans().insert(req)
///              .doit();
/// # }
/// ```
pub struct LiveChatBanInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: LiveChatBan,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveChatBanInsertCall<'a, C, A> {}

impl<'a, C, A> LiveChatBanInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveChatBan)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveChatBans.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveChat/bans";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: LiveChatBan) -> LiveChatBanInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response returns. Set the
    /// parameter value to <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> LiveChatBanInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveChatBanInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveChatBanInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveChatBanInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of sponsors that match the request criteria for a
/// channel.
///
/// A builder for the *list* method supported by a *sponsor* resource.
/// It is not used directly, but through a `SponsorMethods` instance.
///
/// **Settable Parts**
/// 
/// * *<code>id</code>*
/// * *<code>snippet</code>*
///
/// # Scopes
///
/// You will need authorization for at least one of the following scopes to make a valid call, possibly depending on *parts*:
///
/// * *https://www.googleapis.com/auth/youtube*
/// * *https://www.googleapis.com/auth/youtube.force-ssl*
/// * *https://www.googleapis.com/auth/youtube.readonly*
///
/// The default scope will be `Scope::Readonly`.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.sponsors().list("part")
///              .page_token("gubergren")
///              .max_results(28)
///              .filter("sadipscing")
///              .doit();
/// # }
/// ```
pub struct SponsorListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _page_token: Option<String>,
    _max_results: Option<u32>,
    _filter: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for SponsorListCall<'a, C, A> {}

impl<'a, C, A> SponsorListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, SponsorListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.sponsors.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if let Some(value) = self._filter {
            params.push(("filter", value.to_string()));
        }
        for &field in ["alt", "part", "pageToken", "maxResults", "filter"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/sponsors";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>sponsor</code> resource parts that the API response will include.
    /// Supported values are <code>id</code> and <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    ///
    /// **Settable Parts**
    /// 
    /// * *<code>id</code>*
    /// * *<code>snippet</code>*
    pub fn add_part(mut self, new_value: &str) -> SponsorListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> SponsorListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> SponsorListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// Parameter that specifies which channel sponsors to return.
    ///
    /// Sets the *filter* query property to the given value.
    pub fn filter(mut self, new_value: &str) -> SponsorListCall<'a, C, A> {
        self._filter = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> SponsorListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> SponsorListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> SponsorListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *videoAbuseReportReason* resource.
/// It is not used directly, but through a `VideoAbuseReportReasonMethods` instance.
///
/// **Settable Parts**
/// 
/// * *<code>id</code>*
/// * *<code>snippet</code>*
///
/// # Scopes
///
/// You will need authorization for at least one of the following scopes to make a valid call, possibly depending on *parts*:
///
/// * *https://www.googleapis.com/auth/youtube*
/// * *https://www.googleapis.com/auth/youtube.force-ssl*
/// * *https://www.googleapis.com/auth/youtube.readonly*
///
/// The default scope will be `Scope::Readonly`.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.video_abuse_report_reasons().list("part")
///              .hl("magna")
///              .doit();
/// # }
/// ```
pub struct VideoAbuseReportReasonListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _hl: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for VideoAbuseReportReasonListCall<'a, C, A> {}

impl<'a, C, A> VideoAbuseReportReasonListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, VideoAbuseReportReasonListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.videoAbuseReportReasons.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._hl {
            params.push(("hl", value.to_string()));
        }
        for &field in ["alt", "part", "hl"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/videoAbuseReportReasons";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>videoCategory</code> resource parts that the API response will
    /// include. Supported values are <code>id</code> and <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    ///
    /// **Settable Parts**
    /// 
    /// * *<code>id</code>*
    /// * *<code>snippet</code>*
    pub fn add_part(mut self, new_value: &str) -> VideoAbuseReportReasonListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    ///
    /// Sets the *hl* query property to the given value.
    pub fn hl(mut self, new_value: &str) -> VideoAbuseReportReasonListCall<'a, C, A> {
        self._hl = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> VideoAbuseReportReasonListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> VideoAbuseReportReasonListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> VideoAbuseReportReasonListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes a resource.
///
/// A builder for the *delete* method supported by a *thirdPartyLink* resource.
/// It is not used directly, but through a `ThirdPartyLinkMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.third_party_links().delete("linkingToken", "type")
///              .add_part("et")
///              .doit();
/// # }
/// ```
pub struct ThirdPartyLinkDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _linking_token: String,
    _type_: String,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
}

impl<'a, C, A> CallBuilder for ThirdPartyLinkDeleteCall<'a, C, A> {}

impl<'a, C, A> ThirdPartyLinkDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.thirdPartyLinks.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("linkingToken", self._linking_token.to_string()));
        params.push(("type", self._type_.to_string()));
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["linkingToken", "type", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/thirdPartyLinks";
        
        let mut key = self.hub.auth.borrow_mut().api_key();
        if key.is_none() {
            key = dlg.api_key();
        }
        match key {
            Some(value) => params.push(("key", value)),
            None => {
                dlg.finished(false);
                return Err(Error::MissingAPIKey)
            }
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()));

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// Delete the partner links with the given linking token.
    ///
    /// Sets the *linking token* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn linking_token(mut self, new_value: &str) -> ThirdPartyLinkDeleteCall<'a, C, A> {
        self._linking_token = new_value.to_string();
        self
    }
    /// Type of the link to be deleted.
    ///
    /// Sets the *type* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn type_(mut self, new_value: &str) -> ThirdPartyLinkDeleteCall<'a, C, A> {
        self._type_ = new_value.to_string();
        self
    }
    /// Do not use. Required for compatibility.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_part(mut self, new_value: &str) -> ThirdPartyLinkDeleteCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ThirdPartyLinkDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ThirdPartyLinkDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

}


/// Updates an existing resource.
///
/// A builder for the *update* method supported by a *thirdPartyLink* resource.
/// It is not used directly, but through a `ThirdPartyLinkMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::ThirdPartyLink;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = ThirdPartyLink::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.third_party_links().update(req)
///              .doit();
/// # }
/// ```
pub struct ThirdPartyLinkUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: ThirdPartyLink,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
}

impl<'a, C, A> CallBuilder for ThirdPartyLinkUpdateCall<'a, C, A> {}

impl<'a, C, A> ThirdPartyLinkUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, ThirdPartyLink)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.thirdPartyLinks.update",
                               http_method: hyper::method::Method::Put });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/thirdPartyLinks";
        
        let mut key = self.hub.auth.borrow_mut().api_key();
        if key.is_none() {
            key = dlg.api_key();
        }
        match key {
            Some(value) => params.push(("key", value)),
            None => {
                dlg.finished(false);
                return Err(Error::MissingAPIKey)
            }
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Put, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: ThirdPartyLink) -> ThirdPartyLinkUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>thirdPartyLink</code> resource parts that the API request and
    /// response will include. Supported values are <code>linkingToken</code>,
    /// <code>status</code>, and <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> ThirdPartyLinkUpdateCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ThirdPartyLinkUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ThirdPartyLinkUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *thirdPartyLink* resource.
/// It is not used directly, but through a `ThirdPartyLinkMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::ThirdPartyLink;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = ThirdPartyLink::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.third_party_links().insert(req)
///              .doit();
/// # }
/// ```
pub struct ThirdPartyLinkInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: ThirdPartyLink,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
}

impl<'a, C, A> CallBuilder for ThirdPartyLinkInsertCall<'a, C, A> {}

impl<'a, C, A> ThirdPartyLinkInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, ThirdPartyLink)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.thirdPartyLinks.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/thirdPartyLinks";
        
        let mut key = self.hub.auth.borrow_mut().api_key();
        if key.is_none() {
            key = dlg.api_key();
        }
        match key {
            Some(value) => params.push(("key", value)),
            None => {
                dlg.finished(false);
                return Err(Error::MissingAPIKey)
            }
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: ThirdPartyLink) -> ThirdPartyLinkInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>thirdPartyLink</code> resource parts that the API request and
    /// response will include. Supported values are <code>linkingToken</code>,
    /// <code>status</code>, and <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> ThirdPartyLinkInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ThirdPartyLinkInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ThirdPartyLinkInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *thirdPartyLink* resource.
/// It is not used directly, but through a `ThirdPartyLinkMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.third_party_links().list("part")
///              .type_("eos")
///              .linking_token("dolores")
///              .doit();
/// # }
/// ```
pub struct ThirdPartyLinkListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _type_: Option<String>,
    _linking_token: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
}

impl<'a, C, A> CallBuilder for ThirdPartyLinkListCall<'a, C, A> {}

impl<'a, C, A> ThirdPartyLinkListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, ThirdPartyLink)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.thirdPartyLinks.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._type_ {
            params.push(("type", value.to_string()));
        }
        if let Some(value) = self._linking_token {
            params.push(("linkingToken", value.to_string()));
        }
        for &field in ["alt", "part", "type", "linkingToken"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/thirdPartyLinks";
        
        let mut key = self.hub.auth.borrow_mut().api_key();
        if key.is_none() {
            key = dlg.api_key();
        }
        match key {
            Some(value) => params.push(("key", value)),
            None => {
                dlg.finished(false);
                return Err(Error::MissingAPIKey)
            }
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()));

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>thirdPartyLink</code> resource parts that the API response will
    /// include. Supported values are <code>linkingToken</code>,
    /// <code>status</code>, and <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> ThirdPartyLinkListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Get a third party link of the given type.
    ///
    /// Sets the *type* query property to the given value.
    pub fn type_(mut self, new_value: &str) -> ThirdPartyLinkListCall<'a, C, A> {
        self._type_ = Some(new_value.to_string());
        self
    }
    /// Get a third party link with the given linking token.
    ///
    /// Sets the *linking token* query property to the given value.
    pub fn linking_token(mut self, new_value: &str) -> ThirdPartyLinkListCall<'a, C, A> {
        self._linking_token = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ThirdPartyLinkListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ThirdPartyLinkListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

}


/// Retrieves a list of members that match the request criteria for a channel.
///
/// A builder for the *list* method supported by a *member* resource.
/// It is not used directly, but through a `MemberMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.members().list("part")
///              .page_token("consetetur")
///              .mode("vero")
///              .max_results(5)
///              .has_access_to_level("eos")
///              .filter_by_member_channel_id("justo")
///              .doit();
/// # }
/// ```
pub struct MemberListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _page_token: Option<String>,
    _mode: Option<String>,
    _max_results: Option<u32>,
    _has_access_to_level: Option<String>,
    _filter_by_member_channel_id: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for MemberListCall<'a, C, A> {}

impl<'a, C, A> MemberListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, MemberListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.members.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(8 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._mode {
            params.push(("mode", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if let Some(value) = self._has_access_to_level {
            params.push(("hasAccessToLevel", value.to_string()));
        }
        if let Some(value) = self._filter_by_member_channel_id {
            params.push(("filterByMemberChannelId", value.to_string()));
        }
        for &field in ["alt", "part", "pageToken", "mode", "maxResults", "hasAccessToLevel", "filterByMemberChannelId"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/members";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>member</code> resource parts that the API response will include. Set
    /// the parameter value to <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> MemberListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> MemberListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Parameter that specifies which channel members to return.
    ///
    /// Sets the *mode* query property to the given value.
    pub fn mode(mut self, new_value: &str) -> MemberListCall<'a, C, A> {
        self._mode = Some(new_value.to_string());
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> MemberListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// Filter members in the results set to the ones that have access to a level.
    ///
    /// Sets the *has access to level* query property to the given value.
    pub fn has_access_to_level(mut self, new_value: &str) -> MemberListCall<'a, C, A> {
        self._has_access_to_level = Some(new_value.to_string());
        self
    }
    /// Comma separated list of channel IDs. Only data about members that are part
    /// of this list will be included in the response.
    ///
    /// Sets the *filter by member channel id* query property to the given value.
    pub fn filter_by_member_channel_id(mut self, new_value: &str) -> MemberListCall<'a, C, A> {
        self._filter_by_member_channel_id = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> MemberListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> MemberListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> MemberListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Slate and recording control of the live broadcast.
/// Support actions: slate on/off, recording start/stop/pause/resume.
/// Design doc: goto/yt-api-liveBroadcast-control
///
/// A builder for the *control* method supported by a *liveBroadcast* resource.
/// It is not used directly, but through a `LiveBroadcastMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_broadcasts().control("id", "part")
///              .walltime("dolore")
///              .on_behalf_of_content_owner_channel("amet.")
///              .on_behalf_of_content_owner("dolore")
///              .offset_time_ms("magna")
///              .display_slate(false)
///              .doit();
/// # }
/// ```
pub struct LiveBroadcastControlCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _part: Vec<String>,
    _walltime: Option<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _offset_time_ms: Option<String>,
    _display_slate: Option<bool>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveBroadcastControlCall<'a, C, A> {}

impl<'a, C, A> LiveBroadcastControlCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveBroadcast)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveBroadcasts.control",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(9 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._walltime {
            params.push(("walltime", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._offset_time_ms {
            params.push(("offsetTimeMs", value.to_string()));
        }
        if let Some(value) = self._display_slate {
            params.push(("displaySlate", value.to_string()));
        }
        for &field in ["alt", "id", "part", "walltime", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner", "offsetTimeMs", "displaySlate"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveBroadcasts/control";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// Broadcast to operate.
    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> LiveBroadcastControlCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>liveBroadcast</code> resource
    /// properties that the API response will include. The <code>part</code> names
    /// that you can include in the parameter value are <code>id</code>,
    /// <code>snippet</code>, <code>contentDetails</code>, and <code>status</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> LiveBroadcastControlCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The wall clock time at which the action should be executed.
    /// Only one of offset_time_ms and walltime may be set at a time.
    ///
    /// Sets the *walltime* query property to the given value.
    pub fn walltime(mut self, new_value: &str) -> LiveBroadcastControlCall<'a, C, A> {
        self._walltime = Some(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> LiveBroadcastControlCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> LiveBroadcastControlCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The exact time when the actions (e.g. slate on) are executed.
    /// It is an offset from the first frame of the monitor stream.
    /// If not set, it means "now" or ASAP.
    /// This field should not be set if the monitor stream is disabled,
    /// otherwise an error will be returned.
    ///
    /// Sets the *offset time ms* query property to the given value.
    pub fn offset_time_ms(mut self, new_value: &str) -> LiveBroadcastControlCall<'a, C, A> {
        self._offset_time_ms = Some(new_value.to_string());
        self
    }
    /// Whether display or hide slate.
    ///
    /// Sets the *display slate* query property to the given value.
    pub fn display_slate(mut self, new_value: bool) -> LiveBroadcastControlCall<'a, C, A> {
        self._display_slate = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveBroadcastControlCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveBroadcastControlCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveBroadcastControlCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates an existing broadcast for the authenticated user.
///
/// A builder for the *update* method supported by a *liveBroadcast* resource.
/// It is not used directly, but through a `LiveBroadcastMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::LiveBroadcast;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = LiveBroadcast::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_broadcasts().update(req)
///              .on_behalf_of_content_owner_channel("magna")
///              .on_behalf_of_content_owner("ipsum")
///              .doit();
/// # }
/// ```
pub struct LiveBroadcastUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: LiveBroadcast,
    _part: Vec<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveBroadcastUpdateCall<'a, C, A> {}

impl<'a, C, A> LiveBroadcastUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveBroadcast)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveBroadcasts.update",
                               http_method: hyper::method::Method::Put });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveBroadcasts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Put, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: LiveBroadcast) -> LiveBroadcastUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will
    /// include.<br><br>The <code>part</code> properties that you can include in
    /// the parameter value are <code>id</code>, <code>snippet</code>,
    /// <code>contentDetails</code>, and <code>status</code>.<br><br>Note that this
    /// method will override the existing values for all of the mutable properties
    /// that are contained in any parts that the parameter value specifies. For
    /// example, a
    /// broadcast's privacy status is defined in the <code>status</code> part. As
    /// such, if your request is updating a private or unlisted broadcast, and the
    /// request's <code>part</code> parameter value includes the
    /// <code>status</code> part, the broadcast's privacy setting will be updated
    /// to whatever value the request body specifies. If the request body does not
    /// specify a value, the existing privacy setting will be removed and the
    /// broadcast will revert to the default privacy setting.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> LiveBroadcastUpdateCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> LiveBroadcastUpdateCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> LiveBroadcastUpdateCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveBroadcastUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveBroadcastUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveBroadcastUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new stream for the authenticated user.
///
/// A builder for the *insert* method supported by a *liveBroadcast* resource.
/// It is not used directly, but through a `LiveBroadcastMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::LiveBroadcast;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = LiveBroadcast::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_broadcasts().insert(req)
///              .on_behalf_of_content_owner_channel("invidunt")
///              .on_behalf_of_content_owner("accusam")
///              .doit();
/// # }
/// ```
pub struct LiveBroadcastInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: LiveBroadcast,
    _part: Vec<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveBroadcastInsertCall<'a, C, A> {}

impl<'a, C, A> LiveBroadcastInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveBroadcast)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveBroadcasts.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveBroadcasts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: LiveBroadcast) -> LiveBroadcastInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The <code><strong>part</strong></code> parameter serves two purposes in
    /// this operation. It identifies the properties that the write operation will
    /// set as well as the properties that the API response will
    /// include.<br><br>The <code>part</code> properties that you can include in
    /// the parameter value are <code>id</code>, <code>snippet</code>,
    /// <code>contentDetails</code>, and <code>status</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> LiveBroadcastInsertCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> LiveBroadcastInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> LiveBroadcastInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveBroadcastInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveBroadcastInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveBroadcastInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieve the list of broadcasts associated with the given channel.
///
/// A builder for the *list* method supported by a *liveBroadcast* resource.
/// It is not used directly, but through a `LiveBroadcastMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_broadcasts().list("part")
///              .page_token("diam")
///              .on_behalf_of_content_owner_channel("nonumy")
///              .on_behalf_of_content_owner("sed")
///              .mine(false)
///              .max_results(18)
///              .add_id("dolor")
///              .broadcast_type("Lorem")
///              .broadcast_status("dolor")
///              .doit();
/// # }
/// ```
pub struct LiveBroadcastListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _page_token: Option<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _mine: Option<bool>,
    _max_results: Option<u32>,
    _id: Vec<String>,
    _broadcast_type: Option<String>,
    _broadcast_status: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveBroadcastListCall<'a, C, A> {}

impl<'a, C, A> LiveBroadcastListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveBroadcastListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveBroadcasts.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(11 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._mine {
            params.push(("mine", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if self._id.len() > 0 {
            for f in self._id.iter() {
                params.push(("id", f.to_string()));
            }
        }
        if let Some(value) = self._broadcast_type {
            params.push(("broadcastType", value.to_string()));
        }
        if let Some(value) = self._broadcast_status {
            params.push(("broadcastStatus", value.to_string()));
        }
        for &field in ["alt", "part", "pageToken", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner", "mine", "maxResults", "id", "broadcastType", "broadcastStatus"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveBroadcasts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>liveBroadcast</code> resource
    /// properties that the API response will include. The <code>part</code> names
    /// that you can include in the parameter value are <code>id</code>,
    /// <code>snippet</code>, <code>contentDetails</code>, and <code>status</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> LiveBroadcastListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> LiveBroadcastListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> LiveBroadcastListCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> LiveBroadcastListCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    ///
    /// Sets the *mine* query property to the given value.
    pub fn mine(mut self, new_value: bool) -> LiveBroadcastListCall<'a, C, A> {
        self._mine = Some(new_value);
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> LiveBroadcastListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// Return broadcasts with the given ids from Stubby or Apiary.
    ///
    /// Append the given value to the *id* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_id(mut self, new_value: &str) -> LiveBroadcastListCall<'a, C, A> {
        self._id.push(new_value.to_string());
        self
    }
    /// Return only broadcasts with the selected type.
    ///
    /// Sets the *broadcast type* query property to the given value.
    pub fn broadcast_type(mut self, new_value: &str) -> LiveBroadcastListCall<'a, C, A> {
        self._broadcast_type = Some(new_value.to_string());
        self
    }
    /// Return broadcasts with a certain status, e.g. active broadcasts.
    ///
    /// Sets the *broadcast status* query property to the given value.
    pub fn broadcast_status(mut self, new_value: &str) -> LiveBroadcastListCall<'a, C, A> {
        self._broadcast_status = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveBroadcastListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveBroadcastListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveBroadcastListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Delete a given broadcast.
///
/// A builder for the *delete* method supported by a *liveBroadcast* resource.
/// It is not used directly, but through a `LiveBroadcastMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_broadcasts().delete("id")
///              .on_behalf_of_content_owner_channel("nonumy")
///              .on_behalf_of_content_owner("takimata")
///              .doit();
/// # }
/// ```
pub struct LiveBroadcastDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveBroadcastDeleteCall<'a, C, A> {}

impl<'a, C, A> LiveBroadcastDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<hyper::client::Response> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveBroadcasts.delete",
                               http_method: hyper::method::Method::Delete });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["id", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }


        let mut url = self.hub._base_url.clone() + "youtube/v3/liveBroadcasts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Delete, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = res;

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> LiveBroadcastDeleteCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> LiveBroadcastDeleteCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> LiveBroadcastDeleteCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveBroadcastDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveBroadcastDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveBroadcastDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Transition a broadcast to a given status.
///
/// A builder for the *transition* method supported by a *liveBroadcast* resource.
/// It is not used directly, but through a `LiveBroadcastMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_broadcasts().transition("id", "broadcastStatus", "part")
///              .on_behalf_of_content_owner_channel("amet.")
///              .on_behalf_of_content_owner("dolores")
///              .doit();
/// # }
/// ```
pub struct LiveBroadcastTransitionCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _broadcast_status: String,
    _part: Vec<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveBroadcastTransitionCall<'a, C, A> {}

impl<'a, C, A> LiveBroadcastTransitionCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveBroadcast)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveBroadcasts.transition",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(7 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        params.push(("broadcastStatus", self._broadcast_status.to_string()));
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "id", "broadcastStatus", "part", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveBroadcasts/transition";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// Broadcast to transition.
    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> LiveBroadcastTransitionCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// The status to which the broadcast is going to transition.
    ///
    /// Sets the *broadcast status* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn broadcast_status(mut self, new_value: &str) -> LiveBroadcastTransitionCall<'a, C, A> {
        self._broadcast_status = new_value.to_string();
        self
    }
    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>liveBroadcast</code> resource
    /// properties that the API response will include. The <code>part</code> names
    /// that you can include in the parameter value are <code>id</code>,
    /// <code>snippet</code>, <code>contentDetails</code>, and <code>status</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> LiveBroadcastTransitionCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> LiveBroadcastTransitionCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> LiveBroadcastTransitionCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveBroadcastTransitionCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveBroadcastTransitionCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveBroadcastTransitionCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Bind a broadcast to a stream.
///
/// A builder for the *bind* method supported by a *liveBroadcast* resource.
/// It is not used directly, but through a `LiveBroadcastMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.live_broadcasts().bind("id", "part")
///              .stream_id("sed")
///              .on_behalf_of_content_owner_channel("et")
///              .on_behalf_of_content_owner("aliquyam")
///              .doit();
/// # }
/// ```
pub struct LiveBroadcastBindCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _id: String,
    _part: Vec<String>,
    _stream_id: Option<String>,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for LiveBroadcastBindCall<'a, C, A> {}

impl<'a, C, A> LiveBroadcastBindCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, LiveBroadcast)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.liveBroadcasts.bind",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(7 + self._additional_params.len());
        params.push(("id", self._id.to_string()));
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._stream_id {
            params.push(("streamId", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "id", "part", "streamId", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/liveBroadcasts/bind";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// Broadcast to bind to the stream
    ///
    /// Sets the *id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn id(mut self, new_value: &str) -> LiveBroadcastBindCall<'a, C, A> {
        self._id = new_value.to_string();
        self
    }
    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>liveBroadcast</code> resource
    /// properties that the API response will include. The <code>part</code> names
    /// that you can include in the parameter value are <code>id</code>,
    /// <code>snippet</code>, <code>contentDetails</code>, and <code>status</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> LiveBroadcastBindCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Stream to bind, if not set unbind the current one.
    ///
    /// Sets the *stream id* query property to the given value.
    pub fn stream_id(mut self, new_value: &str) -> LiveBroadcastBindCall<'a, C, A> {
        self._stream_id = Some(new_value.to_string());
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> LiveBroadcastBindCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> LiveBroadcastBindCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> LiveBroadcastBindCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> LiveBroadcastBindCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> LiveBroadcastBindCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Inserts a new resource into this collection.
///
/// A builder for the *insert* method supported by a *channelBanner* resource.
/// It is not used directly, but through a `ChannelBannerMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::ChannelBannerResource;
/// use std::fs;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = ChannelBannerResource::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `upload(...)`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.channel_banners().insert(req)
///              .on_behalf_of_content_owner_channel("nonumy")
///              .on_behalf_of_content_owner("sit")
///              .channel_id("aliquyam")
///              .upload(fs::File::open("file.ext").unwrap(), "application/octet-stream".parse().unwrap());
/// # }
/// ```
pub struct ChannelBannerInsertCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: ChannelBannerResource,
    _on_behalf_of_content_owner_channel: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _channel_id: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ChannelBannerInsertCall<'a, C, A> {}

impl<'a, C, A> ChannelBannerInsertCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    fn doit<RS>(mut self, mut reader: RS, reader_mime_type: mime::Mime, protocol: &'static str) -> Result<(hyper::client::Response, ChannelBannerResource)>
		where RS: ReadSeek {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.channelBanners.insert",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        if let Some(value) = self._on_behalf_of_content_owner_channel {
            params.push(("onBehalfOfContentOwnerChannel", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._channel_id {
            params.push(("channelId", value.to_string()));
        }
        for &field in ["alt", "onBehalfOfContentOwnerChannel", "onBehalfOfContentOwner", "channelId"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let (mut url, upload_type) =
            if protocol == "simple" {
                (self.hub._root_url.clone() + "upload/youtube/v3/channelBanners/insert", "multipart")
            } else {
                unreachable!()
            };
        params.push(("uploadType", upload_type.to_string()));
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut mp_reader: MultiPartReader = Default::default();
                let (mut body_reader, content_type) = match protocol {
                    "simple" => {
                        mp_reader.reserve_exact(2);
                        let size = reader.seek(io::SeekFrom::End(0)).unwrap();
                    reader.seek(io::SeekFrom::Start(0)).unwrap();
                    if size > 6291456 {
                    	return Err(Error::UploadSizeLimitExceeded(size, 6291456))
                    }
                        mp_reader.add_part(&mut request_value_reader, request_size, json_mime_type.clone())
                                 .add_part(&mut reader, size, reader_mime_type.clone());
                        let mime_type = mp_reader.mime_type();
                        (&mut mp_reader as &mut dyn io::Read, ContentType(mime_type))
                    },
                    _ => (&mut request_value_reader as &mut dyn io::Read, ContentType(json_mime_type.clone())),
                };
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(content_type)
                    .body(&mut body_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }

    /// Upload media all at once.
    /// If the upload fails for whichever reason, all progress is lost.
    ///
    /// * *max size*: 6291456
    /// * *multipart*: yes
    /// * *valid mime types*: 'image/jpeg', 'image/png' and 'application/octet-stream'
    pub fn upload<RS>(self, stream: RS, mime_type: mime::Mime) -> Result<(hyper::client::Response, ChannelBannerResource)>
                where RS: ReadSeek {
        self.doit(stream, mime_type, "simple")
    }

    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: ChannelBannerResource) -> ChannelBannerInsertCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// This parameter can only be used in a properly <a
    /// href="/youtube/v3/guides/authentication">authorized request</a>.
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwnerChannel</strong></code> parameter
    /// specifies the YouTube channel ID of the channel to which a video is being
    /// added. This parameter is required when a request specifies a value for the
    /// <code>onBehalfOfContentOwner</code> parameter, and it can only be used in
    /// conjunction with that parameter. In addition, the request must be
    /// authorized using a CMS account that is linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies. Finally, the
    /// channel that the <code>onBehalfOfContentOwnerChannel</code> parameter value
    /// specifies must be linked to the content owner that the
    /// <code>onBehalfOfContentOwner</code> parameter specifies.<br><br>This
    /// parameter is intended for YouTube content partners that own and manage many
    /// different YouTube channels. It allows content owners to authenticate once
    /// and perform actions on behalf of the channel specified in the parameter
    /// value, without having to provide authentication credentials for each
    /// separate channel.
    ///
    /// Sets the *on behalf of content owner channel* query property to the given value.
    pub fn on_behalf_of_content_owner_channel(mut self, new_value: &str) -> ChannelBannerInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner_channel = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the request's authorization credentials identify a YouTube CMS user
    /// who is acting on behalf of the content owner specified in the parameter
    /// value. This parameter is intended for YouTube content partners that own and
    /// manage many different YouTube channels. It allows content owners to
    /// authenticate once and get access to all their video and channel data,
    /// without having to provide authentication credentials for each individual
    /// channel. The actual CMS account that the user authenticates with must be
    /// linked to the specified YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> ChannelBannerInsertCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// Unused, channel_id is currently derived from the security context of the
    /// requestor.
    ///
    /// Sets the *channel id* query property to the given value.
    pub fn channel_id(mut self, new_value: &str) -> ChannelBannerInsertCall<'a, C, A> {
        self._channel_id = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ChannelBannerInsertCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ChannelBannerInsertCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ChannelBannerInsertCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of search resources
///
/// A builder for the *list* method supported by a *search* resource.
/// It is not used directly, but through a `SearchMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.search().list("part")
///              .video_type("magna")
///              .video_syndicated("gubergren")
///              .video_license("sit")
///              .video_embeddable("gubergren")
///              .video_duration("sit")
///              .video_dimension("amet")
///              .video_definition("eirmod")
///              .video_category_id("sanctus")
///              .video_caption("Lorem")
///              .add_type("amet.")
///              .topic_id("diam")
///              .safe_search("eirmod")
///              .relevance_language("sadipscing")
///              .related_to_video_id("Lorem")
///              .region_code("sed")
///              .q("sit")
///              .published_before("dolore")
///              .published_after("et")
///              .page_token("At")
///              .order("sit")
///              .on_behalf_of_content_owner("ut")
///              .max_results(23)
///              .location_radius("tempor")
///              .location("et")
///              .for_mine(false)
///              .for_developer(true)
///              .for_content_owner(false)
///              .event_type("et")
///              .channel_type("clita")
///              .channel_id("sed")
///              .doit();
/// # }
/// ```
pub struct SearchListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _video_type: Option<String>,
    _video_syndicated: Option<String>,
    _video_license: Option<String>,
    _video_embeddable: Option<String>,
    _video_duration: Option<String>,
    _video_dimension: Option<String>,
    _video_definition: Option<String>,
    _video_category_id: Option<String>,
    _video_caption: Option<String>,
    _type_: Vec<String>,
    _topic_id: Option<String>,
    _safe_search: Option<String>,
    _relevance_language: Option<String>,
    _related_to_video_id: Option<String>,
    _region_code: Option<String>,
    _q: Option<String>,
    _published_before: Option<String>,
    _published_after: Option<String>,
    _page_token: Option<String>,
    _order: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _max_results: Option<u32>,
    _location_radius: Option<String>,
    _location: Option<String>,
    _for_mine: Option<bool>,
    _for_developer: Option<bool>,
    _for_content_owner: Option<bool>,
    _event_type: Option<String>,
    _channel_type: Option<String>,
    _channel_id: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for SearchListCall<'a, C, A> {}

impl<'a, C, A> SearchListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, SearchListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.search.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(33 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._video_type {
            params.push(("videoType", value.to_string()));
        }
        if let Some(value) = self._video_syndicated {
            params.push(("videoSyndicated", value.to_string()));
        }
        if let Some(value) = self._video_license {
            params.push(("videoLicense", value.to_string()));
        }
        if let Some(value) = self._video_embeddable {
            params.push(("videoEmbeddable", value.to_string()));
        }
        if let Some(value) = self._video_duration {
            params.push(("videoDuration", value.to_string()));
        }
        if let Some(value) = self._video_dimension {
            params.push(("videoDimension", value.to_string()));
        }
        if let Some(value) = self._video_definition {
            params.push(("videoDefinition", value.to_string()));
        }
        if let Some(value) = self._video_category_id {
            params.push(("videoCategoryId", value.to_string()));
        }
        if let Some(value) = self._video_caption {
            params.push(("videoCaption", value.to_string()));
        }
        if self._type_.len() > 0 {
            for f in self._type_.iter() {
                params.push(("type", f.to_string()));
            }
        }
        if let Some(value) = self._topic_id {
            params.push(("topicId", value.to_string()));
        }
        if let Some(value) = self._safe_search {
            params.push(("safeSearch", value.to_string()));
        }
        if let Some(value) = self._relevance_language {
            params.push(("relevanceLanguage", value.to_string()));
        }
        if let Some(value) = self._related_to_video_id {
            params.push(("relatedToVideoId", value.to_string()));
        }
        if let Some(value) = self._region_code {
            params.push(("regionCode", value.to_string()));
        }
        if let Some(value) = self._q {
            params.push(("q", value.to_string()));
        }
        if let Some(value) = self._published_before {
            params.push(("publishedBefore", value.to_string()));
        }
        if let Some(value) = self._published_after {
            params.push(("publishedAfter", value.to_string()));
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._order {
            params.push(("order", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if let Some(value) = self._location_radius {
            params.push(("locationRadius", value.to_string()));
        }
        if let Some(value) = self._location {
            params.push(("location", value.to_string()));
        }
        if let Some(value) = self._for_mine {
            params.push(("forMine", value.to_string()));
        }
        if let Some(value) = self._for_developer {
            params.push(("forDeveloper", value.to_string()));
        }
        if let Some(value) = self._for_content_owner {
            params.push(("forContentOwner", value.to_string()));
        }
        if let Some(value) = self._event_type {
            params.push(("eventType", value.to_string()));
        }
        if let Some(value) = self._channel_type {
            params.push(("channelType", value.to_string()));
        }
        if let Some(value) = self._channel_id {
            params.push(("channelId", value.to_string()));
        }
        for &field in ["alt", "part", "videoType", "videoSyndicated", "videoLicense", "videoEmbeddable", "videoDuration", "videoDimension", "videoDefinition", "videoCategoryId", "videoCaption", "type", "topicId", "safeSearch", "relevanceLanguage", "relatedToVideoId", "regionCode", "q", "publishedBefore", "publishedAfter", "pageToken", "order", "onBehalfOfContentOwner", "maxResults", "locationRadius", "location", "forMine", "forDeveloper", "forContentOwner", "eventType", "channelType", "channelId"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/search";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies a
    /// comma-separated list of one or more <code>search</code> resource properties
    /// that the API response will include. Set the parameter value to
    /// <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Filter on videos of a specific type.
    ///
    /// Sets the *video type* query property to the given value.
    pub fn video_type(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._video_type = Some(new_value.to_string());
        self
    }
    /// Filter on syndicated videos.
    ///
    /// Sets the *video syndicated* query property to the given value.
    pub fn video_syndicated(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._video_syndicated = Some(new_value.to_string());
        self
    }
    /// Filter on the license of the videos.
    ///
    /// Sets the *video license* query property to the given value.
    pub fn video_license(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._video_license = Some(new_value.to_string());
        self
    }
    /// Filter on embeddable videos.
    ///
    /// Sets the *video embeddable* query property to the given value.
    pub fn video_embeddable(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._video_embeddable = Some(new_value.to_string());
        self
    }
    /// Filter on the duration of the videos.
    ///
    /// Sets the *video duration* query property to the given value.
    pub fn video_duration(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._video_duration = Some(new_value.to_string());
        self
    }
    /// Filter on 3d videos.
    ///
    /// Sets the *video dimension* query property to the given value.
    pub fn video_dimension(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._video_dimension = Some(new_value.to_string());
        self
    }
    /// Filter on the definition of the videos.
    ///
    /// Sets the *video definition* query property to the given value.
    pub fn video_definition(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._video_definition = Some(new_value.to_string());
        self
    }
    /// Filter on videos in a specific category.
    ///
    /// Sets the *video category id* query property to the given value.
    pub fn video_category_id(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._video_category_id = Some(new_value.to_string());
        self
    }
    /// Filter on the presence of captions on the videos.
    ///
    /// Sets the *video caption* query property to the given value.
    pub fn video_caption(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._video_caption = Some(new_value.to_string());
        self
    }
    /// Restrict results to a particular set of resource types from One Platform.
    ///
    /// Append the given value to the *type* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_type(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._type_.push(new_value.to_string());
        self
    }
    /// Restrict results to a particular topic.
    ///
    /// Sets the *topic id* query property to the given value.
    pub fn topic_id(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._topic_id = Some(new_value.to_string());
        self
    }
    /// Indicates whether the search results should include restricted content as
    /// well as standard content.
    ///
    /// Sets the *safe search* query property to the given value.
    pub fn safe_search(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._safe_search = Some(new_value.to_string());
        self
    }
    /// Return results relevant to this language.
    ///
    /// Sets the *relevance language* query property to the given value.
    pub fn relevance_language(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._relevance_language = Some(new_value.to_string());
        self
    }
    /// Search related to a resource.
    ///
    /// Sets the *related to video id* query property to the given value.
    pub fn related_to_video_id(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._related_to_video_id = Some(new_value.to_string());
        self
    }
    /// Display the content as seen by viewers in this country.
    ///
    /// Sets the *region code* query property to the given value.
    pub fn region_code(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._region_code = Some(new_value.to_string());
        self
    }
    /// Textual search terms to match.
    ///
    /// Sets the *q* query property to the given value.
    pub fn q(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._q = Some(new_value.to_string());
        self
    }
    /// Filter on resources published before this date.
    ///
    /// Sets the *published before* query property to the given value.
    pub fn published_before(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._published_before = Some(new_value.to_string());
        self
    }
    /// Filter on resources published after this date.
    ///
    /// Sets the *published after* query property to the given value.
    pub fn published_after(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._published_after = Some(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Sort order of the results.
    ///
    /// Sets the *order* query property to the given value.
    pub fn order(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._order = Some(new_value.to_string());
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The CMS
    /// account that the user authenticates with must be linked to the specified
    /// YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> SearchListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// Filter on distance from the location (specified above).
    ///
    /// Sets the *location radius* query property to the given value.
    pub fn location_radius(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._location_radius = Some(new_value.to_string());
        self
    }
    /// Filter on location of the video
    ///
    /// Sets the *location* query property to the given value.
    pub fn location(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._location = Some(new_value.to_string());
        self
    }
    /// Search for the private videos of the authenticated user.
    ///
    /// Sets the *for mine* query property to the given value.
    pub fn for_mine(mut self, new_value: bool) -> SearchListCall<'a, C, A> {
        self._for_mine = Some(new_value);
        self
    }
    /// Restrict the search to only retrieve videos uploaded using the project id
    /// of the authenticated user.
    ///
    /// Sets the *for developer* query property to the given value.
    pub fn for_developer(mut self, new_value: bool) -> SearchListCall<'a, C, A> {
        self._for_developer = Some(new_value);
        self
    }
    /// Search owned by a content owner.
    ///
    /// Sets the *for content owner* query property to the given value.
    pub fn for_content_owner(mut self, new_value: bool) -> SearchListCall<'a, C, A> {
        self._for_content_owner = Some(new_value);
        self
    }
    /// Filter on the livestream status of the videos.
    ///
    /// Sets the *event type* query property to the given value.
    pub fn event_type(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._event_type = Some(new_value.to_string());
        self
    }
    /// Add a filter on the channel search.
    ///
    /// Sets the *channel type* query property to the given value.
    pub fn channel_type(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._channel_type = Some(new_value.to_string());
        self
    }
    /// Filter on resources belonging to this channelId.
    ///
    /// Sets the *channel id* query property to the given value.
    pub fn channel_id(mut self, new_value: &str) -> SearchListCall<'a, C, A> {
        self._channel_id = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> SearchListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> SearchListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> SearchListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a list of resources, possibly filtered.
///
/// A builder for the *list* method supported by a *superChatEvent* resource.
/// It is not used directly, but through a `SuperChatEventMethods` instance.
///
/// **Settable Parts**
/// 
/// * *<code>id</code>*
/// * *<code>snippet</code>*
///
/// # Scopes
///
/// You will need authorization for at least one of the following scopes to make a valid call, possibly depending on *parts*:
///
/// * *https://www.googleapis.com/auth/youtube*
/// * *https://www.googleapis.com/auth/youtube.force-ssl*
/// * *https://www.googleapis.com/auth/youtube.readonly*
///
/// The default scope will be `Scope::Readonly`.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.super_chat_events().list("part")
///              .page_token("clita")
///              .max_results(27)
///              .hl("amet")
///              .doit();
/// # }
/// ```
pub struct SuperChatEventListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _page_token: Option<String>,
    _max_results: Option<u32>,
    _hl: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for SuperChatEventListCall<'a, C, A> {}

impl<'a, C, A> SuperChatEventListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, SuperChatEventListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.superChatEvents.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._max_results {
            params.push(("maxResults", value.to_string()));
        }
        if let Some(value) = self._hl {
            params.push(("hl", value.to_string()));
        }
        for &field in ["alt", "part", "pageToken", "maxResults", "hl"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/superChatEvents";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Readonly.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The <code><strong>part</strong></code> parameter specifies the
    /// <code>superChatEvent</code> resource parts that the API response will
    /// include. Supported values are <code>id</code> and <code>snippet</code>.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    ///
    /// **Settable Parts**
    /// 
    /// * *<code>id</code>*
    /// * *<code>snippet</code>*
    pub fn add_part(mut self, new_value: &str) -> SuperChatEventListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The <code><strong>pageToken</strong></code> parameter identifies a specific
    /// page in the result set that should be returned. In an API response, the
    /// <code>nextPageToken</code> and <code>prevPageToken</code> properties
    /// identify other pages that could be retrieved.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> SuperChatEventListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// The <code><strong>maxResults</strong></code> parameter specifies the
    /// maximum number of items that should be returned in the result set.
    ///
    /// Sets the *max results* query property to the given value.
    pub fn max_results(mut self, new_value: u32) -> SuperChatEventListCall<'a, C, A> {
        self._max_results = Some(new_value);
        self
    }
    /// Return rendered funding amounts in specified language.
    ///
    /// Sets the *hl* query property to the given value.
    pub fn hl(mut self, new_value: &str) -> SuperChatEventListCall<'a, C, A> {
        self._hl = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> SuperChatEventListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> SuperChatEventListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Readonly`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> SuperChatEventListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// As this is not an insert in a strict sense (it supports uploading/setting
/// of a thumbnail for multiple videos, which doesn't result in creation of a
/// single resource), I use a custom verb here.
///
/// A builder for the *set* method supported by a *thumbnail* resource.
/// It is not used directly, but through a `ThumbnailMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use std::fs;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `upload(...)`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.thumbnails().set("videoId")
///              .on_behalf_of_content_owner("takimata")
///              .upload(fs::File::open("file.ext").unwrap(), "application/octet-stream".parse().unwrap());
/// # }
/// ```
pub struct ThumbnailSetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _video_id: String,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ThumbnailSetCall<'a, C, A> {}

impl<'a, C, A> ThumbnailSetCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    fn doit<RS>(mut self, mut reader: RS, reader_mime_type: mime::Mime, protocol: &'static str) -> Result<(hyper::client::Response, ThumbnailSetResponse)>
		where RS: ReadSeek {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.thumbnails.set",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("videoId", self._video_id.to_string()));
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "videoId", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let (mut url, upload_type) =
            if protocol == "simple" {
                (self.hub._root_url.clone() + "upload/youtube/v3/thumbnails/set", "multipart")
            } else {
                unreachable!()
            };
        params.push(("uploadType", upload_type.to_string()));
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());
                if protocol == "simple" {
                    let size = reader.seek(io::SeekFrom::End(0)).unwrap();
                reader.seek(io::SeekFrom::Start(0)).unwrap();
                if size > 2097152 {
                	return Err(Error::UploadSizeLimitExceeded(size, 2097152))
                }
                    req = req.header(ContentType(reader_mime_type.clone()))
                             .header(ContentLength(size))
                             .body(&mut reader);
                }

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }

    /// Upload media all at once.
    /// If the upload fails for whichever reason, all progress is lost.
    ///
    /// * *max size*: 2097152
    /// * *multipart*: yes
    /// * *valid mime types*: 'image/jpeg', 'image/png' and 'application/octet-stream'
    pub fn upload<RS>(self, stream: RS, mime_type: mime::Mime) -> Result<(hyper::client::Response, ThumbnailSetResponse)>
                where RS: ReadSeek {
        self.doit(stream, mime_type, "simple")
    }

    /// Returns the Thumbnail with the given video IDs for Stubby or Apiary.
    ///
    /// Sets the *video id* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn video_id(mut self, new_value: &str) -> ThumbnailSetCall<'a, C, A> {
        self._video_id = new_value.to_string();
        self
    }
    /// <strong>Note:</strong> This parameter is intended exclusively for YouTube
    /// content partners.<br><br>The
    /// <code><strong>onBehalfOfContentOwner</strong></code> parameter indicates
    /// that the
    /// request's authorization credentials identify a YouTube CMS user who is
    /// acting on behalf of the content owner specified in the parameter value.
    /// This parameter is intended for YouTube content partners that own and manage
    /// many different YouTube channels. It allows content owners to authenticate
    /// once and get access to all their video and channel data, without having to
    /// provide authentication credentials for each individual channel. The actual
    /// CMS account that the user authenticates with must be linked to the
    /// specified YouTube content owner.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> ThumbnailSetCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> ThumbnailSetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ThumbnailSetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ThumbnailSetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates infocards for a given video.
/// Note:
/// * If the card id is not provided, a new card will be created.
/// * If the card id is provided, that card will be updated.
/// * Existing cards will be discarded if they're not included in the request.
///
/// A builder for the *v3.infocards* method supported by a *youtube* resource.
/// It is not used directly, but through a `YoutubeMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::InfoCards;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = InfoCards::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.youtube().v3_infocards(req)
///              .video_id("sit")
///              .on_behalf_of_content_owner("labore")
///              .doit();
/// # }
/// ```
pub struct YoutubeV3InfocardCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: InfoCards,
    _part: Vec<String>,
    _video_id: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for YoutubeV3InfocardCall<'a, C, A> {}

impl<'a, C, A> YoutubeV3InfocardCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, InfoCards)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.youtube.v3.infocards",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        if self._part.len() == 0 {
            self._part = self._request.to_parts();
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._video_id {
            params.push(("videoId", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "videoId", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/infocards";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone())
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: InfoCards) -> YoutubeV3InfocardCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The properties to update.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> YoutubeV3InfocardCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Encrypted id of the video.
    ///
    /// Sets the *video id* query property to the given value.
    pub fn video_id(mut self, new_value: &str) -> YoutubeV3InfocardCall<'a, C, A> {
        self._video_id = Some(new_value.to_string());
        self
    }
    /// Content owner of the video.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> YoutubeV3InfocardCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> YoutubeV3InfocardCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> YoutubeV3InfocardCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> YoutubeV3InfocardCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// POST method.
///
/// A builder for the *v3.tests.create* method supported by a *youtube* resource.
/// It is not used directly, but through a `YoutubeMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// use youtube3::TestItem;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = TestItem::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.youtube().v3_tests_create(req)
///              .add_part("nonumy")
///              .doit();
/// # }
/// ```
pub struct YoutubeV3TestCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _request: TestItem,
    _part: Vec<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
}

impl<'a, C, A> CallBuilder for YoutubeV3TestCreateCall<'a, C, A> {}

impl<'a, C, A> YoutubeV3TestCreateCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, TestItem)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.youtube.v3.tests.create",
                               http_method: hyper::method::Method::Post });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        if self._part.is_none() {
            self._part = Some(self._request.to_parts());
        }
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        for &field in ["alt", "part"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/tests";
        
        let mut key = self.hub.auth.borrow_mut().api_key();
        if key.is_none() {
            key = dlg.api_key();
        }
        match key {
            Some(value) => params.push(("key", value)),
            None => {
                dlg.finished(false);
                return Err(Error::MissingAPIKey)
            }
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Post, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: TestItem) -> YoutubeV3TestCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the *parts* list is automatically derived from *Resource* passed in
    /// during instantiation and indicates which values you are passing, the response would contain the very same parts.
    /// This may not always be desirable, as you can obtain (newly generated) parts you cannot pass in,
    /// like statistics that are generated server side. Therefore you should use this method to specify
    /// the parts you provide in addition to the ones you want in the response.
    pub fn add_part(mut self, new_value: &str) -> YoutubeV3TestCreateCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> YoutubeV3TestCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> YoutubeV3TestCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

}


/// Retrieves all infocards for a given video.
///
/// A builder for the *v3.infocards.list* method supported by a *youtube* resource.
/// It is not used directly, but through a `YoutubeMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_youtube3 as youtube3;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use youtube3::YouTube;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = YouTube::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.youtube().v3_infocards_list("part")
///              .video_id("gubergren")
///              .on_behalf_of_content_owner("erat")
///              .doit();
/// # }
/// ```
pub struct YoutubeV3InfocardListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a YouTube<C, A>,
    _part: Vec<String>,
    _video_id: Option<String>,
    _on_behalf_of_content_owner: Option<String>,
    _delegate: Option<&'a mut dyn Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for YoutubeV3InfocardListCall<'a, C, A> {}

impl<'a, C, A> YoutubeV3InfocardListCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, InfocardListResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut dyn Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "youtube.youtube.v3.infocards.list",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        if self._part.len() > 0 {
            for f in self._part.iter() {
                params.push(("part", f.to_string()));
            }
        }
        if let Some(value) = self._video_id {
            params.push(("videoId", value.to_string()));
        }
        if let Some(value) = self._on_behalf_of_content_owner {
            params.push(("onBehalfOfContentOwner", value.to_string()));
        }
        for &field in ["alt", "part", "videoId", "onBehalfOfContentOwner"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "youtube/v3/infocards";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::Full.as_ref().to_string(), ());
        }


        let url = hyper::Url::parse_with_params(&url, params).unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(err) => {
                    match  dlg.token(&*err) {
                        Some(token) => token,
                        None => {
                            dlg.finished(false);
                            return Err(Error::MissingToken(err))
                        }
                    }
                }
            };
            let auth_header = Authorization(Bearer { token: token.access_token });
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, url.clone())
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(auth_header.clone());

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();

                        let json_server_error = json::from_str::<JsonServerError>(&json_err).ok();
                        let server_error = json::from_str::<ServerError>(&json_err)
                            .or_else(|_| json::from_str::<ErrorResponse>(&json_err).map(|r| r.error))
                            .ok();

                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json_server_error,
                                                              server_error) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    /// The properties to return.
    ///
    /// Append the given value to the *part* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn add_part(mut self, new_value: &str) -> YoutubeV3InfocardListCall<'a, C, A> {
        self._part.push(new_value.to_string());
        self
    }
    /// Encrypted id of the video.
    ///
    /// Sets the *video id* query property to the given value.
    pub fn video_id(mut self, new_value: &str) -> YoutubeV3InfocardListCall<'a, C, A> {
        self._video_id = Some(new_value.to_string());
        self
    }
    /// Content owner of the video.
    ///
    /// Sets the *on behalf of content owner* query property to the given value.
    pub fn on_behalf_of_content_owner(mut self, new_value: &str) -> YoutubeV3InfocardListCall<'a, C, A> {
        self._on_behalf_of_content_owner = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut dyn Delegate) -> YoutubeV3InfocardListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> YoutubeV3InfocardListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::Full`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> YoutubeV3InfocardListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}



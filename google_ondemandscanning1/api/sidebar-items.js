initSidebarItems({"enum":[["Scope","Identifies the an OAuth2 authorization scope. A scope is needed when requesting an authorization token."]],"struct":[["AliasContext","An alias to a repo revision."],["AnalyzePackagesRequestV1","AnalyzePackagesRequest is the request to analyze a list of packages and create Vulnerability Occurrences for it."],["Artifact","Artifact describes a build product."],["AttestationOccurrence","Occurrence that represents a single \"attestation\". The authenticity of an attestation can be verified using the attached signature. If the verifier trusts the public key of the signer, then verifying the signature is sufficient to establish trust. In this circumstance, the authority to which this attestation is attached is primarily useful for lookup (how to find this attestation if you already know the authority and artifact to be verified) and intent (for which authority this attestation was intended to sign."],["BuildOccurrence","Details of a build occurrence."],["BuildProvenance","Provenance of a build. Contains all information needed to verify the full details about the build from source to completion."],["Category","The category to which the update belongs."],["CloudRepoSourceContext","A CloudRepoSourceContext denotes a particular revision in a Google Cloud Source Repo."],["Command","Command describes a step performed as part of the build pipeline."],["DeploymentOccurrence","The period during which some deployable was active in a runtime."],["DiscoveryOccurrence","Provides information about the analysis status of a discovered resource."],["Empty","A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON representation for `Empty` is empty JSON object `{}`."],["FileHashes","Container message for hashes of byte content of files, used in source messages to verify integrity of source input to the build."],["Fingerprint","A set of properties that uniquely identify a given Docker image."],["GerritSourceContext","A SourceContext referring to a Gerrit project."],["GitSourceContext","A GitSourceContext denotes a particular revision in a third party Git repository (e.g., GitHub)."],["Hash","Container message for hash values."],["Identity","The unique identifier of the update."],["ImageOccurrence","Details of the derived image portion of the DockerImage relationship. This image would be produced from a Dockerfile with FROM ."],["Jwt","There is no detailed description."],["Layer","Layer holds metadata specific to a layer of a Docker image."],["ListOperationsResponse","The response message for Operations.ListOperations."],["ListVulnerabilitiesResponseV1","ListVulnerabilitiesResponse contains a single page of vulnerabilities resulting from a scan."],["Location","An occurrence of a particular package installation found within a system's filesystem. E.g., glibc was found in `/var/lib/dpkg/status`."],["Occurrence","An instance of an analysis type that has been found on a resource."],["OnDemandScanning","Central instance to access all OnDemandScanning related resource activities"],["Operation","This resource represents a long-running operation that is the result of a network API call."],["PackageData","There is no detailed description."],["PackageIssue","A detail for a distro and package this vulnerability occurrence was found in and its associated fix (if one is available)."],["PackageOccurrence","Details on how a particular software package was installed on a system."],["ProjectLocationOperationCancelCall","Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`."],["ProjectLocationOperationDeleteCall","Deletes a long-running operation. This method indicates that the client is no longer interested in the operation result. It does not cancel the operation. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`."],["ProjectLocationOperationGetCall","Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service."],["ProjectLocationOperationListCall","Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`. NOTE: the `name` binding allows API services to override the binding to use different resource name schemes, such as `users/*/operations`. To override the binding, API services can add a binding such as `\"/v1/{name=users/*}/operations\"` to their service configuration. For backwards compatibility, the default name includes the operations collection id, however overriding users must ensure the name binding is the parent resource, without the operations collection id."],["ProjectLocationOperationWaitCall","Waits until the specified long-running operation is done or reaches at most a specified timeout, returning the latest state. If the operation is already done, the latest state is immediately returned. If the timeout specified is greater than the default HTTP/RPC timeout, the HTTP/RPC timeout is used. If the server does not support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method is on a best-effort basis. It may return the latest state before the specified timeout (including immediately), meaning even an immediate response is no guarantee that the operation is done."],["ProjectLocationScanAnalyzePackageCall","Initiates an analysis of the provided packages."],["ProjectLocationScanVulnerabilityListCall","Lists vulnerabilities resulting from a successfully completed scan."],["ProjectMethods","A builder providing access to all methods supported on project resources. It is not used directly, but through the `OnDemandScanning` hub."],["ProjectRepoId","Selects a repo using a Google Cloud Platform project ID (e.g., winged-cargo-31) and a repo name within that project."],["RelatedUrl","Metadata for any related URL information."],["RepoId","A unique identifier for a Cloud Repo."],["Signature","Verifiers (e.g. Kritis implementations) MUST verify signatures with respect to the trust anchors defined in policy (e.g. a Kritis policy). Typically this means that the verifier has been configured with a map from `public_key_id` to public key material (and any required parameters, e.g. signing algorithm). In particular, verification implementations MUST NOT treat the signature `public_key_id` as anything more than a key lookup hint. The `public_key_id` DOES NOT validate or authenticate a public key; it only provides a mechanism for quickly selecting a public key ALREADY CONFIGURED on the verifier through a trusted channel. Verification implementations MUST reject signatures in any of the following circumstances: * The `public_key_id` is not recognized by the verifier. * The public key that `public_key_id` refers to does not verify the signature with respect to the payload. The `signature` contents SHOULD NOT be \"attached\" (where the payload is included with the serialized `signature` bytes). Verifiers MUST ignore any \"attached\" payload and only verify signatures with respect to explicitly provided payload (e.g. a `payload` field on the proto message that holds this Signature, or the canonical serialization of the proto message that holds this signature)."],["Source","Source describes the location of the source used for the build."],["SourceContext","A SourceContext is a reference to a tree of files. A SourceContext together with a path point to a unique revision of a single file or directory."],["Status","The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC. Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the API Design Guide."],["UpgradeDistribution","The Upgrade Distribution represents metadata about the Upgrade for each operating system (CPE). Some distributions have additional metadata around updates, classifying them into various categories and severities."],["UpgradeOccurrence","An Upgrade Occurrence represents that a specific resource_url could install a specific upgrade. This presence is supplied via local sources (i.e. it is present in the mirror and the running system has noticed its availability). For Windows, both distribution and windows_update contain information for the Windows update."],["Version","Version contains structured information about the version of a package."],["VulnerabilityOccurrence","An occurrence of a severity vulnerability on a resource."],["WindowsUpdate","Windows Update represents the metadata about the update for the Windows operating system. The fields in this message come from the Windows Update API documented at https://docs.microsoft.com/en-us/windows/win32/api/wuapi/nn-wuapi-iupdate."]]});